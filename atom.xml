<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://localhost:4000</id>
    <title>tangyin</title>
    <updated>2023-08-15T11:18:16.878Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://localhost:4000"/>
    <link rel="self" href="http://localhost:4000/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>http://localhost:4000/images/avatar.png</logo>
    <icon>http://localhost:4000/favicon.ico</icon>
    <rights>All rights reserved 2023, tangyin</rights>
    <entry>
        <title type="html"><![CDATA[单元测试的一些基础知识]]></title>
        <id>http://localhost:4000/post/dan-yuan-ce-shi-de-yi-xie-ji-chu-zhi-shi/</id>
        <link href="http://localhost:4000/post/dan-yuan-ce-shi-de-yi-xie-ji-chu-zhi-shi/">
        </link>
        <updated>2023-08-14T13:08:11.000Z</updated>
        <summary type="html"><![CDATA[<p>🐶🐶关于单元测试的小知识<br>
🐱🐱本人菜鸡，说错勿怪</p>
]]></summary>
        <content type="html"><![CDATA[<p>🐶🐶关于单元测试的小知识<br>
🐱🐱本人菜鸡，说错勿怪</p>
<!-- more -->
<h1 id="一-什么是单元测试">一、什么是单元测试</h1>
<p>单元测试是为了保证代码在基本功能正确，因为代码经常会修改，每次修改完之后如果手动测试太花费时间，单元测试写好之后可以随时跑。</p>
<p>单元测试类似于网页设计时的代码校验，一般用白盒测试进去检测，当然也分静态和动态测试之分，单元测试主要是检测这部分代码ok不，不行就记录下来修改，这个校验过程叫回归测试，通过了单元测试，就到下一环节。<br>
集成测试，集测相当于组装测试，把网站开发小组各自通过的模块（单元测试）组装在一起集成一个面，多个集成测试就串起一个系统，进行系统测试，最后到验收测试，大体上测试分开  单元-集成-系统-验收，四大测试流程</p>
<p>不同的单元测试框架有不同的使用方法，一般来说会输出测试报告，告诉你哪些测试用例成功了，哪些测试用例失败了。</p>
<h1 id="二-单元测试案例gtest">二、单元测试案例（gtest）</h1>
<p>在vs2019中，内置gtest测试功能，选择创建新项目---&gt;点击搜索---&gt;本机单元测试---&gt;找到gtest<br>
下面是根据一个计算器的基础功能加减乘除的作为例子讲解<br>
<img src="http://localhost:4000/post-images/1692019404735.png" alt="" loading="lazy"><br>
在一个单元测试中，有下面三个部分组成<br>
<img src="http://localhost:4000/post-images/1692019631421.png" alt="" loading="lazy"></p>
<h2 id="1">1.</h2>
<p>在pch.cpp中放需要测试的函数<br>
需要在头部包含<strong>pch.h</strong>头文件</p>
<pre><code class="language-C++">//
// pch.cpp
//

#include &quot;pch.h&quot;
double calculate(const std::string&amp; expression, int&amp; index) {
  int length = expression.length();

  // 当前操作数
  double operand1 = 0.0;

  // 处理第一个操作数
  while (index &lt; length &amp;&amp; (isdigit(expression[index]) || expression[index] == '.')) {
      operand1 = operand1 * 10.0 + (expression[index] - '0');
      index++;
  }

  // 如果已经到达表达式结尾，直接返回第一个操作数
  if (index == length) {
      return operand1;
  }

  char operation = expression[index];

  // 跳过运算符
  index++;

  // 递归计算后续的表达式
  double operand2 = calculate(expression, index);

  // 根据运算符进行计算并返回结果
  switch (operation) {
  case '+':
      return operand1 + operand2;
  case '-':
      return operand1 - operand2;
  case '*':
      return operand1 * operand2;
  case '/':
      if (operand2 != 0.0) {
          return operand1 / operand2;
      }
      else {
          std::cerr &lt;&lt; &quot;Error: 除数不能为零&quot; &lt;&lt; std::endl;
          return 0.0;
      }
  default:
      std::cerr &lt;&lt; &quot;Error: 无法识别，请正确输入&quot; &lt;&lt; std::endl;
      return 0.0;
  }
}

double calculate(const std::string&amp; expression) {
  int index = 0;
  return calculate(expression, index);
}
</code></pre>
<h2 id="2">2.</h2>
<p>在pch.h中<br>
<img src="http://localhost:4000/post-images/1692020040154.png" alt="" loading="lazy"></p>
<h2 id="3">3.</h2>
<p>在test.cpp中写测试数据代码</p>
<pre><code class="language-C++">#include &quot;pch.h&quot;

#include &quot;pch.h&quot;
#include &lt;gtest/gtest.h&gt;

TEST(CalculatorTest, Addition) {
    double result = calculate(&quot;1+2*3&quot;);//测试案例
    EXPECT_EQ(result, 7);//测试预期正确结果
}

TEST(CalculatorTest, Subtraction) {
    double result = calculate(&quot;5-2&quot;);
    EXPECT_EQ(result, 3);
}

TEST(CalculatorTest, Multiplication) {
    double result = calculate(&quot;2*4&quot;);
    EXPECT_EQ(result, 8);
}

TEST(CalculatorTest, Division) {
    double result = calculate(&quot;10/2&quot;);
    EXPECT_EQ(result, 5);
}

TEST(CalculatorTest, DivisionByZero) {
    double result = calculate(&quot;5/0&quot;);
    EXPECT_TRUE(std::isinf(result));
}
</code></pre>
<h2 id="4">4.</h2>
<p>最后点击运行，如果是在整个项目中添加到额单元测试，想要运行测试代码则右键---&gt;设为启动项即可<br>
测试结果如下：<br>
<img src="http://localhost:4000/post-images/1692020497921.png" alt="" loading="lazy"></p>
<h1 id="三-测试的需求">三、测试的需求</h1>
<p>基础的测试工作，在实际开发中大多数的岗位是开发岗位，但技术含量相对较低，由于分为白盒测试跟黑盒测试，写开发代码的才是大佬，基础的说白了也就是配置好环境以后点点点，高端的测试岗位一般都在大厂，且很重要，中小型公司技术含量较低，一般都是新手进去了解整个项目开发流程的一个岗位。</p>
<p>测试有专门的岗位，单元测试是开发人员的职责。</p>
<p>专门测试主要做集成测试和功能测试，有专门的工具和方案</p>
<p>基础的测试岗位说白了就是点点点，发现哪里功能和设计不一致就提bug给开发修复。</p>
<p>测试开发岗位本质就是开发，开发测试相关的工具，以及写相关的集成代码。这种岗位国内很少，基本上只有头部的大厂会有，规模不大。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[g++安装与一些基本指令]]></title>
        <id>http://localhost:4000/post/gan-zhuang-yu-yi-xie-ji-ben-zhi-ling/</id>
        <link href="http://localhost:4000/post/gan-zhuang-yu-yi-xie-ji-ben-zhi-ling/">
        </link>
        <updated>2023-08-13T15:25:49.000Z</updated>
        <summary type="html"><![CDATA[<p>❤️❤️❤️新人小白请多指教❤️❤️❤️<br>
💡💡💡在linux下安装gdb跟cmake，以及一些基础知识💡💡💡</p>
]]></summary>
        <content type="html"><![CDATA[<p>❤️❤️❤️新人小白请多指教❤️❤️❤️<br>
💡💡💡在linux下安装gdb跟cmake，以及一些基础知识💡💡💡</p>
<!-- more -->
<h1 id="1安装gdb">1安装gdb</h1>
<p>安装gdb（包含了gcc：c语言 g++：c++）<br>
<code>sudo apt install build-essential gdb</code><br>
在安装任何软件之前需要先输入：<br>
<code>sudo apt update</code><br>
检验：</p>
<pre><code>gcc --version
g++ --version
gdb --version
</code></pre>
<h1 id="2安装cmake">2安装cmake：</h1>
<p><code>sudo apt install cmake</code><br>
检验：<br>
<code>cmake –version</code></p>
<h1 id="3建第一个在linux下第一个程序">3建第一个在linux下第一个程序</h1>
<ol>
<li><code>vim text1.cpp</code>  #创建一个叫text1的.cpp文件</li>
<li>编写程序</li>
<li>生成可执行程序：<br>
<code>g++ text1.cpp -o text1</code>  #生成一个叫text1的c++可执行文件<br>
4.运行text1(在ls查看文件后，若文件为绿色则表示为可执直接运行的文件)<br>
<code>./text1</code></li>
</ol>
<h1 id="4on优化源代码">4<strong>O[n]优化源代码</strong></h1>
<ol>
<li>-O，-O1<br>
这两个命令的效果是一样的，目的都是在不影响编译速度的前提下，尽量采用一些优化算法降低代码大小和可执行代码的运行速度。并开启如下的优化选项：</li>
<li>-O3<br>
该选项除了执行-O2所有的优化选项之外，一般都是采取很多向量化算法，提高代码的并行执行程度，利用现代CPU中的流水线，Cache等</li>
<li>-Os<br>
这个优化标识和-O3有异曲同工之妙，当然两者的目标不一样，<br>
-O3的目标是宁愿增加目标代码的大小，也要拼命的提高运行速度，<br>
但是这个选项是在-O2的基础之上，尽量的降低目标代码的大小，这对于存储容量很小的设备来说非常重要。<br>
为了降低目标代码大小，会禁用下列优化选项，一般就是压缩内存中的对齐空白(alignment padding)</li>
<li>-Ofast<br>
该选项将不会严格遵循语言标准，除了启用所有的-O3优化选项之外，也会针对某些语言启用部分优化。如：-ffast-math ，对于Fortran语言，还会启用下列选项</li>
<li>-Og<br>
优化调试体验。 -Og应该是标准edit-compile-debug周期的优化级别选择，<br>
在保持快速编译和良好调试体验的同时，提供合理的优化级别。<br>
用于生成可调试代码，因为某些收集调试信息的编译器通道在以下位置被禁用 -O0。<br>
像-O0 -Og完全禁用了许多优化过程，因此控制它们的单个选项无效。除此以外-Og 使所有 -O1 优化标志，但那些可能会干扰调试的标志除外：</li>
</ol>
<h1 id="5-l和-l指定库文件路径">5 <strong>-l</strong>和 <strong>-L</strong>指定库文件路径</h1>
<p>-l参数(小写)就是用来指定程序要链接的库，-l参数紧接着就是库名<br>
在/lib和/usr/lib和/usr/local/lib里的库直接用-l参数就能链接<br>
链接glog库<br>
<code>g++ -lglog test.cpp</code><br>
如果库文件没放在上面三个目录里，需要使用-L参数(大写)指定库文件所在目录#  -L参数跟着的是库文件所在的目录名<br>
链接mytest库，libmytest.so在*/home/bing/mytestlibfolder*目录下g++ -L/home/bing/<code>mytestlibfolder -lmytest test.cpp</code></p>
<h1 id="6-i-指定头文件搜索目录">6 -I 指定头文件搜索目录</h1>
<p>/usr/include目录一般是不用指定的，gcc知道去那里找，但 是如果头文件不在/usr/icnclude里我们就要用-I参数指定了，比如头文件放在/myinclude目录里，那编译命令行就要加上- I/myinclude 参数了，如果不加你会得到一个”xxxx.h: No such file or directory”的错<br>
误。-I参数可以用相对路径，比如头文件在当前 目录，可以用-I.来指定。上面我们提到的–cflags参数就是用来生成-I参数的。</p>
<p><code>g++ -I/myinclude test.cpp</code></p>
<h1 id="7-wall打印警告信息">7-Wall打印警告信息</h1>
<p><code>g++ -Wall text,cpp</code></p>
<h1 id="8-stdc-设置编译标准">8-std=c++ 设置编译标准</h1>
<p><code>g++ -std=c++11 text.cpp</code></p>
<h1 id="9-o-指定输出文件名">9 -o 指定输出文件名</h1>
<p><code>g++ text,cpp -o text</code></p>
<h1 id="10-d-定义宏">10-D   定义宏</h1>
<p>在使用gcc/g++编译的时候定义宏<br>
常用场景：<br>
-DDEBUG  定义DEBUG宏，可能文件中有DEBUG宏部分的相关信息，用个DDEBUG来选择开启或关闭DEBUG<br>
示例代码：<br>
//  -Dname  定义宏name,默认定义内容为字符串“1”</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
int main()
 {
#ifdef DEBUG
printf(&quot;DEBUG LOG\n&quot;); #endif
printf(&quot;in\n&quot;); 
}

//  1.  在编译的时候，使用gcc  -DDEBUG  main.cpp
// 2. 第五行代码可以被执行
</code></pre>
<h1 id="11-git工作流程图">11 Git工作流程图</h1>
<figure data-type="image" tabindex="1"><img src="http://localhost:4000/post-images/1691940756890.png" alt="" loading="lazy"></figure>
<h1 id="12-程序编译过程">12 程序编译过程</h1>
<figure data-type="image" tabindex="2"><img src="http://localhost:4000/post-images/1691940820451.png" alt="" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[linux基础指令]]></title>
        <id>http://localhost:4000/post/linux-ji-chu-zhi-ling/</id>
        <link href="http://localhost:4000/post/linux-ji-chu-zhi-ling/">
        </link>
        <updated>2023-08-13T13:59:42.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  这是一篇简单的<strong>linux</strong>基本指令 ！<br>
✍️ 新人小白请多指教</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  这是一篇简单的<strong>linux</strong>基本指令 ！<br>
✍️ 新人小白请多指教</p>
<!-- more -->
<h2 id="常见文件夹意义"><strong>常见文件夹意义</strong>：</h2>
<p><strong>Bin</strong>：全称binary，含义是二进制。该目录中存储的都是一些二进制文件，文件都是可以被运行的。<br>
<strong>Dev</strong>：该目录中主要存放的是外接设备，例如盘、其他的光盘等。在其中的外接设备是不能直接被使用的，需要挂载（类似window下的分配盘符）。<br>
<strong>Etc</strong>：该目录主要存储一些配置文件。<br>
<strong>Home</strong>：表示“家”，表示除了root用户以外其他用户的家目录，类似于windows下的User/用户目录。<br>
<strong>Proc</strong>：全称process，表示进程，该目录中存储的是Linux运行时候的进程。<br>
<strong>Root</strong>：该目录是root用户自己的家目录。<br>
<strong>Sbin</strong>：全称super binary，该目录也是存储一些可以被执行的二进制文件，但是必须得有super权限的用户才能执行。<br>
<strong>Tmp</strong>：表示“临时”的，当系统运行时候产生的临时文件会在这个目录存着。<br>
<strong>Usr</strong>：存放的是用户自己安装的软件。类似于windows下的program files。<br>
<strong>Var</strong>：存放的程序/系统的日志文件的目录。<br>
<strong>Mnt</strong>：当外接设备需要挂载的时候，就需要挂载到mnt目录下<br>
命令格式：【命令】空格【选项】空格【操作对象】<br>
Eg:<code>ls -lah /home</code></p>
<h3 id="重要指令"><strong>重要指令</strong>*</h3>
<h2 id="1pwd">1：pwd</h2>
<p><code>pwd （print current working directory）</code><br>
打印当前终端所在的目录</p>
<h2 id="2ls">2：ls</h2>
<p><code>ls（list directory contents）</code><br>
列出当前工作目录下的所有文件/文件夹的名称<br>
用法：<br>
ls ./ #表示当前目录下<br>
ls.// #表示上一级目录下<br>
ls -lah /home<br>
解释：</p>
<ol>
<li>-l：表示list 表示以详细的列表的形式进行展示</li>
<li>-a：all，表示显示所有的文件夹/文件（包含了隐藏文件）</li>
<li>-h：表示以可读性较高的形式显示</li>
</ol>
<p>当显示出文件以“d”开头则为文件夹<br>
当显示出文件以“-”开头则说明为文件<br>
当显示出文件以“.”开头则说明是隐藏文件</p>
<h2 id="3-ctrll-清屏">3 ctrl+l  (清屏）</h2>
<h2 id="4-cd">4 cd</h2>
<p><code>cd（change directory）</code>切换到当前的工作目录<br>
用法1；cd  cd~    #直接进入当前的home目录下【很常用】</p>
<p>用法2：cd【相对路径】<br>
#进入到上级目录下<br>
<code>cd ..</code><br>
#进入到上级目录中的local目录下<br>
<code>cd ../local</code></p>
<p>PS:当输入cd /etc 后输入tab键</p>
<p>然后输入y确定之后</p>
<p>在键盘上输入open（不会有显示）</p>
<h2 id="5-midir">5 midir</h2>
<p><code>midir：make directories</code>创建目录<br>
用法1：mkdir a#在当前路径下创建了一个a的文件夹（目录）<br>
用法2：mkdir -p a/b/c #在当前路径下先创建了一个a然后在a下面创建b 然后在b下面创建了c<br>
用法3：直接创建多个目录<br>
<code>mkdir a b c</code></p>
<h2 id="6-touch">6 touch</h2>
<p><code>touch change file timestamps</code><br>
作用：创建新文件<br>
touch是创建文件 mkdir是创建文件夹</p>
<h4 id="1">1.</h4>
<p>touch的作用本来不是创建文件，而是将指定文件的修改时间设置为当前时间。就是假<br>
装“碰”（touch）了一下这个文件，假装文件被“修改”了，于是文件的修改时间就是被设置为当前时间。</p>
<h4 id="2">2.</h4>
<p>这带来了一个副作用，就是当touch一个不存在的文件的时候，它会创建这个文件。然后，由于touch已经可以完成创建文件的功能了，就不再需要一个单独的create了。</p>
<p>用法1：<br>
<code>touch linux.txt</code> 直接在当前目录下创建了一个linux的txt文件<br>
<code>touch home/tangyin/myfile</code>  在home/tangyin下面创建了一个myfile文件<br>
用法2：<br>
<code>touch file file.txt</code>  在当前目录下创建了file 跟file.txt两个文件</p>
<h2 id="7-rm">7 rm</h2>
<p><code>rm （remove files or directories）</code><br>
删除文件</p>
<ol>
<li>删除文件<br>
直接删除<br>
<code>rm myfile</code><br>
<code>rm /user/myfile</code></li>
<li>移除目录<br>
<code>rm -rf myfolder</code> 删除当前路径下的abc文件<br>
<code>rm -rf /usr/myfolder</code>  删除/usr路径下的abc文件</li>
</ol>
<h2 id="8-cp">8 cp</h2>
<p>cp：复制文件到指定位置<br>
用法1：<br>
cp [被复制的文件路径] [文件被复制到的路径]<br>
用法二：<br>
cp -r [被复制的文件夹路径] [文件夹被复制到的路径]</p>
<p>文件夹要加上-r  直接复制文件则直接</p>
<h2 id="9-mv">9 mv</h2>
<p>mv（move）移动文件或者重命名    ----剪切<br>
当文件在同一个文件夹下，没有移动到别处时，重命名</p>
<h2 id="10-man">10 man</h2>
<p>当没有手册，列如：<code>man cd</code></p>
<p>这时候应该输入 help cd<br>
<img src="http://localhost:4000/post-images/1691938848365.png" alt="" loading="lazy"></p>
<p>shutdown:关机<br>
rebot:重启<br>
sudo -i:进入root权限</p>
<p>拓展：<br>
关于tree<br>
安装tree命令之前需要安装make命令</p>
<ol>
<li>安装make命令：<br>
首先在终端更新所有软件：sudo apt-get update<br>
然后输入：sudo apt install make<br>
最后等待安装，若出现需要确认的选项选择确认</li>
<li>安装tree：<br>
首先下载 输入：<br>
<code>wget http://mama.indstate.edu/users/ice/tree/src/tree-1.7.0.tgz</code></li>
</ol>
<p>然后解压：<code>tar zxvf tree-1.7.0.tgz</code><br>
进入目录：<code>cd tree -1.7.0</code><br>
使用sudo -i切换到root       （这次修改的密码时12345678）<br>
然后 <code>cp tree /bin</code><br>
完成</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello Gridea]]></title>
        <id>http://localhost:4000/post/hello-gridea/</id>
        <link href="http://localhost:4000/post/hello-gridea/">
        </link>
        <updated>2018-12-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
]]></summary>
        <content type="html"><![CDATA[<p>👏  欢迎使用 <strong>Gridea</strong> ！<br>
✍️  <strong>Gridea</strong> 一个静态博客写作客户端。你可以用它来记录你的生活、心情、知识、笔记、创意... ...</p>
<!-- more -->
<p><a href="https://github.com/getgridea/gridea">Github</a><br>
<a href="https://gridea.dev/">Gridea 主页</a><br>
<a href="http://fehey.com/">示例网站</a></p>
<h2 id="特性">特性👇</h2>
<p>📝  你可以使用最酷的 <strong>Markdown</strong> 语法，进行快速创作</p>
<p>🌉  你可以给文章配上精美的封面图和在文章任意位置插入图片</p>
<p>🏷️  你可以对文章进行标签分组</p>
<p>📋  你可以自定义菜单，甚至可以创建外部链接菜单</p>
<p>💻  你可以在 <strong>Windows</strong>，<strong>MacOS</strong> 或 <strong>Linux</strong> 设备上使用此客户端</p>
<p>🌎  你可以使用 <strong>𝖦𝗂𝗍𝗁𝗎𝖻 𝖯𝖺𝗀𝖾𝗌</strong> 或 <strong>Coding Pages</strong> 向世界展示，未来将支持更多平台</p>
<p>💬  你可以进行简单的配置，接入 <a href="https://github.com/gitalk/gitalk">Gitalk</a> 或 <a href="https://github.com/SukkaW/DisqusJS">DisqusJS</a> 评论系统</p>
<p>🇬🇧  你可以使用<strong>中文简体</strong>或<strong>英语</strong></p>
<p>🌁  你可以任意使用应用内默认主题或任意第三方主题，强大的主题自定义能力</p>
<p>🖥  你可以自定义源文件夹，利用 OneDrive、百度网盘、iCloud、Dropbox 等进行多设备同步</p>
<p>🌱 当然 <strong>Gridea</strong> 还很年轻，有很多不足，但请相信，它会不停向前 🏃</p>
<p>未来，它一定会成为你离不开的伙伴</p>
<p>尽情发挥你的才华吧！</p>
<p>😘 Enjoy~</p>
]]></content>
    </entry>
</feed>