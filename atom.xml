<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tangyin1.github.io</id>
    <title>Gridea</title>
    <updated>2023-11-30T08:55:42.866Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tangyin1.github.io"/>
    <link rel="self" href="https://tangyin1.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://tangyin1.github.io/images/avatar.png</logo>
    <icon>https://tangyin1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2023, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[C++11新特性（五）]]></title>
        <id>https://tangyin1.github.io/post/c11-xin-te-xing-wu/</id>
        <link href="https://tangyin1.github.io/post/c11-xin-te-xing-wu/">
        </link>
        <updated>2023-11-30T08:53:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-可调用对象包装器和绑定器">1、可调用对象包装器和绑定器</h3>
<h4 id="什么是可调用对象">什么是可调用对象</h4>
<p>c++11中有一个重要的概念叫做<font color='red'>可调用对象(Callable Objects)。</font></p>
<p><strong>可调用对象用处广泛，比如在使用一些基于范围的模板函数时（如 sort()、all_of()、find_if() 等），常常需要我们传入一个可调用对象，以指明我们需要对范围中的每个元素进行怎样的处理。</strong><br>
又比如，在处理一些回调函数、触发函数时，也常常会使用可调用对象。</p>
<p>总的来说，可调用对象可以是以下几种情况：</p>
<ul>
<li>普通函数</li>
<li>函数指针</li>
<li>仿函数，即重载了operator()运算符的类对象</li>
<li>匿名函数，即Lambda表达式</li>
<li>std::function</li>
</ul>
<h4 id="可调用对象包装器-function">可调用对象包装器 function</h4>
<p>首先需要在头文件里面包含#include<functional></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;functional&gt;
using namespace std;
int add(int a, int b)
{
    cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; endl;
    return a + b;
}

class T1
{
public:
    static int sub(int a, int b)
    {
        cout &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a - b &lt;&lt; endl;
        return a - b;
    }
};

class T2
{
public:
    int operator()(int a, int b)
    {
        cout &lt;&lt; a &lt;&lt; &quot; * &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a * b &lt;&lt; endl;
        return a * b;
    }
};

int main()
{
    //包装普通函数
    function&lt;int(int, int)&gt;f1 = add;
    //包装类的静态函数
    function&lt;int(int, int)&gt;f2 = T1::sub;
    //包装仿函数
    T2 t;
    function&lt;int(int, int)&gt;f3 = t;
    //调用
    f1(1, 2);
    f2(3, 4);
    f3(5, 6);
	system(&quot;pause&quot;);
	return 0;

}
</code></pre>
<h4 id="可调用对象绑定器-bind">可调用对象绑定器 bind</h4>
<p>bind()函数同样在头文件<font color='red'>functional</font>里面</p>
<p>std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。通俗来讲，它主要有两大作用：</p>
<ol>
<li>
<p>将可调用对象与其参数一起绑定成一个仿函数。</p>
</li>
<li>
<p>将多元（参数个数为n，n&gt;1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数。</p>
</li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;functional&gt;
using namespace std;
void output(int x, int y)
{
	cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;
}

int main()
{
    // 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数
    bind(output, 1, 2)();
    bind(output, placeholders::_1, 2)(10);
    bind(output, 2, placeholders::_1)(10);

    // error, 调用时没有第二个参数
    // bind(output, 2, placeholders::_2)(10);
    // 调用时第一个参数10被吞掉了，没有被使用
    bind(output, 2, placeholders::_2)(10, 20);
    
    bind(output, placeholders::_1, placeholders::_2)(10, 20);
    bind(output, placeholders::_2, placeholders::_1)(10, 20);
    
    system(&quot;pause&quot;);
    return 0;
}
</code></pre>
<p>绑定类内元素</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;functional&gt;
using namespace std;
class A
{
public:
	void print(int a, int b)
	{
		cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;
	}
	int c;

};
int main()
{
	A aa;
	//绑定类内函数
	auto f1 = bind(&amp;A::print,&amp;aa, placeholders::_1,placeholders::_2);//自动推导得出的仿函数类型
	function&lt;void(int,int)&gt; f11 = 
	bind(&amp;A::print, &amp;aa, placeholders::_1, placeholders::_2);//进行了function包装，二者参数类型不同
	f1(1,2);
	f11(8,9);
	//绑定类内成员变量
	auto f22 = bind(&amp;A::c, &amp;aa);
	function&lt;int&amp;(void)&gt; f2=bind(&amp;A::c, &amp;aa);
	f2() = 3;
	cout &lt;&lt; f2() &lt;&lt; endl;
	f22() = 4;
	cout &lt;&lt; f22() &lt;&lt; endl;
	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
<p>在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。<font color='red'>f1的类型是function&lt;void(int, int)&gt;，通过使用std::bind将Test的成员函数output的地址和对象t绑定，并转化为一个仿函数并存储到对象f1中。</font></p>
<p><font color='red'>使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function&lt;int&amp;(void)&gt;的包装器对象f2中，并且可以在需要的时候修改这个成员。其中int是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为void。</font></p>
<p>示例程序中是使用function包装器保存了bind返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用auto进行类型的自动推导，这样使用起来会更容易一些。</p>
<h3 id="2-右值引用">2、右值引用</h3>
<p>C++11 增加了一个新的类型，称为右值引用（ R-value reference），标记为<code>&amp;&amp;</code>。在介绍右值引用类型之前先要了解什么是左值和右值：</p>
<ul>
<li>lvalue 是<code>loactor value</code>的缩写，rvalue 是 <code>read value</code>的缩写</li>
<li>左值是指存储在内存中、有明确存储地址（可取地址）的数据；</li>
<li>右值是指可以提供数据值的数据（不可取地址）；</li>
</ul>
<p>通过描述可以看出，区分左值与右值的便捷方法是：可以对表达式取地址（&amp;）就是左值，否则为右值 。所有有名字的变量或对象都是左值，而右值是匿名的。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int&amp;&amp; value = 520;
class Test
{
public:
    Test()
    {
        cout &lt;&lt; &quot;construct: my name is jerry&quot; &lt;&lt; endl;
    }
    Test(const Test&amp; a)
    {
        cout &lt;&lt; &quot;copy construct: my name is tom&quot; &lt;&lt; endl;
    }
};

Test getObj()
{
    return Test();
}

int main()
{
    int a1;
    int &amp;&amp;a2 = a1;        // error
    Test&amp; t = getObj();   // error
    Test &amp;&amp; t = getObj();
    const Test&amp; t = getObj();
    return 0;
}
</code></pre>
<ul>
<li>在上面的例子中<code>int&amp;&amp; value = 520;</code>里面<code>520</code>是纯右值，<code>value</code>是对字面量<code>520</code>这个右值的引用。</li>
<li>在<code>int &amp;&amp;a2 = a1;</code>中<code>a1</code>虽然写在了<code>=</code>右边，但是它仍然是一个左值，<code>使用左值初始化一个右值引用类型是不合法的。</code></li>
<li>在<code>Test&amp; t = getObj()</code>这句代码中语法是错误的，<code>右值不能给普通的左值引用赋值。</code></li>
<li>在<code>Test &amp;&amp; t = getObj();</code>中<code>getObj()</code>返回的<code>临时对象</code>被称之为<code>将亡值</code>，<code>t</code>是这个将亡值的右值引用。</li>
<li><code>const Test&amp; t = getObj()</code>这句代码的语法是正确的，<code>常量左值引用是一个万能引用类型，它可以接受左值、右值、常量左值和常量右值。</code></li>
</ul>
<p><font color='red'>在C++中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要避免对象的深拷贝，就可以使用右值引用进行性能的优化。</font></p>
<h4 id="特性">&amp;&amp;特性</h4>
<p>在C++中，<font color='cornflowerblue'>并不是所有情况下 &amp;&amp; 都代表是一个右值引用</font>，具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为T&amp;&amp;，如果是自动类型推导需要指定为auto &amp;&amp;，在这两种场景下 &amp;&amp;被称作未定的引用类型。另外还有一点需要额外注意<font color='red'>const T&amp;&amp;表示一个右值引用，不是未定引用类型。</font></p>
<ol>
<li><font color='red'> 左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。</font></li>
<li><font color='red'>编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。</font></li>
<li><font color='red'>auto&amp;&amp;或者函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型（上面有例子）。</font></li>
<li><font color='red'>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型，其余都是左值引用类型。</font></li>
</ol>
<pre><code class="language-cpp">int&amp;&amp; a1 = 5;
auto&amp;&amp; bb = a1;
auto&amp;&amp; bb1 = 5;

int a2 = 5;
int &amp;a3 = a2;
auto&amp;&amp; cc = a3;
auto&amp;&amp; cc1 = a2;

const int&amp; s1 = 100;
const int&amp;&amp; s2 = 100;
auto&amp;&amp; dd = s1;
auto&amp;&amp; ee = s2;

const auto&amp;&amp; x = 5;
</code></pre>
<ul>
<li>
<p>第2行：a1为右值引用，推导出的bb为左值引用类型</p>
</li>
<li>
<p>第3行：5为右值，推导出的bb1为右值引用类型</p>
</li>
<li>
<p>第7行：a3为左值引用，推导出的cc为左值引用类型</p>
</li>
<li>
<p>第8行：a2为左值，推导出的cc1为左值引用类型</p>
</li>
<li>
<p>第12行：s1为常量左值引用，推导出的dd为常量左值引用类型</p>
</li>
<li>
<p>第13行：s2为常量右值引用，推导出的ee为常量左值引用类型</p>
</li>
<li>
<p>第15行：x为右值引用，不需要推导，只能通过右值初始化</p>
</li>
</ul>
<h3 id="3-转移和完美转发">3、转移和完美转发</h3>
<h4 id="1-move">1、move</h4>
<p>在C++11添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助std::move()函数，使用<font color='red'>std::move方法可以将左值转换为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。</font></p>
<p>（舔狗净身出户，车房还在，只是所有权转移）</p>
<pre><code class="language-cpp">class Test
{
public：
    Test(){}
    ......
}
int main()
{
    Test t;
    Test &amp;&amp; v1 = t;          // error
    Test &amp;&amp; v2 = move(t);    // ok
    return 0;
}
</code></pre>
<ul>
<li>在第4行中，使用左值初始化右值引用，因此语法是错误的</li>
<li>在第5行中，使用move()函数将左值转换为了右值，这样就可以初始化右值引用了。</li>
</ul>
<p>假设一个临时容器很大，并且需要将这个容器赋值给另一个容器，就可以执行如下操作：</p>
<pre><code class="language-cpp">list&lt;string&gt; ls;
ls.push_back(&quot;hello&quot;);
ls.push_back(&quot;world&quot;);
......
list&lt;string&gt; ls1 = ls;        // 需要拷贝, 效率低
list&lt;string&gt; ls2 = move(ls);
</code></pre>
<p>如果不使用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。如果一个对象内部有较大的堆内存或者动态数组时，使用move()就可以非常方便的进行数据所有权的转移。另外，我们也可以给类编写相应的移动构造函数（<font color='red'>T::T(T&amp;&amp; another</font>)）和和具有移动语义的赋值函数（<font color='red'>T&amp;&amp; T::operator=(T&amp;&amp; rhs)</font>），在构造对象和赋值的时候尽可能的进行资源的重复利用，<font color='red'>因为它们都是接收一个右值引用参数。</font></p>
<h4 id="2-forward">2、forward</h4>
<p>// 函数原型</p>
<pre><code class="language-cpp">template &lt;class T&gt; T&amp;&amp; forward (typename remove_reference&lt;T&gt;::type&amp; t) noexcept;
template &lt;class T&gt; T&amp;&amp; forward (typename remove_reference&lt;T&gt;::type&amp;&amp; t) noexcept;

// 精简之后的样子
std::forward&lt;T&gt;(t);
</code></pre>
<ul>
<li><font color='red'>当T为左值引用类型时，t将被转换为T类型的左值</font></li>
<li><font color='red'>当T不是左值引用类型时，t将被转换为T类型的右值</font></li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

template&lt;typename T&gt;
void printValue(T&amp; t)
{
    cout &lt;&lt; &quot;l-value: &quot; &lt;&lt; t &lt;&lt; endl;
}

template&lt;typename T&gt;
void printValue(T&amp;&amp; t)
{
    cout &lt;&lt; &quot;r-value: &quot; &lt;&lt; t &lt;&lt; endl;
}

template&lt;typename T&gt;
void testForward(T &amp;&amp; v)
{
    printValue(v);
    printValue(move(v));
    printValue(forward&lt;T&gt;(v));
    cout &lt;&lt; endl;
}

int main()
{
    testForward(520);
    int num = 1314;
    testForward(num);
    testForward(forward&lt;int&gt;(num));
    testForward(forward&lt;int&amp;&gt;(num));
    testForward(forward&lt;int&amp;&amp;&gt;(num));

    return 0;

}
</code></pre>
<p>测试结果如下</p>
<pre><code class="language-cpp">l-value: 520
r-value: 520
r-value: 520

l-value: 1314
r-value: 1314
l-value: 1314

l-value: 1314
r-value: 1314
r-value: 1314

l-value: 1314
r-value: 1314
l-value: 1314

l-value: 1314
r-value: 1314
r-value: 1314
</code></pre>
<h3 id="4-共享智能指针">4、共享智能指针</h3>
<p>在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。<font color='red'>解决这个问题最有效的方法是使用智能指针</font>（smart pointer）。</p>
<p>智能指针：</p>
<p><font color='red'>是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</font></p>
<p>C++11中提供了三种智能指针，使用这些智能指针时需要引用头文件<memory>：</p>
<ul>
<li>
<pre><code class="language-cpp">- std::shared_ptr：共享的智能指针
- std::unique_ptr：独占的智能指针
- std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。
</code></pre>
</li>
</ul>
<h4 id="shared_ptr-四种初始化方法">shared_ptr 四种初始化方法</h4>
<ol>
<li>
<p>通过构造函数初始化</p>
</li>
<li>
<p>通过拷贝和移动构造函数初始化</p>
</li>
<li>
<p>通过std::make_shared初始化</p>
</li>
<li>
<p>通过 reset方法初始化</p>
<pre><code class="language-cpp">//共享智能指针
#include &lt;iostream&gt;
#include&lt;memory&gt;
using namespace std;
class Test
{
public:
    Test()
    {
        cout &lt;&lt; &quot;construct Test...&quot; &lt;&lt; endl;
    }
    Test(int x)
    {
        cout &lt;&lt; &quot;construct Test, x = &quot; &lt;&lt; x &lt;&lt; endl;
    }
    Test(string str)
    {
        cout &lt;&lt; &quot;construct Test, str = &quot; &lt;&lt; str &lt;&lt; endl;
    }
    void setValue(int v)
    {
        m_num = v;
    }
    void print()
    {
        cout &lt;&lt; m_num &lt;&lt; endl;
    }
    ~Test()
    {
        cout &lt;&lt; &quot;destruct Test ...&quot; &lt;&lt; endl;
    }
private:
    int m_num;
};

int main()
{
    //通过构造函数初始化
    shared_ptr&lt;int&gt;ptr1(new int(3));
    cout &lt;&lt; &quot;ptr1 use count: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;
    //通过移动构造和拷贝构造函数初始话
    shared_ptr&lt;int&gt;ptr2 = move(ptr1);
    cout &lt;&lt; &quot;ptr1 use count: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;
    cout &lt;&lt; &quot;ptr2 use count: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;
    //通过make_shared初始化
    shared_ptr&lt;int&gt; ptr3 = make_shared&lt;int&gt;(8);
    shared_ptr&lt;Test&gt;ptr4 = make_shared&lt;Test&gt;(0);
    shared_ptr&lt;Test&gt;ptr5 = make_shared&lt;Test&gt;(&quot;hello&quot;);
    cout &lt;&lt; &quot;ptr3 use count: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;
    //通过reset初始化
    ptr5.reset();
    cout &lt;&lt; &quot;ptr5 use count: &quot; &lt;&lt; ptr5.use_count() &lt;&lt; endl;
    ptr5.reset(new Test(&quot;kkk&quot;));
    cout &lt;&lt; &quot;ptr5 use count: &quot; &lt;&lt; ptr5.use_count() &lt;&lt; endl;
    //通过原始指针
    Test* t = ptr5.get();
    t-&gt;setValue(1000);
    t-&gt;print();
    ptr5-&gt;setValue(999);
    ptr5-&gt;print();
	system(&quot;pause&quot;);
	return 0;

}
</code></pre>
</li>
</ol>
<p>获取原始指针</p>
<pre><code class="language-cpp">T* get() const noexcept;
</code></pre>
<h3 id="unique_ptr独占的共享指针">unique_ptr,独占的共享指针</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;

#include&lt;memory&gt;
using namespace std;
class Test
{
public:
    Test()
    {
        cout &lt;&lt; &quot;construct Test...&quot; &lt;&lt; endl;
    }
    Test(int x)
    {
        cout &lt;&lt; &quot;construct Test, x = &quot; &lt;&lt; x &lt;&lt; endl;
    }
    Test(string str)
    {
        cout &lt;&lt; &quot;construct Test, str = &quot; &lt;&lt; str &lt;&lt; endl;
    }
    void setValue(int v)
    {
        m_num = v;
    }
    void print()
    {
        cout &lt;&lt; m_num &lt;&lt; endl;
    }
    ~Test()
    {
        cout &lt;&lt; &quot;destruct Test ...&quot; &lt;&lt; endl;
    }
private:
    int m_num;
};

unique_ptr&lt;int&gt; func()
{
	return unique_ptr&lt;int&gt;(new int(99));
}
int main()
{
	//初始化
	unique_ptr&lt;int&gt;ptr_1(new int(1));//普通初始化
	unique_ptr&lt;int&gt;ptr2 = move(ptr_1);//使用move
	unique_ptr&lt;int&gt;ptr_3 = func();//将亡值
    shared_ptr&lt;int&gt;pw(new int(777));
	//reset	
	ptr_1.reset();
	ptr2.reset(new int(2)); 
	cout &lt;&lt; *ptr2 &lt;&lt; endl;
    //获取原始指针
    unique_ptr&lt;Test&gt; ppp(new Test (999));
    Test* p = ppp.get();
    p-&gt;setValue(888);
    p-&gt;print();
    //独占智能指针没有use_count()函数
    cout &lt;&lt; pw.use_count() &lt;&lt; endl;;
    //删除器
    using ptrFunc = void(*)(Test*);
    unique_ptr&lt;Test,ptrFunc&gt;prr_9(new Test(&quot;kkkk&quot;), [](Test* t) {
        cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;
        delete t;

​    });

   ////独占的智能指针可以管理数组类型的地址，能够自动释放
   // unique_ptr &lt;Test[]&gt;ptr_11(new Test[3]);
   // ptr_11 = nullptr;

​	system(&quot;pause&quot;);
​	return 0;

}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11新特性（四）]]></title>
        <id>https://tangyin1.github.io/post/c11-xin-te-xing-si/</id>
        <link href="https://tangyin1.github.io/post/c11-xin-te-xing-si/">
        </link>
        <updated>2023-11-22T09:19:06.000Z</updated>
        <summary type="html"><![CDATA[<p>本章节包含<br>
constexpr修饰常量表达式<br>
常量表达式函数<br>
using定义基础类型和函数指针别名<br>
委托构造函数和继承构造函数<br>
列表初始化</p>
]]></summary>
        <content type="html"><![CDATA[<p>本章节包含<br>
constexpr修饰常量表达式<br>
常量表达式函数<br>
using定义基础类型和函数指针别名<br>
委托构造函数和继承构造函数<br>
列表初始化</p>
<!-- more -->
<h3 id="1-constexpr修饰常量表达式">1、constexpr修饰常量表达式</h3>
<p><font color='red'>在c++11以后，表达只读的话使用const 或者constexpr都是可以的，在只读方面二者是等价的，在表示常量的时候建议使用constexptr。</font></p>
<p>在介绍gcc/g++工作流程的时候说过，C++ 程序从编写完毕到执行分为四个阶段：<font color='red'>预处理、 编译、汇编和链接4个阶段</font>，得到可执行程序之后就可以运行了。需要额外强调的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<p>那么问题来了，编译器如何识别表达式是不是常量表达式呢？在C++11中添加了constexpr关键字之后就可以在程序中使用它来修饰常量表达式，用来提高程序的执行效率。在使用中建议将 const 和 constexpr 的功能区分开，<font color='red'>即凡是表达“只读”语义的场景都使用 const</font>，<font color='red'>表</font><font color='red'>达“常量”语义的场景都使用 constexpr。</font></p>
<p>在定义常量时，const 和 constexpr 是等价的，都可以在程序的编译阶段计算出结果，例如：</p>
<pre><code class="language-cpp">const int m = f();  // 不是常量表达式，m的值只有在运行时才会获取。
const int i=520;    // 是一个常量表达式
const int j=i+1;    // 是一个常量表达式

constexpr int i=520;    // 是一个常量表达式
constexpr int j=i+1;    // 是一个常量表达式
</code></pre>
<p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。</p>
<pre><code class="language-cpp">// 此处的constexpr修饰是无效的
constexpr struct Test
{
    int id;
    int num;
};
</code></pre>
<p>如果要定义一个结构体/类常量对象，可以这样写：</p>
<pre><code class="language-cpp">struct Test
{
    int id;
    int num;
};
int main()
{
    constexpr Test t{ 1, 2 };
    constexpr int id = t.id;
    constexpr int num = t.num;
    // error，不能修改常量
    t.num += 100;
    cout &lt;&lt; &quot;id: &quot; &lt;&lt; id &lt;&lt; &quot;, num: &quot; &lt;&lt; num &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>在第13行的代码中t.num += 100;的操作是错误的，对象t是一个常量，因此它的成员也是常量，常量是不能被修改的。</p>
<h3 id="2-常量表达式函数">2、常量表达式函数</h3>
<p>为了提高C++程序的执行效率，我们可以将程序中值不需要发生变化的变量定义为常量，也可以使用constexpr修饰函数的返回值，这种函数被称作常量表达式函数，这些函数主要包括以下几种：<font color='red'>普通函数/类成员函数、类的构造函数、模板函数</font>。</p>
<h4 id="1-constexpr并不能修改任意函数的返回值使这些函数成为常量表达式函数必须要满足以下几个条件">1、constexpr并不能修改任意函数的返回值，使这些函数成为常量表达式函数，必须要满足以下几个条件：</h4>
<ol>
<li>函数必须要有返回值，并且return 返回的表达式必须是常量表达式。</li>
<li>函数在使用之前，必须有对应的定义语句。</li>
<li>整个函数的函数体中，不能出现非常量表达式之外的语句（<font color='red'>using 指令、typedef 语句以及 static_assert 断言、return语句除外</font>）。</li>
</ol>
<pre><code class="language-cpp">// error
constexpr int func1()
{
    constexpr int a = 100;
    constexpr int b = 10;
    for (int i = 0; i &lt; b; ++i)
    {
        cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; endl;
    }
    return a + b;
}

// ok
constexpr int func2()
{
    using mytype = int;
    constexpr mytype a = 100;
    constexpr mytype b = 10;
    constexpr mytype c = a * b;
    return c - (a + b);
}
</code></pre>
<p>因为func1()是一个常量表达式函数，在函数体内部是不允许出现非常量表达式以外的操作，因此函数体内部的for循环是一个非法操作。</p>
<h4 id="2-修饰模板函数">2、修饰模板函数</h4>
<p>C++11 语法中，constexpr 可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。<font color='red'>如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该</font><font color='red'>函数就等同于一个普通函数。</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Person {
    const char* name;
    int age;
};

// 定义函数模板
template&lt;typename T&gt;
constexpr T dispaly(T t) {
    return t;
}

int main()
{
    struct Person p { &quot;luffy&quot;, 19 };
    //普通函数
    struct Person ret = dispaly(p);
    cout &lt;&lt; &quot;luffy's name: &quot; &lt;&lt; ret.name &lt;&lt; &quot;, age: &quot; &lt;&lt; ret.age &lt;&lt; endl;

    //常量表达式函数
    constexpr int ret1 = dispaly(250);
    cout &lt;&lt; ret1 &lt;&lt; endl;
    
    constexpr struct Person p1 { &quot;luffy&quot;, 19 };
    constexpr struct Person p2 = dispaly(p1);
    cout &lt;&lt; &quot;luffy's name: &quot; &lt;&lt; p2.name &lt;&lt; &quot;, age: &quot; &lt;&lt; p2.age &lt;&lt; endl;
    return 0;

}
</code></pre>
<p>在上面示例程序中定义了一个函数模板 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p>
<ul>
<li><font color='red'>struct Person ret = dispaly(p);</font>由于参数p是变量，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的</li>
<li><font color='red'>constexpr int ret1 = dispaly(250)</font>;参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的</li>
<li><font color='red'>constexpr struct Person p2 = dispaly(p1)</font>;参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的</li>
</ul>
<h4 id="3-修饰构造函数">3、修饰构造函数</h4>
<p>如果想用直接得到一个常量对象，也可以使用constexpr修饰一个构造函数，这样就可以得到一个常量构造函数了。常量构造函数有一个要求：构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Person {
    constexpr Person(const char* p, int age) :name(p), age(age)
    {
    }
    const char* name;
    int age;
};

int main()
{
    constexpr struct Person p1(&quot;luffy&quot;, 19);
    cout &lt;&lt; &quot;luffy's name: &quot; &lt;&lt; p1.name &lt;&lt; &quot;, age: &quot; &lt;&lt; p1.age &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="3-通过using定义基础类型和函数指针别名">3、通过using定义基础类型和函数指针别名</h3>
<h4 id="1-定义别名">1、定义别名</h4>
<p>在 C++中可以通过 typedef 重定义一个类型，语法格式如下：</p>
<p>被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。C++11中规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名，即使用using。</p>
<p>在使用的时候，关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。<font color='red'>类型</font><font color='red'>别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。使用typedef定义的别名和使用using定义的别名在语义上</font><font color='red'>是等效的。</font></p>
<p>使用using定义别名的语法格式是这样的：</p>
<pre><code class="language-cpp">using 新的类型 = 旧的类型;
// 使用举例
using uint_t = int;
</code></pre>
<p>通过using和typedef的语法格式可以看到二者的使用没有太大的区别，假设我们定义一个函数指针，using的优势就能凸显出来了，看一下下面的例子：</p>
<pre><code class="language-cpp">// 使用typedef定义函数指针
typedef int(*func_ptr)(int, double);

// 使用using定义函数指针
using func_ptr1 = int(*)(int, double);
</code></pre>
<p>使用using定义函数指针别名的写法看起来就非常直观了，把别名的名字强制分离到了左边，<font color='red'>而把别名对应的实际类型放在了右边，比较清晰，可读性比较好。</font></p>
<h4 id="2-模板的别名">2、模板的别名</h4>
<p>使用typedef重定义类似很方便，但是它有一点限制，比如无法重定义一个模板，比如我们需要一个固定以int类型为key的map，它可以和很多类型的value值进行映射，如果使用typedef这样直接定义就非常麻烦:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;map&gt;
using namespace std;

template &lt;typename T&gt;
// 定义外敷类
struct MyMap
{
    typedef map&lt;int, T&gt; type;
};

int main(void)
{
    MyMap&lt;string&gt;::type m;
    m.insert(make_pair(1, &quot;luffy&quot;));
    m.insert(make_pair(2, &quot;ace&quot;));

    MyMap&lt;int&gt;::type m1;
    m1.insert(1, 100);
    m1.insert(2, 200);
    
    return 0;

}
</code></pre>
<p>使用using就会很简洁</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;map&gt;
using namespace std;

template &lt;typename T&gt;
using mymap = map&lt;int, T&gt;;

int main(void)
{
    // map的value指定为string类型
    mymap&lt;string&gt; m;
    m.insert(make_pair(1, &quot;luffy&quot;));
    m.insert(make_pair(2, &quot;ace&quot;));

    // map的value指定为int类型
    mymap&lt;int&gt; m1;
    m1.insert(1, 100);
    m1.insert(2, 200);
    
    return 0;

}
</code></pre>
<p><font color='red'>最后在强调一点：using语法和typedef一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名。using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名。</font></p>
<h3 id="4-委托构造函数和继承构造函数">4、委托构造函数和继承构造函数</h3>
<h4 id="1-委托构造函数">1、委托构造函数</h4>
<p>在C++11以后，构造函数中构造函数2中有构造函数1，可以在构造函数2里调用构造函数1</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Test
{
public:
    Test() {};
    Test(int max)
    {
        this-&gt;m_max = max &gt; 0 ? max : 100;
    }

    Test(int max, int min):Test(max)
    {
        this-&gt;m_min = min &gt; 0 &amp;&amp; min &lt; max ? min : 1;
    }
    
    Test(int max, int min, int mid):Test(max, min)
    {
        this-&gt;m_middle = mid &lt; max &amp;&amp; mid &gt; min ? mid : 50;
    }
    
    int m_min;
    int m_max;
    int m_middle;

};

int main()
{
    Test t(90, 30, 60);
    cout &lt;&lt; &quot;min: &quot; &lt;&lt; t.m_min &lt;&lt; &quot;, middle: &quot; 
         &lt;&lt; t.m_middle &lt;&lt; &quot;, max: &quot; &lt;&lt; t.m_max &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>在一个构造函数中调用了其他的构造函数用于相关数据的初始化，相当于是一个链式调用。在使用委托构造函数的时候还需要注意一些几个问题：</p>
<p><font color='red'>这种链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常。</font></p>
<p><font color='red'>如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义</font>。</p>
<pre><code class="language-cpp">Test(int max)
{
    this-&gt;m_max = max &gt; 0 ? max : 100;
}

Test(int max, int min)
{
    Test(max);	// error, 此处编译器会报错, 提示形参max被重复定义
    this-&gt;m_min = min &gt; 0 &amp;&amp; min &lt; max ? min : 1;
}
</code></pre>
<p><font color='red'>在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了。</font></p>
<pre><code class="language-cpp">// 错误, 使用了委托构造函数就不能再次m_max初始化了
Test(int max, int min) : Test(max), m_max(max)
{
    this-&gt;m_min = min &gt; 0 &amp;&amp; min &lt; max ? min : 1;
}
</code></pre>
<h4 id="2-继承构造函数">2、继承构造函数</h4>
<p>C++11中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。</p>
<p>继承构造函数的使用方法是这样的：通过使用<font color='red'>using 类名::构造函数名（其实类名和构造函数名是一样的）</font>来声明使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Base
{
public:
    Base(int i) :m_i(i) {}
    Base(int i, double j) :m_i(i), m_j(j) {}
    Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {}

    int m_i;
    double m_j;
    string m_k;

};

class Child : public Base
{
public:
    using Base::Base;
};

int main()
{
    Child c1(520, 13.14);
    cout &lt;&lt; &quot;int: &quot; &lt;&lt; c1.m_i &lt;&lt; &quot;, double: &quot; &lt;&lt; c1.m_j &lt;&lt; endl;
    Child c2(520, 13.14, &quot;i love you&quot;);
    cout &lt;&lt; &quot;int: &quot; &lt;&lt; c2.m_i &lt;&lt; &quot;, double: &quot; 
         &lt;&lt; c2.m_j &lt;&lt; &quot;, string: &quot; &lt;&lt; c2.m_k &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="5-列表初始化">5、列表初始化</h3>
<h4 id="1-统一初始化">1、统一初始化</h4>
<p>C++98：</p>
<pre><code class="language-cpp">// 数组的初始化
int array[] = { 1,3,5,7,9 };
double array1[3] = { 1.2, 1.3, 1.4 };

// 对象的初始化
struct Person
{
    int id;
    double salary;
}zhang3{ 1, 3000 };
</code></pre>
<p>C++11：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Test
{
public:
    Test(int) {}
private:
    Test(const Test &amp;);
};

int main(void)
{
    Test t1(520);
    Test t2 = 520; 
    Test t3 = { 520 };
    Test t4{ 520 };
    int a1 = { 1314 };
    int a2{ 1314 };
    int arr1[] = { 1, 2, 3 };
    int arr2[]{ 1, 2, 3 };
    return 0;
}
</code></pre>
<ul>
<li>
<p>t1：最中规中矩的初始化方式，通过提供的带参构造进行对象的初始化</p>
</li>
<li>
<p>t2：语法错误，因为提供的拷贝构造函数是私有的。如果拷贝构造函数是公共的，520会通过隐式类型转换被Test(int)构造成一个匿名对象，然后再通过对这个匿名对象进行拷贝构造得到t2（<font color='red'>这个错误在VS中不会出现</font>，在Linux中使用g++编译会提示描述的这个错误，截图如下。）</p>
</li>
<li>
<p>t3和t4：使用了C++11的初始化方式来初始化对象，效果和t1的方式是相同的。</p>
</li>
<li>
<p>在初始时，{}前面的等号是否书写对初始化行为没有任何影响。</p>
</li>
<li>
<ul>
<li>t3虽然使用了等号，但是它仍然是列表初始化，因此私有的拷贝构造对它没有任何影响。</li>
<li>t1、arr1和t2、arr2：这两个是基础数据类型的列表初始化方式，可以看到，和对象的初始化方式是统一的。</li>
</ul>
</li>
<li>
<p>t4、a2、arr2的写法，<font color='red'>是C++11中新添加的语法格式，使用这种方式可以直接在变量名后边跟上初始化列表，来进行变量或者对象的初始化</font></p>
</li>
</ul>
<h4 id="2-列表初始化细节">2、列表初始化细节</h4>
<h5 id="1-聚合体">1、聚合体</h5>
<ul>
<li>普通数组本身可以看做是一个聚合类型</li>
<li>满足以下条件的类（class、struct、union）可以被看做是一个聚合类型：</li>
</ul>
<p>​		<font color='cornflowerblue'>（1）无用户自定义的构造函数。</font></p>
<p>​		<font color='cornflowerblue'>（2）无私有或保护的非静态数据成员。</font></p>
<p>​		<font color='cornflowerblue'>（3）无基类。</font></p>
<p>​		<font color='cornflowerblue'>（4）无虚函数。</font></p>
<p>​		<font color='cornflowerblue'>（5）类中不能有使用{}和=直接初始化的非静态数据成员（从c++14开始就支持了</font></p>
<h5 id="2-非聚合体">2、非聚合体</h5>
<p>对于聚合类型的类可以直接使用列表初始化进行对象的初始化，如果不满足聚合条件还想使用列表初始化其实也是可以的，<font color='red'>需要在类的内部自定义一个构造函数, 在构造函数中使用初始化列表对类成员变量进行初始化:</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

struct T1
{
    int x;
    double y;
    // 在构造函数中使用初始化列表初始化类成员
    T1(int a, double b, int c) : x(a), y(b), z(c){}
    virtual void print()
    {
        cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;, y: &quot; &lt;&lt; y &lt;&lt; &quot;, z: &quot; &lt;&lt; z &lt;&lt; endl;
    }
private:
    int z;
};

int main(void)
{
    T1 t{ 520, 13.14, 1314 };	// ok, 基于构造函数使用初始化列表初始化类成员
    t.print();
    return 0;
}
</code></pre>
<p>另外，需要额外注意的是<font color='red'>聚合类型的定义并非递归的&lt;，也就是说<font color='red'>当一个类的非静态成员是非聚合类型时，这个类也可能是聚合类型，比如下面的这个例子</font>：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

struct T1
{
    int x;
    double y;
private:
    int z;
};

struct T2
{
    T1 t1;
    long x1;
    double y1;
};

int main(void)
{
    T2 t2{ {}, 520, 13.14 };
    return 0;
}
</code></pre>
<p>可以看到，T1并非一个聚合类型，因为它有一个Private的非静态成员。但是尽管T2有一个非聚合类型的非静态成员t1，T2依然是一个聚合类型，可以直接使用列表初始化的方式进行初始化。</p>
<p>最后强调一下t2对象的初始化过程，对于非聚合类型的成员t1做初始化的时候，可以直接写一对空的大括号{}，这相当于调用是T1的无参构造函数。</p>
<p><font color='red'>对于一个聚合类型，使用列表初始化相当于对其中的每个元素分别赋值，而对于非聚合类型，则需要先自定义一个合适的构造函数，此时使用列表初始化将会调用它对应的构造函数。</font></p>
<h4 id="3-sstdinitializer_list模板类的使用">3、sstd::initializer_list模板类的使用</h4>
<p>在C++的STL容器中，可以进行任意长度的数据的初始化，使用初始化列表也只能进行固定参数的初始化，如果想要做到和STL一样有任意长度初始化的能力，可以使用<font color='red'>std::initializer_list</font>这个轻量级的类模板来实现。</p>
<p>先来介绍一下这个类模板的一些特点：</p>
<ul>
<li>它是一个轻量级的容器类型，内部定义了迭代器iterator等容器必须的概念，遍历时得到的迭代器是只读的。</li>
<li>对于std::initializer_list<T>而言，它可以接收任意长度的初始化列表，但是要求元素<font color='red'>必须是同种类型T</font></li>
<li>在std::initializer_list内部有三个成员接口：<font color='red'>size(), begin(), end()。</font></li>
<li>std::initializer_list对象<font color='red'>只能被整体初始化或者赋值</font>。</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
//构造函数
class Person
{
public:
	Person(initializer_list&lt;string&gt;ls)
	{
		auto it = ls.begin();
		for (; it != ls.end(); it++)
		{
			cout &lt;&lt; *it &lt;&lt; endl;
			m_name.push_back(*it);
		}
	}
private:
	vector&lt;string&gt;m_name;
};
//普通函数
void func(initializer_list&lt;int&gt;ls)
{
	auto it = ls.begin();
	for (; it != ls.end(); ++it)
	{
		cout &lt;&lt; *it &lt;&lt;&quot; &quot;;
	}
	cout &lt;&lt; endl;
}
int main()
{
	func({ 1,2,3,4,5,6,7 });
	Person p1({ &quot;a&quot;,&quot;b&quot;,&quot;c&quot; });
	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11新特性（三）]]></title>
        <id>https://tangyin1.github.io/post/c11-xin-te-xing-san/</id>
        <link href="https://tangyin1.github.io/post/c11-xin-te-xing-san/">
        </link>
        <updated>2023-11-21T09:20:53.000Z</updated>
        <summary type="html"><![CDATA[<p>文章内容来自https://subingwen.cn/cplusplus/的整理，感谢丙哥</p>
]]></summary>
        <content type="html"><![CDATA[<p>文章内容来自https://subingwen.cn/cplusplus/的整理，感谢丙哥</p>
<!-- more -->
<h3 id="1for循环新特性">1for循环新特性</h3>
<p>C++98/03中普通的for循环，语法格式：</p>
<pre><code class="language-cpp">for(表达式 1; 表达式 2; 表达式 3)
{
    // 循环体
}
</code></pre>
<p>C++11基于范围的for循环，语法格式：</p>
<pre><code class="language-cpp">for (declaration : expression)
{
    // 循环体
}
</code></pre>
<p>在上面的语法格式中declaration表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。expression是要遍历的对象，它可以是<font color='red'>表达式、容器、数组、初始化列表等。</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int main(void)
{
    vector&lt;int&gt; t{ 1,2,3,4,5,6 };
    cout &lt;&lt; &quot;遍历修改之前的容器: &quot;;
    for (auto &amp;value : t)
    {
        cout &lt;&lt; value++ &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl &lt;&lt; &quot;遍历修改之后的容器: &quot;;
    for (auto &amp;value : t)
    {
        cout &lt;&lt; value &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<p><strong>auto &amp;value : t</strong></p>
<p>由于直接不采用引用的方式是使用拷贝的方法来输出，这种拷贝的不仅影响内存还影响速度，采用引用的方式会解决了资源占用，还能进行对其数值进行修改</p>
<h3 id="2基于范围的for循环需要注意的3个细节">2基于范围的for循环需要注意的3个细节</h3>
<h4 id="21-关系型容器">2.1 关系型容器</h4>
<p>使用基于范围的for循环有一些需要注意的细节，先来看一下对关系型容器map的遍历：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
using namespace std;

int main(void)
{
    map&lt;int, string&gt; m{
        {1, &quot;lucy&quot;},{2, &quot;lily&quot;},{3, &quot;tom&quot;}
    };

    // 基于范围的for循环方式
    for (auto&amp; it : m)
    {
        cout &lt;&lt; &quot;id: &quot; &lt;&lt; it.first &lt;&lt; &quot;, name: &quot; &lt;&lt; it.second &lt;&lt; endl;
    }
    
    // 普通的for循环方式
    for (auto it = m.begin(); it != m.end(); ++it)
    {
        cout &lt;&lt; &quot;id: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;, name: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
    }
    
    return 0;

}
</code></pre>
<p>在上面的例子中使用两种方式对map进行了遍历，通过对比有两点需要注意的事项：</p>
<p>使用普通的for循环方式（基于迭代器）遍历关联性容器，<font color='red'> auto自动推导出的是一个迭代器类型</font>，需要使用迭代器的方式取出元素中的键值对（<font color='red'>和指针的操作方法相同</font>）：</p>
<ul>
<li>it-&gt;first</li>
<li>it-&gt;second</li>
</ul>
<p>使用基于范围的for循环遍历关联性容器，<font color='red'>auto自动推导出的类型是容器中的value_type</font>，相当于一个对组（std::pair）对象，提取键值对的方式如下：</p>
<ul>
<li>it.first<br>
it.second</li>
</ul>
<h4 id="22元素只读">2.2元素只读</h4>
<p><font color='red'>对应set容器来说，内部元素都是只读的，这是由容器的特性决定的，因此在for循环中auto&amp;会被视为const auto &amp; 。</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;set&gt;
using namespace std;

int main(void)
{
    set&lt;int&gt; st{ 1,2,3,4,5,6 };
    for (auto &amp;item : st) 
    {
        cout &lt;&lt; item++ &lt;&lt; endl;		// error, 不能给常量赋值
    }
    return 0;
}
</code></pre>
<h4 id="23访问次数">2.3访问次数</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
vector&lt;int&gt; v{ 1,2,3,4,5,6 };
vector&lt;int&gt;&amp; getRange()
{
    cout &lt;&lt; &quot;get vector range...&quot; &lt;&lt; endl;
    return v;
}
int main(void)
{
    for (auto val : getRange())
    {
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>输出的结果如下：<br>
<code>get vector range...</code><br>
<code>1 2 3 4 5 6</code></p>
<p><font color='red'>对应基于范围的for循环来说，冒号后边的表达式只会被执行一次。在得到遍历对象之后会先确定好迭代的范围，基于这个范围直接进行遍历。如果是普通的for循环，在每次迭代的时候都需要判断是否已经到了结束边界。</font></p>
<h3 id="3-nullptr">3 nullptr</h3>
<p>在C++程序开发中，为了提高程序的健壮性，一般会在定义指针的同时完成初始化操作，或者在指针的指向尚未明确的情况下，都会给指针初始化为NULL，避免产生野指针（没有明确指向的指针，操作也这种指针极可能导致程序发生异常）。C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种：</p>
<pre><code class="language-cpp">char *ptr = 0;
char *ptr = NULL;
</code></pre>
<p>C++ 中将 NULL 定义为字面常量 0，并不能保证在所有场景下都能很好的工作，比如，函数重载时，NULL 和 0 无法区分</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void func(char *p)
{
    cout &lt;&lt; &quot;void func(char *p)&quot; &lt;&lt; endl;
}

void func(int p)
{
    cout &lt;&lt; &quot;void func(int p)&quot; &lt;&lt; endl;
}

int main()
{
    func(nullptr);
    func(250);
    return 0;
}
</code></pre>
<p><font color='red'>nullptr 无法隐式转换为整形，但是可以隐式匹配指针类型</font>。在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</p>
<p><font color='red'>总的来说在支持c++11的编译器之中，建议使用nullptr来代替NULL 和0，来避免报错。</font></p>
<h3 id="4-lambda表达式">4、lambda表达式</h3>
<h4 id="1-基本用法">1、基本用法</h4>
<p>lambda表达式的语法形式简单归纳如下：</p>
<pre><code class="language-cpp">[capture](params) opt -&gt; ret {body;};
</code></pre>
<p>其中<font color='red'>capture</font>是捕获列表，<font color='red'>params</font>是参数列表，<font color='red'>opt</font>是函数选项，<font color='red'>ret</font>是返回值类型，<font color='red'>body</font>是函数体。</p>
<ol>
<li>捕获列表[]: 捕获一定范围内的变量</li>
<li>参数列表(): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。</li>
</ol>
<pre><code class="language-cpp">auto f = [](){return 1;}	// 没有参数, 参数列表为空
auto f = []{return 1;}		// 没有参数, 参数列表省略不写
</code></pre>
<p>​	3.opt 选项， <font color='red'>不需要可以省略</font></p>
<ul>
<li>​	mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li>
<li>​	exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();</li>
</ul>
<p>​	4.返回值类型：在C++11中，lambda表达式的返回值是通过返回值后置语法来定义的。</p>
<p>​	5.函数体：函数的实现，这部分不能省略，但函数体可以为空。</p>
<h4 id="2捕获列表">2.捕获列表</h4>
<p>lambda表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p>
<ul>
<li>[] - 不捕捉任何变量</li>
<li>[&amp;] - 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (按引用捕获)</li>
<li>[=] - 捕获外部作用域中所有变量, 并作为副本在函数体内使用 (按值捕获)</li>
<li>拷贝的副本在匿名函数体内部是只读的</li>
<li>[=, &amp;foo] - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo</li>
<li>[bar] - 按值捕获 bar 变量, 同时不捕获其他变量</li>
<li>[&amp;bar] - 按引用捕获 bar 变量, 同时不捕获其他变量</li>
<li>[this] - 捕获当前类中的this指针</li>
</ul>
<p>​		让lambda表达式拥有和当前类成员函数同样的访问权限<br>
​		如果已经使用了 &amp; 或者 =, 默认添加此选项</p>
<pre><code class="language-cpp">//lambda表达式
#include &lt;iostream&gt;
using namespace std;
void func(int x, int y)
{
	int a = 1;
	int b = 2;
	[=,&amp;x]() mutable//除了x为引用的方式被取值，其他的元素都是以拷贝的方式取值
	{
		int c = a;
		b++;//使用mutable可以使得拷贝进来的元素可以进行修改
		cout &lt;&lt; b &lt;&lt; endl;
	}();//要调用这个函数需要在{}后面接上(),如果{}前面的小括号有参数，{}后面的也要有相应类型的参数
	cout &lt;&lt; b &lt;&lt; endl;
	[=](int z)mutable
	{
		int d = a;
		a++;
		cout &lt;&lt; &quot;d= &quot; &lt;&lt; d&lt;&lt;endl;
	}(1);
}
int main()
{
	func(1, 2);
	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
<h4 id="3-返回值">3、返回值</h4>
<p>很多时候，lambda表达式的返回值是非常明显的，因此在C++11中允许省略lambda表达式的返回值。</p>
<pre><code class="language-cpp">// 完整的lambda表达式定义
auto f = [](int a) -&gt; int
{
    return a+10;  
};

// 忽略返回值的lambda表达式定义
auto f = [](int a)
{
    return a+10;  
};
</code></pre>
<p>一般情况下，不指定lambda表达式的返回值，编译器会根据return语句自动推导返回值的类型，但需要注意的是labmda表达式<font color='red'>不能通过</font><font color='red'>列表初始化自动推导出返回值类型</font>。</p>
<pre><code class="language-cpp">/ ok，可以自动推导出返回值类型
auto f = [](int i)
{
    return i;
}

// error，不能推导出返回值类型
auto f1 = []()
{
    return {1, 2};	// 基于列表初始化推导返回值，错误
}
</code></pre>
<h4 id="4-函数本质">4、函数本质</h4>
<p>使用lambda表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用mutable选项，<font color='red'>被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。</font></p>
<pre><code class="language-cpp">int a = 0;
auto f1 = [=] {return a++; };              // error, 按值捕获外部变量, a是只读的
auto f2 = [=]()mutable {return a++; };     // ok
</code></pre>
<p>最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:</p>
<ol>
<li>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。</li>
<li>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</li>
</ol>
<p>​	<font color='red'>mutable选项的作用就在于取消operator()的const属性。</font></p>
<p>因为lambda表达式在C++中会被看做是一个仿函数，因此可以使用<font color='red'>std::function和std::bind来存储和操作lambda表达式</font>：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;functional&gt;
using namespace std;

int main(void)
{
    // 包装可调用函数
    std::function&lt;int(int)&gt; f1 = [](int a) {return a; };
    // 绑定可调用函数
    std::function&lt;int(int)&gt; f2 = bind([](int a) {return a; }, placeholders::_1);

    // 函数调用
    cout &lt;&lt; f1(100) &lt;&lt; endl;
    cout &lt;&lt; f2(200) &lt;&lt; endl;
    return 0;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11新特性2（自动类型推导）]]></title>
        <id>https://tangyin1.github.io/post/c11-xin-te-xing-2zi-dong-lei-xing-tui-dao/</id>
        <link href="https://tangyin1.github.io/post/c11-xin-te-xing-2zi-dong-lei-xing-tui-dao/">
        </link>
        <updated>2023-11-21T01:59:28.000Z</updated>
        <summary type="html"><![CDATA[<p>C++11新特性2（自动类型推导） auto、decltype、返回值类型后置</p>
]]></summary>
        <content type="html"><![CDATA[<p>C++11新特性2（自动类型推导） auto、decltype、返回值类型后置</p>
<!-- more -->
<h3 id="1使用auto进行类型自动推导">1使用auto进行类型自动推导</h3>
<h4 id="auto">auto</h4>
<p>C++11中auto并不代表一种实际的数据类型，只是一个类型声明的 “占位符”，auto并不是万能的在任意场景下都能够推导出变量的实际类型，使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型。使用语法如下：</p>
<pre><code class="language-cpp">auto 变量名 = 变量值;
</code></pre>
<pre><code class="language-cpp">auto x = 3.14;      // x 是浮点型 double
auto y = 520;       // y 是整形 int
auto z = 'a';       // z 是字符型 char
auto nb;            // error，变量必须要初始化
auto double nbl;    // 语法错误, 不能修改数据类型
</code></pre>
<ul>
<li>当变量<font color='red'>不是</font>指针或者引用类型时，推导的结果中<font color='red'>不会保留</font>const、volatile关键字</li>
<li>当变量<font color='red'>是指针或者引用</font>类型时，推导的结果中<font color='red'>会保留</font>const、volatile关键字</li>
</ul>
<p>（1） “编译器一般不为const变量分配内存，而是将它保存在符号表中，这使得它成为一个编译期间的值，没有了存储与读内存的操作。”</p>
<p>（2） volatile的作用是“告诉编译器，i是随时可能发生变化的，每次使用它的时候必须从内存中取出i的值”。</p>
<p>— —《c语言深度解剖》</p>
<h5 id="1-const-volatile含义">1、 const, volatile含义</h5>
<p>（1）const含义是“请做为常量使用”，而并非“放心吧，那肯定是个常量”。 （2）volatile的含义是“请不要做自以为是的优化，这个值可能变掉的”，而并非“你可以修改这个值”。</p>
<h5 id="2-const-volatile的作用以及起作用的阶段">2、const, volatile的作用以及起作用的阶段</h5>
<p>（1）const只在编译期有用，在运行期无用</p>
<p>const在编译期保证在C的“源代码”里面，没有对其修饰的变量进行修改的地方（如有则报错，编译不通过），而运行期该变量的值是否被改变则不受const的限制。</p>
<p>（2） volatile在编译期和运行期都有用</p>
<p>在编译期告诉编译器：请不要做自以为是的优化，这个变量的值可能会变掉；</p>
<p>在运行期：每次用到该变量的值，都从内存中取该变量的值。</p>
<pre><code class="language-cpp">int temp = 110;
auto *a = &amp;temp;	
auto b = &amp;temp;		
auto &amp;c = temp;		
auto d = temp;		
</code></pre>
<ul>
<li>变量a的数据类型为 int*，因此auto关键字被推导为 int类型</li>
<li>变量b的数据类型为 int*，因此auto关键字被推导为 int*类型</li>
<li>变量c的数据类型为 int&amp;，因此auto关键字被推导为 int类型</li>
<li>变量d的数据类型为 int，因此auto关键字被推导为 int类型</li>
</ul>
<h4 id="auto的限制">auto的限制</h4>
<p>1不能作为函数参数使用。因为只有在函数调用的时候才会给函数参数传递实参，auto要求必须要给修饰的变量赋值，因此二者矛盾。</p>
<pre><code class="language-cpp">int func(auto a, auto b)	// error
{	
    cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt;&quot;, b: &quot; &lt;&lt; b &lt;&lt; endl;
}
</code></pre>
<p>2不能用于类的非静态成员变量的初始化</p>
<pre><code class="language-cpp">class Test
{
    auto v1 = 0;                    // error
    static auto v2 = 0;             // error,类的静态非常量成员不允许在类内部直接初始化
    static const auto v3 = 10;      // ok
}
</code></pre>
<p>3不能使用auto关键字定义数组</p>
<pre><code class="language-cpp">int func()
{
    int array[] = {1,2,3,4,5};  // 定义数组
    auto t1 = array;            // ok, t1被推导为 int* 类型
    auto t2[] = array;          // error, auto无法定义数组
    auto t3[] = {1,2,3,4,5};;   // error, auto无法定义数组
}
</code></pre>
<p>4无法使用auto推导出模板参数</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct Test{}

int func()
{
    Test&lt;double&gt; t;
    Test&lt;auto&gt; t1 = t;           // error, 无法推导出模板类型
    return 0;
}
</code></pre>
<h4 id="auto的应用">auto的应用</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
//用于泛型编程
class T1 {
public:
	static int get()
	{
		return 10;
	}
};
class T2 {
public:
	static string get()
	{
		return &quot;hello world!&quot;;
	}
};
template &lt;class A&gt;
void func()
{
	auto val = A::get();
	cout &lt;&lt; val &lt;&lt; endl;
}
//用于STL的容器遍历
void test()
{
	map&lt;int, string&gt;mp;
	mp.insert(make_pair(1, &quot;ace&quot;));
	mp.insert(make_pair(2, &quot;katun&quot;));
	mp.insert(make_pair(3, &quot;luky&quot;));
	//map&lt;int, string&gt;::iterator it = mp.begin();//迭代器
	auto it = mp.begin();
	for (; it != mp.end(); it++)
	{
		cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;,value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}
}
int main()
{
	func&lt;T1&gt;();
	func&lt;T2&gt;();
	test();
	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
<h3 id="2decltype">2decltype</h3>
<p>decltype 是“declare type”的缩写，意思是“声明类型”。某些情况下，不需要或者不能定义变量，但是希望得到某种类型,使用decltype</p>
<pre><code class="language-cpp">decltype (表达式)
</code></pre>
<pre><code class="language-cpp">int a = 10;
decltype(a) b = 99;                 // b -&gt; int
decltype(a+3.14) c = 52.13;         // c -&gt; double
decltype(a+b*c) d = 520.1314;       // d -&gt; double
</code></pre>
<h4 id="推导规则">推导规则</h4>
<p><font color='red'>1表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用decltype推导出的类型和表达式的类型是一致的。</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Test
{
public:
    string text;
    static const int value = 110;
};

int main()
{
    int x = 99;
    const int &amp;y = x;
    decltype(x) a = x;
    decltype(y) b = x;
    decltype(Test::value) c = 0;// c是const int类型

    Test t;
    decltype(t.text) d = &quot;hello, world&quot;;
    
    return 0;

}
</code></pre>
<p><font color='red'>2表达式是函数调用，使用decltype推导出的类型和函数返回值一致</font></p>
<pre><code class="language-cpp">class Test{...};
//函数声明
int func_int();                 // 返回值为 int
int&amp; func_int_r();              // 返回值为 int&amp;
int&amp;&amp; func_int_rr();            // 返回值为 int&amp;&amp;

const int func_cint();          // 返回值为 const int
const int&amp; func_cint_r();       // 返回值为 const int&amp;
const int&amp;&amp; func_cint_rr();     // 返回值为 const int&amp;&amp;

const Test func_ctest();        // 返回值为 const Test

//decltype类型推导
int n = 100;
decltype(func_int()) a = 0;		
decltype(func_int_r()) b = n;	
decltype(func_int_rr()) c = 0;	
decltype(func_cint())  d = 0;	
decltype(func_cint_r())  e = n;	
decltype(func_cint_rr()) f = 0;	
decltype(func_ctest()) g = Test();	
</code></pre>
<p>函数 func_cint() 返回的是一个纯右值（在表达式执行结束后不再存在的数据，也就是临时性的数据），对于纯右值而言，只有类类型可以携带const、volatile限定符，除此之外需要忽略掉这两个限定符，因此推导出的变量d的类型为 int 而不是 const int。</p>
<p><font color='red'>3表达式是一个左值(可以取地址的变量)，或者被括号( )包围，使用 decltype推导出的是表达式类型的引用（如果有const、volatile限定符不能忽略）。</font></p>
<pre><code class="language-cpp">class Test{...};
//函数声明
int func_int();                 // 返回值为 int
int&amp; func_int_r();              // 返回值为 int&amp;
int&amp;&amp; func_int_rr();            // 返回值为 int&amp;&amp;

const int func_cint();          // 返回值为 const int
const int&amp; func_cint_r();       // 返回值为 const int&amp;
const int&amp;&amp; func_cint_rr();     // 返回值为 const int&amp;&amp;

const Test func_ctest();        // 返回值为 const Test

//decltype类型推导
int n = 100;
decltype(func_int()) a = 0;		
decltype(func_int_r()) b = n;	
decltype(func_int_rr()) c = 0;	
decltype(func_cint())  d = 0;	
decltype(func_cint_r())  e = n;	
decltype(func_cint_rr()) f = 0;	
decltype(func_ctest()) g = Test(
</code></pre>
<p>);</p>
<ul>
<li>obj.num 为类的成员访问表达式，符合场景1，因此 a 的类型为int</li>
<li>obj.num 带有括号，符合场景3，因此b 的类型为 const int&amp;。</li>
<li>n+m 得到一个右值，符合场景1，因此c的类型为 int</li>
<li>n=n+m 得到一个左值 n，符合场景3，因此d的类型为 int&amp;</li>
</ul>
<h4 id="decltype的应用">decltype的应用</h4>
<pre><code class="language-cpp">//decltype的应用
#include &lt;iostream&gt;
#include&lt;list&gt;
using namespace std;
template &lt;typename T&gt;
class A
{
public:
	void print(T &amp;t)
	{
		for (m_it = t.begin(); m_it !=t.end(); m_it++)
		{
			cout &lt;&lt; &quot;value:&quot; &lt;&lt; *m_it &lt;&lt; endl;
		}
	}
private:
	decltype(T().begin()) m_it;
};
int main()
{
	list&lt;int&gt; lst{ 1,2,3,4,5 };
	const list&lt;int&gt; lst1{ 1,2,3,4,5,6,7 };
	list&lt;int&gt;::iterator it = lst.begin();
	A&lt;list&lt;int&gt;&gt; b;
	A&lt;const list&lt;int&gt;&gt; b1;
	b.print(lst);
	cout &lt;&lt; endl;
	b1.print(lst1);
	system(&quot;pause&quot;);
	return 0;	
}

### 3
</code></pre>
<h3 id="3-左值和右值的概念">3、左值和右值的概念</h3>
<p>C++中左值（lvalue）和右值（rvalue）是比较基础的概念，虽然平常几乎用不到，但C++11之后变得十分重要，它是理解 move/forward 等新语义的基础。</p>
<p>左值与右值这两个概念是从 C 中传承而来的，左值指既能够出现在等号左边，也能出现在等号右边的变量；右值则是只能出现在等号右边的变量。</p>
<pre><code class="language-cpp">int a; // a 为左值
a = 3; // 3 为右值
</code></pre>
<ul>
<li>左值是可寻址的变量，有持久性；</li>
<li>右值<font color='red'>一般是不可寻址的常量</font>，或在表达式求值过程中创建的无名临时对象，短暂性的。</li>
</ul>
<p><font color='cornflowerblue'>左值和右值主要的区别之一是左值可以被修改，而右值不能。</font></p>
<h3 id="4-左值引用和右值引用">4、左值引用和右值引用</h3>
<ul>
<li>左值引用：引用一个对象；</li>
<li>右值引用：就是必须绑定到右值的引用，C++11中右值引用可以实现“移动语义”，通过 &amp;&amp; 获得右值引用。</li>
</ul>
<pre><code class="language-cpp">int x = 6; // x是左值，6是右值
int &amp;y = x; // 左值引用，y引用x

int &amp;z1 = x * 6; // 错误，x*6是一个右值
const int &amp;z2 =  x * 6; // 正确，可以将一个const引用绑定到一个右值

int &amp;&amp;z3 = x * 6; // 正确，右值引用
int &amp;&amp;z4 = x; // 错误，x是一个左值
</code></pre>
<p>右值引用和相关的移动语义是C++11标准中引入的最强大的特性之一，通过std::move()可以避免无谓的复制，提高程序性能。</p>
<h3 id="5-返回值类型后置-追踪返回类型">5、 返回值类型后置 (追踪返回类型)</h3>
<p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型，比如下面这个场景：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
// R-&gt;返回值类型, T-&gt;参数1类型, U-&gt;参数2类型
template &lt;typename R, typename T, typename U&gt;
R add(T t, U u)
{
    return t + u;
}
int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = add&lt;decltype(x + y), int, double&gt;(x, y);
    auto z = add&lt;decltype(x + y)&gt;(x, y);	// 简化之后的写法
    cout &lt;&lt; &quot;z: &quot; &lt;&lt; z &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>关于返回值，从上面的代码可以推断出和表达式 t+u的结果类型是一样的，因此可以通过通过decltype进行推导，关于模板函数的参数t和u可以通过实参自动推导出来，因此在程序中就也可以不写。虽然通过上述方式问题被解决了，<font color='red'>但是解决方案有点过于理想化</font>，因为对于调用者来说，<font color='red'>是不知道函数内部执行了什么样的处理动作的。</font></p>
<pre><code class="language-cpp">// 返回类型后置语法
auto 函数(T t, U u) -&gt; decltype(合适的表达式) 
</code></pre>
<p>上面代码使用返回类型后置优化之后</p>
<pre><code class="language-cpp">// 返回值类型后置 (追踪返回类型)
#include &lt;iostream&gt;
using namespace std;
// R-&gt;返回值类型, T-&gt;参数1类型, U-&gt;参数2类型

//R add(T t, U u)
//{
//    return t + u;
//}
template &lt;typename T, typename U&gt;
auto add(T t, U u)-&gt;decltype(t + u)
{
    return t+u;
}
int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = add&lt;decltype(x + y), int, double&gt;(x, y);
    //auto z = add&lt;decltype(x + y)&gt;(x, y);	// 简化之后的写法
    auto ret = add(x, y);
    cout &lt;&lt; &quot;ret: &quot; &lt;&lt; ret &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11新特性（1）]]></title>
        <id>https://tangyin1.github.io/post/c11-xin-te-xing-1/</id>
        <link href="https://tangyin1.github.io/post/c11-xin-te-xing-1/">
        </link>
        <updated>2023-11-20T05:52:29.000Z</updated>
        <summary type="html"><![CDATA[<p>C++11的一些常用新特性，本节包含<br>
字符串原始字面量<br>
long long<br>
类成员的快速初始化</p>
<p>苏丙榅老师的博客https://subingwen.cn/</p>
]]></summary>
        <content type="html"><![CDATA[<p>C++11的一些常用新特性，本节包含<br>
字符串原始字面量<br>
long long<br>
类成员的快速初始化</p>
<p>苏丙榅老师的博客https://subingwen.cn/</p>
<!-- more -->
<h3 id="1字符串原始字面量">1字符串原始字面量</h3>
<p>在C++11中添加了定义原始字符串的字面量，定义方式为：<font color='red'>R “xxx(原始字符串)xxx”</font>其中（）两边的字符串可以省略。原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。</p>
<p>在R “xxx(raw string)xxx” 中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，<font color='red'>并且加的字符串必须在括号两边同时出现</font>。</p>
<p><code>string str2 = R&quot;luffy(D:\hello\world\test.text)luffy&quot;;</code>-----------正确</p>
<p><code>string str3 = R&quot;luffy(D:\hello\world\test.text)robin&quot;;</code>	----------<font color='cornflowerblue'>错误（原因在字符串两边的字符串不一样）</font></p>
<p>运行结果：</p>
<p><code>D:\hello\world\test.text</code></p>
<h3 id="2long-long-整型">2long long 整型</h3>
<p>C++11 标准要求 long long 整型可以在不同平台上有不同的长度，但至少有64位。long long 整型有两种∶</p>
<p>long long - 对应类型的数值可以使用 LL (大写) 或者 ll (小写) 后缀</p>
<p><code>long long num1 = 123456789LL;</code><br>
<code>long long num2 = 123456789ll;</code></p>
<p><font color='red'>在通常情况下我们使用LL</font>，因为ll容易与数字1混淆</p>
<p>同其他的整型一样，要了解平台上 long long大小的方法就是查看<climits>（或&lt;limits. h&gt; ）中的宏与long long整 型相关的一共有3个：</p>
<ul>
<li>LLONG_MIN - 最小的long long值（负数）</li>
<li>LLONG_MAX - 最大的long long 值（正数包括0）</li>
<li>ULLONG MAX - 最大的 unsigned long long 值LLONG_MIN+LLONG_MAX的数）</li>
</ul>
<p><strong>在C++11中一共只定义了以下5种标准的有符号整型</strong>：</p>
<ul>
<li>signed char</li>
<li>short int</li>
<li>int</li>
<li>long int</li>
<li>long long int</li>
</ul>
<p>关于整形提升的隐式转换遵循如下原则:</p>
<ul>
<li>长度越大的整型等级越高，比如 long long int 的等级会高于int。</li>
<li>长度相同的情况下，标准整型的等级高于扩展类型，比如 long long int 和 int64 如果 都是64 位长度，则long long int类型的等级更高。</li>
<li>相同大小的有符号类型和无符号类型的等级相同，long long int 和unsigned longlong  int的等级就相同。</li>
<li><font color='red'>转换过程中，低等级整型需要转换为高等级整型，有符号的需要转换为无符号整形。</font></li>
</ul>
<h3 id="3类成员的快速初始化">3类成员的快速初始化</h3>
<p>//类成员的快速初始化</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
struct Base
{
    Base() : a(250) {}
    Base(int num) : a(num) {}

int a;
int b = 1;
static int c;//直接在类中声明会报错 类的静态成员，必须在类的外部进行初始化
static const double d;//类的静态常量成员，但不是整形或者枚举，无法通过编译
static const char* const e ;//类的静态常量成员，但不是整形或者枚举，无法通过编译
const static int f = 0;

};
//可以在类外声明
int::Base::c = 1;
const double::Base::d = 3.14;
const char* const e = &quot;i am luffy&quot;;
int main()
{
	system(&quot;pause&quot;);
	return 0;

}
</code></pre>
<h3 id="c11-标准两种类成员初始化方法">C++11 标准两种类成员初始化方法</h3>
<h4 id="21-初始化类的非静态成员">2.1 初始化类的非静态成员</h4>
<p>进行类成员变量初始化的时候，C++11标准对于C++98做了补充，允许在定义类的时候在类内部直接对非静态成员变量进行初始化，在初始化的时候可以<font color='red'>使用等号 = 也可以使用花括号 {}</font> 。</p>
<pre><code class="language-cpp">class Test
{
private:
    int a = 9;
    int b = {5};
    int c{12};
    double array[4] = { 3.14, 3.15, 3.16, 3.17};
    double array1[4] { 3.14, 3.15, 3.16, 3.17 };
    string s1(&quot;hello&quot;);     // error
    string s2{ &quot;hello, world&quot; };
};
</code></pre>
<p><font color='cornflowerblue'>可以看到如果使用花括号 {}的方式对类的非静态成员进行初始化，等号是可以省略不写的</font>。</p>
<p>第9行：错误，不能使用小括号() 初始化对象，应该使用花括号{}</p>
<h4 id="22-类内部赋值和初始化列表">2.2 类内部赋值和初始化列表</h4>
<p>在C++11之前对于非静态的类成员变量我们除了在构造函数内部进行赋值，也可以在类的初始化列表中进行初始化（这种方式比在构造函数内部赋值效率高）</p>
<pre><code class="language-cpp">class Init
{
public:
    Init(int x, int y, int z) :a(x), b(y), c(z) {}

int a = 1;
int b = 2;
int c = 3;

};

int main()
{
    Init tmp(10, 20, 30);
    cout &lt;&lt; &quot;a: &quot; &lt;&lt; tmp.a &lt;&lt; &quot;, b: &quot; &lt;&lt; tmp.b &lt;&lt; &quot;, c: &quot; &lt;&lt; tmp.c &lt;&lt; endl;
    return 0;
}
</code></pre>
<ul>
<li>第4行：使用初始化列表对类的非静态成员进行初始化</li>
<li>第6、7、8行：在类内部对非静态成员变量就地初始化（C++11新特性）</li>
</ul>
<p>执行程序，输出的结果如下：<br>
<code>a: 10, b: 20, c: 30</code></p>
<p><font color='red'>通过初始化列表指定的值会覆盖就地初始化时指定的值</font></p>
<h3 id="4final和override">4.final和override</h3>
<h4 id="final">final</h4>
<p>C++中增加了<font color='red'>final关键字来限制某个类不能被继承，或者某个虚函数不能被重写</font>，和Java的final关键字的功能是类似的。如果使用final修饰函数，只能修饰虚函数，并且要把final关键字<font color='red'>放到类或者函数的后面</font></p>
<p>如果使用final修饰函数，只能修饰虚函数，这样就能<font color='red'>阻止子类重写父类的这个函数了</font>：</p>
<pre><code class="language-cpp">class Base
{
public:
    virtual void test()
    {
        cout &lt;&lt; &quot;Base class...&quot;;
    }
};

class Child : public Base
{
public:
    void test() final
    {
        cout &lt;&lt; &quot;Child class...&quot;;
    }
};

class GrandChild : public Child
{
public:
    // 语法错误, 不允许重写
    void test()
    {
        cout &lt;&lt; &quot;GrandChild class...&quot;;
    }
};
</code></pre>
<p>但注意的是，在父类的虚函数以后不允许加上final</p>
<h4 id="override重写">override(重写)</h4>
<p>override关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样这个关键字要写到方法的后面。</p>
<pre><code class="language-cpp">class Base
{
public:
    virtual void test()
    {
        cout &lt;&lt; &quot;Base class...&quot;;
    }
};

class Child : public Base
{
public:
    void test() override
    {
        cout &lt;&lt; &quot;Child class...&quot;;
    }
};

class GrandChild : public Child
{
public:
    void test() override
    {
        cout &lt;&lt; &quot;Child class...&quot;;
    }
};
</code></pre>
<p>上述代码中第13行和第22行就是显示指定了要重写父类的test()方法，使用了override关键字之后，假设在重写过程中因为误操作，写错了函数名或者函数参数或者返回值编译器都会提示语法错误，提高了程序的正确性，降低了出错的概率</p>
<h3 id="5断言">5.断言</h3>
<h4 id="断言">断言</h4>
<p>断言（assertion）是一种编程中常用的手段。在通常情况下，断言就是将一个返回值总是需要为真的判断表达式放在语句中，用于排除在设计的逻辑上不应该产生的情况。</p>
<p>比如：一个函数总需要输入在一定的范围内的参数，那么程序员就可以对该参数使用断言，以迫使在该参数发生异常的时候程序退出，从而避免程序陷入逻辑的混乱。</p>
<p>从一些意义上讲，断言并不是正常程序所必需的，不过对于程序调试来说，通常断言能够帮助程序开发者快速定位那些违反了某些前提条件的程序错误。</p>
<p>如果我们要在C++程序中使用断言，需要在程序中包含头文件<cassert>或&lt;assert.h&gt;，头文件中为我们提供了 assert 宏，用于在运行时进行断言。举例说明：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;cassert&gt;
using namespace std;
char* creatArray(int size)
{
	assert(size &gt; 0);
	char* Array = new char[size];
	return Array;
}
int main()
{
	char* buf = creatArray(0);
	system(&quot;pause&quot;);
	return 0;

}
</code></pre>
<h4 id="静态断言">静态断言</h4>
<p>在上面的例子中我们使用了断言 assert。<font color='cornflowerblue'>但 assert是一个运行时断言，也就是说它只有在程序运行时才能起作用 </font>。这意味着不运行程序我们将无法得知某些条件是否是成立的。 比如：我们想知道当前是32位还是64位平台，对于这个需求我们应该是在程序运行之前就应该得到结果，如果使用断言显然是无法做到的，对于这种情况我们就需要使用C++11提供的静态断言了。</p>
<p>静态断言static_assert，所谓静态就是在编译时就能够进行检查的断言，使用时不需要引用头文件。静态断言的另一个好处是，可以自定义违反断言时的错误提示信息。静态断言使用起来非常简单，它接收两个参数：</p>
<ul>
<li>参数1：断言表达式，这个表达式通常需要返回一个 bool值</li>
<li>参数2：警告信息，它通常就是一段字符串，在违反断言（表达式为false）时提示该信息</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;                                         
using namespace std;

int main()
{
    // 字体原因看起来是一个=, 其实这是两个=
    static_assert(sizeof(long) == 4, &quot;错误, 不是32位平台...&quot;);
    cout &lt;&lt; &quot;64bit Linux 指针大小: &quot; &lt;&lt; sizeof(char*) &lt;&lt; endl;
    cout &lt;&lt; &quot;64bit Linux long 大小: &quot; &lt;&lt; sizeof(long) &lt;&lt;endl;

    return 0;

}
</code></pre>
<h3 id="异常和noexcept">异常和noexcept</h3>
<h4 id="异常">异常</h4>
<p>异常通常用于处理逻辑上可能发生的错误，在C++98中为我们提供了一套完善的异常处理机制，我们可以直接在程序中将各种类型的异常抛出，从而强制终止程序的运行。</p>
<pre><code class="language-cpp">int main()
{ 
    try
    {
        throw -1; 
    } 
    catch (int e)
    { 
        cout &lt;&lt; &quot;int exception, value: &quot; &lt;&lt; e &lt;&lt; endl; 
    } 
    cout &lt;&lt; &quot;That's ok!&quot; &lt;&lt; endl; 
    return 0; 
}
</code></pre>
<h4 id="noexcept">noexcept</h4>
<p>表示其修饰的函数不会抛出异常 。不过与 <code>throw()</code>动态异常声明不同的是，<font color='red'>在 C++11 中如果 noexcept 修饰的函数抛出了异常，编译器可以选择直接调用 std::terminate() 函数来终止程序的运行，这比基于异常机制的 throw() 在效率上会高一些</font>。这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（栈解旋），并自动调用析构函数释放栈上的所有对象。</p>
<p>从语法上讲，noexcept 修饰符有两种形式：</p>
<p>简单地在函数声明后加上 noexcept 关键字</p>
<p>可以接受一个常量表达式作为参数，如下所示∶</p>
<pre><code class="language-cpp">double divisionMethod(int a, int b) noexcept(常量表达式);
</code></pre>
<p>常量表达式的结果会被转换成一个bool类型的值：</p>
<ul>
<li>值为 true，表示函数不会抛出异常</li>
<li>值为 false，表示有可能抛出异常这里</li>
<li>不带常量表达式的noexcept相当于声明了noexcept（true），即不会抛出异常。</li>
</ul>
<h3 id="字符串和数值类型之间的转换">字符串和数值类型之间的转换</h3>
<h4 id="to_string">to_string()</h4>
<p>数字转成字符串</p>
<h4 id="stoi">stoi()</h4>
<p>字符串转换成数字，默认是十进制，第二个参数通常写0 或者nullptr</p>
<pre><code class="language-cpp">inline int stoi(const string&amp; _Str, size_t* _Idx = nullptr, int _Base = 10)
</code></pre>
<pre><code class="language-cpp">//字符串和数值类型之间的转换
#include &lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
void numbertostring()
{
	double a = 3.1415926;
	string b = to_string(a);
	cout &lt;&lt; b &lt;&lt; endl;
}
void stringtonumber()
{
	string a = &quot;2020.04.01 is a goodday!&quot;;
	string b = &quot;10001&quot;;
	string c = &quot;0x13&quot;;
	size_t sz;
	int i_a = stoi(a, &amp;sz);
	int i_b = stoi(b, 0,2);//int i_b=stoi(b,nullptr,2)
	int i_c = stoi(c, nullptr, 0);//0为编译器自动推导
	cout &lt;&lt; i_a &lt;&lt; endl;
	cout &lt;&lt; i_b &lt;&lt; endl;
	cout &lt;&lt; i_c &lt;&lt; endl;
}
int main()
{
	numbertostring();
	stringtonumber();
	system(&quot;pause&quot;);
	return 0;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vim命令]]></title>
        <id>https://tangyin1.github.io/post/vim-ming-ling/</id>
        <link href="https://tangyin1.github.io/post/vim-ming-ling/">
        </link>
        <updated>2023-11-09T02:17:53.000Z</updated>
        <summary type="html"><![CDATA[<p>vim命令大全，需要自己多看多用。也可在终端输入 vimtutor来帮助自己学习！</p>
]]></summary>
        <content type="html"><![CDATA[<p>vim命令大全，需要自己多看多用。也可在终端输入 vimtutor来帮助自己学习！</p>
<!-- more -->
<h2 id="基础命令"><strong>基础命令</strong></h2>
<ul>
<li><code>$ vim code.c</code>: 在终端中打开 code.c 文件</li>
<li><code>$ vim ~/.vimrc</code>: 打开根目录下的 <code>.vimrc</code> 文件</li>
<li><code>$ vim -u NONE -N</code>: 以不加载任何插件的方式启动 vim</li>
<li><code>:h [option]</code>: 显示对命令的帮助</li>
<li><code>:source ~/.vimrc</code>: 重载配置文件(可以在不重启 vim 的情况下重载配置文件)</li>
<li><code>:syntax on</code>: 开启语法</li>
<li><code>:set number</code>: 设置行号</li>
<li><code>:set ft=json</code>: 设置的文件格式为<code>json 格式</code></li>
<li><code>:set ft?</code>: 查看当前文件的 ft 值</li>
<li><code>.</code>: 修改完之后移动至下一个单词出按<code>.</code> 可重复相同操作(厉害!)</li>
<li><code>5.</code>: 重复 5 次相同动作</li>
<li><code>*</code>: 向下查找光标下的单词</li>
<li><code>#</code>: 向上查找光标下的单词</li>
<li><code>ga</code>: 查看当前光标下字符的 unicode 码及其他详细信息</li>
<li><code>:e.</code>: <code>.</code> 代表 <code>pwd</code> 的结果, 即当前工作路径, 这个命令会进入 <code>netrw</code> 的文件管理界面</li>
</ul>
<h2 id="保存退出"><strong>保存退出</strong></h2>
<ul>
<li><code>:q</code>: 退出文件</li>
<li><code>q:</code>: 进入命令历史记录, 与<code>:history</code> 等价</li>
<li><code>q/</code>: 进入搜索历史记录</li>
<li><code>:wq</code>: 保存退出</li>
<li><code>:wa</code>: 保存所有缓冲区</li>
<li><code>:wn</code>: 保存当前缓冲区并进入下一个参数列表</li>
<li><code>:qa</code>: 退出所有缓冲区</li>
<li><code>ZZ</code>: 保存退出</li>
<li><code>:sav path/to.txt</code>: 将本缓冲区保存为文件(相当于另存为, 命令全名是 <code>saveas</code>)</li>
<li><code>:w path/to.txt</code>: 保存到某路径</li>
<li><code>:e!</code>: 重载本文件, 即使有未保存的内容也会被丢弃(edit 缩写)</li>
<li><code>:e path/to.txt</code>: 打开指定文件</li>
<li><code>:e .</code>: 进入 <code>netrw</code> 浏览目录</li>
</ul>
<h2 id="移动"><strong>移动</strong></h2>
<ul>
<li><code>hjkl</code>: 左下上右键</li>
<li><code>10 + hjkl</code>: 向左下上右跳 10 个格</li>
<li><code>gj</code>: 在一段被折为多行时, 将光标向下移动一行(向下移动一个屏幕行)</li>
<li><code>gk</code>: 在一段被折为多行时, 将光标向上移动一行(向上移动一个屏幕行)</li>
<li><code>&gt;&gt;</code>: 整行向右缩进</li>
<li><code>&lt;&lt;</code>: 整行向左缩进</li>
<li><code>:le</code>: 当前行居左对齐</li>
<li><code>:ce</code>: 当前行居中对齐</li>
<li><code>:ri</code>: 当前行居右对齐</li>
<li><code>0</code>: 移动到行首(非字符)</li>
<li><code>^</code>: 光标移至行首(字符)</li>
<li><code>g^</code>: 移动到屏幕行的行首</li>
<li><code>$</code>: 光标移至行尾(换行符)</li>
<li><code>g$</code>: 移动到屏幕行的行尾</li>
<li><code>g_</code>: 光标移至最后一个可见字符上</li>
<li><code>0</code>: 光标移动至行首</li>
<li><code>g;</code>: 跳转到上次修改的位置</li>
<li><code>g,</code>: 跳转到下次修改的位置</li>
<li><code>gi</code>: 跳转到上次退出插入模式的位置并直接进入 <code>Insert Mode</code></li>
<li><code>%</code>: 在 <code>()</code>, <code>[]</code>, <code>{}</code> 之内跳转到包围符号上</li>
<li><code>''</code>, 双反撇号, 跳转到当前文件中最近一次跳转动作发生时的位置</li>
<li><code>'.</code>: 反撇号, 跳转到上次修改的地方</li>
<li><code>w</code>: 跳至下一个词首</li>
<li><code>b</code>: 跳至上一个词首</li>
<li><code>e</code>: 跳至下一个词末端</li>
<li><code>ge</code>: 跳转到上一个词的结尾</li>
<li><code>f</code>: 移动到行内下一个字符, 如 <code>fx</code> 将查找行内出现的下一个 <code>x</code> 字符</li>
<li><code>F</code>: 移动到行内上一个字符, 用法同 <code>f</code></li>
<li><code>t</code>: 移动到行内下一个字符的前一字符上</li>
<li><code>T</code>: 移动到行内上一个字符的下一字符上</li>
<li><code>;</code>: 重复查找, 即重复 <code>f</code> 或 <code>t</code>, 非常有用, 可以与 <code>.</code> 想媲美</li>
<li><code>,</code>: <code>;</code> 的反面, 当按 <code>;</code> 过头了可以用 <code>,</code> 退回来</li>
<li><code>&lt;C-b&gt;</code>: 向前滚一页</li>
<li><code>&lt;C-f&gt;</code>: 向后滚一页</li>
<li><code>&lt;C-e&gt;</code>: 向上滚一行</li>
<li><code>&lt;C-y&gt;</code>: 向下滚一行</li>
<li><code>&lt;C-u&gt;</code>: 向上滚半页</li>
<li><code>&lt;C-d&gt;</code>: 向下滚半页</li>
<li><code>gg</code>: 跳至文件顶部</li>
<li><code>G</code>: 跳至文件底部</li>
<li><code>M</code>: 光标移至页中部</li>
<li><code>L</code>: 光标移至页底部</li>
<li><code>H</code>: 光标移至页顶部</li>
<li><code>88gg</code>: 跳至第 88 行</li>
<li><code>88G</code>: 跳至第 88 行</li>
<li><code>zz</code>: 将当前行置于视图中央</li>
<li><code>zt</code>: 将当前行置于视图顶部</li>
<li><code>zb</code>: 将当前行置于视图底部</li>
<li><code>gd</code>: 跳转到局部变量定义处</li>
<li><code>gD</code>: 跳转到文件内全局声明(从文件开头开始查找)</li>
<li><code>gf</code>: 跳转到相应的头文件</li>
<li><code>&lt;C-o&gt;</code>: Normal 模式下返回上一个操作的位置, Insert 模式下切换到 Normal 模式, 输入完命令后再次进入 Insert 模式: <code>c-o zz</code></li>
<li><code>&lt;C-t&gt;</code>: Normal 模式下返回上一个操作的位置</li>
<li><code>&lt;C-i&gt;</code>: Normal 模式下返回下一个操作的位置</li>
<li><code>&lt;C-^&gt;</code>: 在当前文件与上次编辑的文件中快速切换</li>
<li><code>mm</code>: 为当前位置在当前缓冲区内设置标记 <code>m</code></li>
<li><code>'m</code>: 反撇号, 跳转到设置的标记 <code>m</code> 处</li>
<li><code>mM</code>: 为当前位置设置全局标记 <code>M</code>(必须是大写, 可以跨文件使用)</li>
<li><code>'M</code>: 跳转到全局标记</li>
</ul>
<h2 id="复制粘贴删除"><strong>复制/粘贴/删除</strong></h2>
<ul>
<li>
<p><code>c</code>: 删除并进入<code>插入模式</code> (理解: <code>cert</code> , 会插入)</p>
</li>
<li>
<p><code>cw</code>: 删除一个单词并进入<code>插入模式</code></p>
</li>
<li>
<p><code>C</code>: 删除自游标处到当前行尾, 并进入<code>插入模式</code></p>
</li>
<li>
<p><code>c2c</code>: 删除两行并进入<code>插入模式</code></p>
</li>
<li>
<p><code>cc</code>: 删除一行并进入<code>插入模式</code></p>
</li>
<li>
<p><code>d^</code>: 删除至行首 (理解: <code>delete</code> , 不会插入, 直接删除, 不会复制)</p>
</li>
<li>
<p><code>D</code>: 从当前光标处删除至行尾</p>
</li>
<li>
<p><code>dw</code>: 向右删除一个单词</p>
</li>
<li>
<p><code>d2d</code>: 删除两行</p>
</li>
<li>
<p><code>dd</code>: 删除一行</p>
</li>
<li>
<p><code>d121gg</code>: 从当前行删除到 121 行</p>
</li>
<li>
<p><code>d121j</code>: 从当前行向下删除 121 行</p>
</li>
<li>
<p><code>x</code>: 删除本字符(等于 delete)</p>
</li>
<li>
<p><code>X</code>: 向前删除一个字符(等于 backspace)</p>
</li>
<li>
<p><code>s</code>: 删除右侧并进入插入模式</p>
</li>
<li>
<p><code>S</code>: 删除整行并进入插入模式</p>
</li>
<li>
<p><code>yy</code>: 复制一行</p>
</li>
<li>
<p><code>y$</code>: 从光标当前处复制到结尾, 不会复制到换行符, 但是如果 <code>v$y</code> 则会复制到换行符</p>
</li>
<li>
<p><code>y</code>: 复制所选(可视模式)</p>
</li>
<li>
<p><code>y5j</code>: 向下复制 5 行</p>
</li>
<li>
<p><code>v/d/c/y</code> + <code>[文本对象]</code></p>
</li>
<li>
<ul>
<li>
<p>操作分隔符的文本对象: 用于确定范围</p>
</li>
<li>
<ul>
<li><code>i(/[/{/&quot;/'</code>: 由<code>(/[/{/&quot;/'</code> 包围起来的字符, 不包含 <code>(/[/{/&quot;/'</code></li>
<li><code>a(/[/{/&quot;/'</code>: 由 <code>(/[/{/&quot;/'</code>包围起来的字符及包围符号本身</li>
<li><code>it</code>: 由 tag 包围起来的字符</li>
<li><code>at</code>: 由 tag 包围起来的字符及 tag 本身</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>操作文本块的文本对象</p>
</li>
<li>
<ul>
<li><code>iw</code>: 当前单词</li>
<li><code>aw</code>: 当前单词及一个空格</li>
<li><code>iW</code>: 当前字串</li>
<li><code>aW</code>: 当前字串及一个空格</li>
<li><code>is</code>: 当前句子</li>
<li><code>as</code>: 当前句子及一个空格</li>
<li><code>ip</code>: 当前段落</li>
<li><code>ap</code>: 当前段落记一个空行</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>一般来说, <code>d{motion}</code> 命令和 <code>aw</code>, <code>as</code> 和 <code>ap</code> 配合起来使用比较好,而 <code>c{motion}</code> 命令和 <code>iw</code> 及类似的文本对象一起用效果会更好.</li>
</ul>
</li>
<li>
<p><code>p</code>: 如果整行复制, 粘贴在下方一行. 如果选中复制, 粘贴到当前光标后方</p>
</li>
<li>
<p><code>P</code>: 与 <code>p</code> 方向相反</p>
</li>
<li>
<p><code>gp</code>: 与<code>p</code>类似, 不过会把光标移动至文本的结尾</p>
</li>
<li>
<p><code>gP</code>: 与 <code>P</code>类似, 不过会把光标移动到文本的结尾, 在粘贴多行的时候尤其有用</p>
</li>
</ul>
<h2 id="模式切换"><strong>模式切换</strong></h2>
<ul>
<li><code>i</code>: 当前字符之前插入</li>
<li><code>I</code>: 行首插入</li>
<li><code>a</code>: 当前字符之后插入</li>
<li><code>A</code>: 当前字符行尾插入</li>
<li><code>o</code>: 在下方插入一行并进入<code>Insert Mode</code></li>
<li><code>O</code>: 在上方插入一行并进入<code>Insert Mode</code></li>
<li><code>&lt;C-v&gt;</code>: 进入列选择模式, 可沿垂直方向选中多行, 然后使用大写的 I 和 A 分别可以实现在前侧和后侧批量添加字符, 使用 <code>&gt;</code> 可以向右缩进, 使用 <code>r</code> 可以替换, 特别好用!</li>
<li><code>v</code>: 进入 visual 模式, 移动光标可进行批量选择删除</li>
<li><code>gv</code>: 重复选择上次选择并操作的区域</li>
<li><code>O</code>: 在 Visual 模式下切换高亮选取的活动端使之可调整</li>
</ul>
<h2 id="大小写加减"><strong>大小写/加减</strong></h2>
<ul>
<li>
<p><code>~</code>: 将当前光标处的大小写翻转</p>
</li>
<li>
<p><code>g~5j</code>: 将当前行向下 5 行大小写反转</p>
</li>
<li>
<p><code>gu5j</code>: 将当前行向下 5 行改为小写</p>
</li>
<li>
<p><code>gU5j</code>: 将当前行向下 5 行改为大写</p>
</li>
<li>
<p><code>gUit</code>: 将 tag 包围的内容改为大写</p>
</li>
<li>
<p><code>Vu</code>: 将当前行改为小写</p>
</li>
<li>
<p><code>VU</code>: 将当前行改为大写</p>
</li>
<li>
<p><code>veu</code>: 当前光标至尾端的字符改为小写</p>
</li>
<li>
<p><code>vG~</code>: 将当前光标至文本结尾的字符翻转大小写</p>
</li>
<li>
<p><code>&lt;C-a&gt;</code>: 对数字进行增加操作, 在列选择模式下批量增加数字, 对 Markdown 的列表排序特别好用</p>
</li>
<li>
<ul>
<li><code>&lt;C-v&gt;</code> + <code>select</code> + <code>C-a</code>: 将选择区域数字统一增加 1</li>
<li><code>&lt;C-v&gt;</code> + <code>select</code> + <code>2</code> + <code>C-a</code>: 将选择区域数字统一增加 2</li>
<li><code>&lt;C-v&gt;</code> + <code>select</code> + <code>g</code> + <code>C-a</code>: 将选择区域的数字改为递增为 1 的序列</li>
<li><code>&lt;C-v&gt;</code> + <code>select</code> + <code>2</code> + <code>g</code> + <code>C-a</code>: 将选择区域的数字改为递增为 2 的序列</li>
</ul>
</li>
<li>
<p><code>&lt;C-x&gt;</code>: 对数字进行缩小操作(用法同<code>C-a</code> )</p>
</li>
</ul>
<h2 id="撤销"><strong>撤销</strong></h2>
<ul>
<li><code>u</code>: 撤销 undo(命令模式, 可多次撤销)</li>
<li><code>U</code>: 无论当前行修改了多少次, 全部撤销操作</li>
<li><code>&lt;C-r&gt;</code>: Normal 模式下反撤销</li>
<li><code>:undolist</code>: 撤销历史(命令模式)</li>
<li><code>:undo 5</code>: 撤销 5 个改变(命令模式)</li>
</ul>
<h2 id="folding"><strong>Folding</strong></h2>
<ul>
<li><code>zc</code>: close, 关闭当前光标下可折叠区域</li>
<li><code>zo</code>: open, 打开当前光标下可折叠区域</li>
<li><code>za</code>: toggle, 打开/关闭当前光标下可折叠区域</li>
<li><code>zC/zO/zA</code>: 与小写不同的是操作对象为全局, 与光标位置无关</li>
<li><code>zr</code>: reduce, 减少折叠等级</li>
<li><code>zR</code>: 将所有折叠级别减值最小(直观看来就是缓冲区完全展开了)</li>
<li><code>zm</code>: more, 增加折叠级别</li>
<li><code>zM</code>: 增加折叠级别至最高(直观看来就是缓冲区完全折叠了)</li>
<li><code>zd</code>: 删除当前折叠</li>
<li><code>zE</code>: 删除所有折叠</li>
<li><code>zj</code>: 移动至下一个折叠</li>
<li><code>zk</code>: 移动至上一个折叠</li>
<li><code>zn</code>: 禁用折叠</li>
<li><code>zN</code>: 启用折叠</li>
</ul>
<h2 id="windowtab"><strong>window/tab</strong></h2>
<ul>
<li><code>:tabnew [filename]</code>: 新建一个标签页, 例: <code>tabnew%</code> 以当前文件新建一个标签页, <code>%</code> 表示当前文件</li>
<li><code>:tabclose</code>: 关闭当前标签</li>
<li><code>:tabonly</code>: 关闭所有其他的tab</li>
<li><code>:tabn</code>: 前一个 tab</li>
<li><code>:tabp</code>: 后一个 tab</li>
<li><code>tabdo %s/foo/bar/g</code>: 在所有打开的 tab 上执行替换</li>
<li><code>tab ball</code>: 将所有的缓冲区在 tab 中打开</li>
<li><code>gt</code>: 跳转到下一个 tab</li>
<li><code>gT</code>: 跳转到上一个 tab</li>
<li><code>gt5</code>: 跳转到第 5 个 tab 上</li>
<li><code>:tabn</code>: 移动至下一个标签, 直接使用 gt 也可</li>
<li><code>:tabp</code>: 移动至上一个标签, 直接使用 gT 也可</li>
<li><code>:sp</code>: 上下切割当前文件, 同 <code>&lt;C-w&gt; s</code></li>
<li><code>:vs</code>: 左右切割当前文件, 同 <code>&lt;C-w&gt; v</code></li>
<li><code>:sp [filename]</code>: 上下分割并打开一个新文件, 如果不输入 filename 会切割打开本文件(光标在文件开头位置)</li>
<li><code>:vs [filename]</code>: 左右分割并打开一个新文件, 如果不输入 filename 会切割打开本文件(光标在文件开头位置)</li>
<li><code>&lt;C-w&gt; T</code>: 如果当前 tab 存在多个不同的window, 那么将当前 window 移动到新标签上, 必须是大写</li>
<li><code>&lt;C-w&gt; s</code>: 水平切割当前窗口</li>
<li><code>&lt;C-w&gt; v</code>: 垂直切割当前窗口</li>
<li><code>&lt;C-w&gt; h/j/k/l</code>: 光标向某个方向分屏移动</li>
<li><code>&lt;C-w&gt; w</code>: 在所有窗口间进行切换</li>
<li><code>&lt;C-w&gt; _</code>: 使窗口高度最大化</li>
<li><code>&lt;C-w&gt; |</code>: 使窗口宽度最大化</li>
<li><code>&lt;C-w&gt; =</code>: 使所有窗口等宽等高</li>
<li><code>&lt;C-w&gt; q</code>: quit, 关闭当前分屏, 如果是最后一个, 则退出 vim</li>
<li><code>&lt;C-w&gt; c</code>: close, 关闭当前分屏, 如果是最后一个, 则退出 vim</li>
<li><code>&lt;C-w&gt; o</code>: only, 关闭所有除当前屏幕外的所有分屏</li>
<li><code>&lt;C-w&gt; L</code>: 当前分屏向右移动</li>
<li><code>[N]&lt;C-w&gt; +</code>: 分屏增加 N 列高度(可选)</li>
<li><code>[N]&lt;C-w&gt; &lt;</code>: 分屏减少 N 列宽度(可选)</li>
<li><code>:close</code>: 关闭活动窗口</li>
<li><code>:only</code>: 只留下当前活动窗口</li>
<li><code>new abc.txt</code>: 在新窗口中编辑文件</li>
</ul>
<h2 id="buffer"><strong>Buffer</strong></h2>
<ul>
<li><code>:ls</code>: 显示当前所有 buffer(缓冲区列表)</li>
<li><code>:ls!</code> : 列出非缓冲区列表文件</li>
<li><code>:bn</code>: buffer next, 下一个 buffer</li>
<li><code>:bp</code>: buffer previous, 上一个 buffer</li>
<li><code>:bf</code>: 打开第一个 buffer</li>
<li><code>:bl</code>: 打开最后一个 buffer</li>
<li><code>:b1</code>: 切换到 buffer1(同理可按照数字切换到不同的 buffer)</li>
<li><code>:bd</code>: 删除 buffer(并没有删除文件本身, 只是 buffer 而已)</li>
<li><code>:bd 1 3</code>: 删除 buffer 编号为 <code>1</code>, <code>3</code> 的两个 buffer</li>
<li><code>:bw 3</code> : 将非缓冲区文件全部删除</li>
<li><code>:bfirst</code>: 第一个缓冲区</li>
<li><code>:blast</code>: 最后一个缓冲区</li>
<li><code>:bufdo [command]</code>: 对所有缓冲区执行操作</li>
<li><code>:1,3 bd</code>: 删除 buffer 编号在 <code>1~3</code>之间的所有 buffer</li>
</ul>
<h2 id="tag"><strong>Tag</strong></h2>
<ul>
<li><code>&lt;C-]&gt;</code>: 跳转到当前光标的定义处</li>
<li><code>g &lt;C-]&gt;</code>: 查看当前光标处有多少个定义(可输入数字然后跳转)</li>
<li><code>g ]</code>: 查看当前光标处有多少个定义(可输入数字然后跳转)</li>
<li><code>tag {keyword}</code>: 根据 <code>keyworkd</code> 查找有多少个匹配的 tag</li>
<li><code>tag</code>: 正向遍历标签历史</li>
<li><code>tnext</code>: 跳转到下一处匹配的标签</li>
<li><code>tprev</code>: 跳转到上一处匹配的标签</li>
<li><code>tfist</code>: 跳转到第一处匹配的标签</li>
<li><code>tlast</code>: 跳转到最后一处匹配的标签</li>
<li><code>tselect</code>: 提示用户从标签匹配的列表中选择一项进行跳转</li>
</ul>
<h2 id="quick-list"><strong>Quick-list</strong></h2>
<ul>
<li><code>:cnext</code> : 显示当前页下一个结果</li>
<li><code>:cpre</code> : 显示当前页上一个结果</li>
<li><code>:copen</code> : 打开 Quickfix 窗口</li>
<li><code>:cfirst</code>: 跳转到第一项</li>
<li><code>:clast</code>: 跳转到最后一项</li>
<li><code>:cnfile</code>: 跳转到下一个文件中的第一项</li>
<li><code>:cpfile</code>: 跳转到上一个文件中的最后一项</li>
<li><code>:cc N</code>: 跳转到第 n 项</li>
<li><code>:cclose</code> : 关闭 Quickfix 窗口</li>
<li><code>:cdo {cmd}</code>: 在 quickfix 列表中的每一行上执行 {cmd}</li>
<li><code>:cfdo {cmd}</code>: 在 quickfix 列表上的每个文件上执行一次 {cmd}</li>
<li><code>:cl[ist]</code> : 打开 location list 窗口, 目前看来不需要使用此选项</li>
</ul>
<h2 id="location-list"><strong>Location List</strong></h2>
<p>与 Quick-List 相似, 最大的不同是: Quick-List 是针对多个窗口共享一个结果, 而 <code>Location List</code> 则是各个窗口的结果互相独立</p>
<ul>
<li><code>lopen</code>: 用于打开位置列表窗口</li>
<li><code>lclose</code>: 用于关闭位置列表窗口</li>
<li><code>lnext</code>: 用于切换到位置列表中的下一项</li>
<li><code>lprevious</code>: 用于切换到位置列表中的上一项</li>
<li><code>lwindow</code>: 用于在错误出现时才触发位置列表窗口</li>
</ul>
<h2 id="宏"><strong>宏</strong></h2>
<ul>
<li><code>q + 小写字母</code>: 进入宏记录模式, 记录到<code>小写字母</code>寄存器中, 记录完成后再次按下 <code>q</code> 即可.</li>
<li><code>q + 大写字母</code>: 进入宏记录模式, 在 <code>小写字母</code>寄存器尾部接着添加命令, 记录完成后再次按下 <code>q</code> 即可.</li>
<li><code>@ + 小写字母</code>: 执行对应寄存器内的宏. 可使用前缀添加数字的方式重复多次命令</li>
<li><code>@:</code>: 重复执行上一次运行过的命令, <code>:</code> 寄存器总是保存着最后执行的命令行命令</li>
<li><code>@@</code>: 直接重复上一次的 <code>@</code> 命令, 此命令必须建立在上一次使用了以 <code>@</code> 开头的寄存器宏 或者 刚刚建立了一个寄存器宏的 基础上, 因此经常配合 <code>@:</code> 使用.</li>
<li><code>10@a</code>: 执行寄存器 <code>a</code>中所存储宏 10 次(串行处理, 如果有错误, 则立刻停止, 后续命令不再执行)</li>
</ul>
<h2 id="参数列表"><strong>参数列表</strong></h2>
<p>参数列表与缓冲区的概念很类似, 参数列表的原始含义是我们在终端中使用 <code>vim a.txt b.txt</code> 时后面的一系列文件或参数名, 但是我们也可以在进入 vim 后使用 <code>args</code>手动添加参数文件. 其与缓冲区的区别是:</p>
<ol>
<li>位于参数列表的文件必然位于缓冲区列表中</li>
<li>缓冲区列表永远是乱糟糟的, 但是参数列表永远是秩序井然</li>
</ol>
<ul>
<li><code>:args *.*</code> : 将当前目录下的所有类型的文件加入到参数列表中(不包括文件夹中的文件)</li>
<li><code>:args **/*.*</code> : 将当前目录下的所有文件及子文件夹的所有文件都匹配加入到参数列表中</li>
<li><code>:args *.md aa/**/*.md</code> 表示添加子文件夹下的 md 文件及 aa 文件夹下的和其子文件夹下的 md 文件到参数列表中</li>
<li><code>:args 'cat list.txt'</code>: 用反撇号将命令包围起来, 然后将命令被执行后的结果作为参数加入参数列表中</li>
<li><code>:argdo %s/oldword/newword/egc | update</code> : 对所有存在参数列表中的文件执行命令, s 代表替换, % 指对所有行进行匹配, g 代表整行替换(必用), e 指使用正则表达式, c 代表每次替换前都会进行确认, update 表示对文件进行读写</li>
<li><code>:argdo write</code>: 将所有参数列表中的内容进行缓冲区保存</li>
<li><code>:argdo normal @a</code>: 将当前参数列表的所有缓冲区执行寄存器 a 中所存储的宏</li>
<li><code>:argd *</code> : 清空参数列表</li>
<li><code>:argdo bw</code> : 将参数列表中的所有文件清除出缓冲区</li>
<li><code>args</code>: 显示当前的所有参数列表</li>
<li><code>:next</code>: 跳转到下一个参数列表的文件</li>
<li><code>:prev</code>: 跳转到上一个参数列表的文件</li>
<li><code>:first</code>: 跳转到第一个参数列表的文件</li>
<li><code>:last</code>: 跳转到最后一个参数列表的文件</li>
<li><code>:args **/*.md</code> : 将当前文件夹下所有.md 文件加入到参数列表中(包括子文件夹中的文件)</li>
<li><code>:argdo %s/!\[.*\]/!\[img\]/gc</code>: 将所有参数列表中的以 <code>![</code> 开头, 以 <code>]</code> 结尾的所有字段改为 <code>[img]</code></li>
<li><code>:argdo source FormatCN.vim</code>: 对参数列表中的所有文件执行脚本 <code>FormatCN.vim</code></li>
</ul>
<h2 id="命令行模式"><strong>命令行模式</strong></h2>
<ul>
<li><code>:shell</code>: 调用系统的 <code>shell</code> 来在 vim 进程中执行命令, 执行完使用 <code>exit</code> 退出</li>
<li><code>:term bash</code>: 在底部分割出一个独立窗口并调用 <code>bash</code>, 也可以使用 <code>term zsh</code> 来调用 <code>zsh</code>, 或 <code>:terminal zsh</code></li>
<li><code>&lt;C-w&gt; N</code>: 在进入 <code>:term</code> 的终端模式后, 使用本命令可以获得 <code>Normal 模式</code> 的效果, 使用 <code>i</code> 返回正常的终端模式</li>
<li><code>:col&lt;C-d&gt;</code>: 在 Ex 命令模式中使用补全查看可能的选项, 然后使用 <code>Tab</code>/<code>S-Tab</code> 进行选择/反向选择</li>
<li><code>&lt;C-r&gt;&lt;C-w&gt;</code>: 将当前的光标下的单词插入到命令行中</li>
<li><code>&lt;C-f&gt;</code>: 将正在命令行中输入的内容放入到命令行窗口开始编辑</li>
<li><code>&lt;C-c&gt;</code>: 与 <code>&lt;C-f&gt;</code> 相反, 此命令可以使命令行窗口的当前行内容从命令行窗口放回到命令行中</li>
<li><code>&lt;C-z&gt;</code>: 在终端中将 <code>vim</code> 最小化, 然后如果再需要调用的话使用 <code>fg</code> 进行操作, 使用 <code>jobs</code>查看所有处于后台的工作</li>
<li><code>&lt;C-b&gt;</code>: beginning, 在命令行模式中跳转到行首</li>
<li><code>&lt;C-e&gt;</code>: end, 在命令行模式中跳转到结尾</li>
<li><code>&lt;C-p&gt;</code>: 在命令行模式中显示上次的命令</li>
<li><code>&lt;C-n&gt;</code>: 在命令行模式中显示下次的命令</li>
<li><code>:!&lt;command&gt;</code>: 在 shell 中执行命令</li>
<li><code>!sh %</code>: 将当前文件使用外部程序 sh 执行, <code>%</code> 代表本文件</li>
<li><code>!!&lt;command&gt;</code>: 运行命令并将结果作为当前行的内容, 同 <code>:read !&lt;command&gt;</code></li>
<li><code>:!ls</code>: 显示当前工作目录下的所有文件(此操作属于调用系统进程, 使用!来调用系统操作是 Vim 的一大特点)</li>
<li><code>:w !sudo tee % &gt; /dev/null</code>: 在当前用户没有权限对当前文件做操作时使用超级管理员身份进行操作</li>
<li><code>:ls</code>: 列出当前所有的缓冲区文件列表, 执行的是 vim 的 ls 命令</li>
<li><code>:f</code>: 显示当前文件路径, (使用了 <code>&lt;C-g&gt;</code> 代替, 此项基本不会用了)</li>
<li><code>:command</code>: 显示当前所文件的所有可使用命令</li>
<li><code>:retab</code> : 重新生成所有的 tab(主要用于在 .vimrc 中重新设置了 tab 格式, 然后在已存在旧格式 tab 的文档进行重生成)</li>
<li><code>:map g</code>: 查看所有以 <code>g</code> 开头的映射</li>
</ul>
<blockquote>
<p>❝Vim 的先祖是 vi, 正是 vi 开创了区分模式编辑的范例. 相应的, vi 奉 一个名为 ex 的行编辑器为先祖, 这就是为什么会有 Ex 命令.</p>
</blockquote>
<p>Ex 命令在命令行模式中执行, 而命令行模式的进入方式为 <code>:</code> 键, 因此我们可以看到所有的 <code>Ex</code> 命令都是以 <code>:</code> 开始的, 输入完命令后按下确定键 <code>&lt;CR&gt;</code> 即可执行, 虽然 <code>Ex</code> 命令年代久远, 但是不可否认其语法的简洁明了以及高效, 很多复杂的操作往往都是通过 <code>Ex</code> 命令来进行处理.</p>
<ul>
<li>
<p><code>:[range] &lt;command&gt; [target]</code>: 执行命令并将结果放入目标位置</p>
</li>
<li>
<ul>
<li>
<p><code>:3,5 w !bash</code>: 将 3~5 行写入 bash</p>
</li>
<li>
<p><code>:. w !bash</code>: 将当前行写入 bash</p>
</li>
<li>
<p><code>:. !bash</code>: 将当前行执行结果写入当前 buffer</p>
</li>
<li>
<p><code>:3,5 delete x</code>: 将当前行执行结果删除到 x 寄存器</p>
</li>
<li>
<p><code>:3,5 yank x</code>: 将当前行执行结果复制到 x 寄存器</p>
</li>
<li>
<p><code>:. put x</code>: 在当前行后粘贴寄存器 x 的内容</p>
</li>
<li>
<p><code>:3,5 copy .</code>: 将 3~5 行复制到当前行下</p>
</li>
<li>
<p><code>:3,5 move .</code>: 将 3~5 行移动到当前行下</p>
</li>
<li>
<p><code>:3,5 join</code>: 将 3~5 行进行合并</p>
</li>
<li>
<p><code>[range] normal [cmd]</code>: normal 用来指定在 normal 模式下对文本的操作命令</p>
</li>
<li>
<ul>
<li><code>:3,5 normal .</code>: 对 3~5 行执行 <code>.</code> 重复命令</li>
<li><code>:3,5 normal @q</code>: 对 3~5 行执行寄存器 <code>q</code> 内存储的命令</li>
<li><code>'&lt;,'&gt; normal @a</code>: 在所选高亮区域上执行宏(如果有错误也不停止, 因为是针对每一行执行的, 出错了只需要不处理那一行就行了)</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p><code>:[range] global/{pattern}/[cmd]</code>: 对指定范围内匹配的所有行执行 Ex 命令</p>
</li>
<li>
<ul>
<li><code>:g/re/d</code>: 删除所有匹配到 <code>re</code> 的行</li>
<li><code>:g/re/p</code>: 打印所有匹配到 <code>re</code> 的行</li>
<li><code>:g//d</code>: 使用上次的查找结果进行匹配然后删除</li>
<li><code>:v/re/d</code>: vglobal 的反面, 只保留匹配到 <code>re</code> 的行</li>
<li><code>:g/TODO/yank A</code>: 将结果匹配到 <code>TODO</code> 的行复制到寄存器 <code>a</code> 的原内容尾部</li>
<li><code>:g/TODO/t$</code>: 将结果匹配到 <code>TODO</code> 的行复制到本缓冲区的尾部</li>
<li><code>:g:/{pattern}/[range][cmd]</code>: 可以用 <code>:g/{pattern}</code> 匹配作为参考点, 动态设置 <code>[cmd</code> 的 range</li>
<li><code>g/{/ .+1,/}/-1 sort</code>: 会在每个 <code>{</code> 开始找, 然后在之后一直执行到 <code>}</code> 为止, 进行排序</li>
<li><code>g/{/sil .+1,/}/-1 &gt;</code>: 会在每个 <code>{</code> 开始找, 然后在之后一直执行到 <code>}</code> 为止, 进行缩进(加入 sil 是为了屏蔽提示信息)</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li><code>:3,5 s/{pattern}/{string}/[flags]</code>: 将 <code>3~5</code>行进行相应替换</li>
<li><code>:3,5 join</code>: 将 <code>3~5</code>行进行合并</li>
<li><code>:3 p</code>: 打印第 3 行</li>
<li><code>:3,5 p</code>: 打印 3~5 行</li>
<li><code>:.,.+3 p</code>: 打印本行以下的三行内容, <code>+3</code> 代表偏移</li>
<li><code>:% p</code>: 打印本 buffer 的所有行, <code>%</code> 代表所有行, 是 <code>1:$</code> 的简写</li>
<li><code>:0,$ p</code>: 打印本 buffer 所有行, <code>$</code> 代表最后一行</li>
<li><code>:.,$ p</code>: 打印本 buffer 内从本行到结尾的所有内容, <code>.</code> 代表当前行</li>
<li><code>/&lt;html&gt;/+1,/&lt;\/html&gt;/-1 p</code>: 使用 patten 指定范围, <code>+1</code> 表示偏移</li>
<li><code>:6t.</code>: 把第 6 行复制到当前行下方, tail 代表尾巴, 遵守 <code>from...to...</code> 的含义</li>
<li><code>:t6</code>: 把当前行复制到第 6 行下方, <strong>当.位于首位时可以省略.</strong>, 因此全称是 <code>:.t6</code></li>
<li><code>:t.</code>: 粘贴当前行到下方, 与 <code>yyp</code> 不同的是本方式不会将内容放到寄存器中, 而 <code>yyp</code> 会将内容复制到 <code>unname</code> 寄存器与 <code>0</code> 寄存器</li>
<li><code>:t$</code>: 粘贴当前行到文本结尾</li>
<li><code>:'&lt;,'&gt;t0</code>: 把高亮选中的行复制到文件开头, <code>'&lt;</code> 代表高亮选取的第一行, <code>'&gt;</code> 代表高亮选取的最后一行</li>
<li><code>:'&lt;,'&gt;m$</code>: 把高亮选中的行移动到文件结尾</li>
<li><code>:'&lt;,'&gt;A;</code>: 把当前文件的所有行的尾部加上 <code>;</code></li>
</ul>
</li>
<li>
<p><code>:!!</code>: 重复执行上一次运行过的命令</p>
</li>
<li>
<p><code>:read !&lt;command&gt;</code>: 将命令的结果输入(重定向)到当前缓冲区</p>
</li>
<li>
<p><code>:[range]write !sh</code>: 将当前缓冲区的内容, 在 shell 中逐行执行, 与 <code>read !&lt;command&gt;</code>作用正好相反, <code>!</code>表示外部程序</p>
</li>
<li>
<p><code>:[range]write ! sh</code>: 将当前缓冲区的内容, 在 shell 中逐行执行, <code>!</code>表示外部程序</p>
</li>
<li>
<p><code>:[range]write! sh</code>: 将当前缓存区内容写入到一个名为 sh 的文件, <code>!</code>表示强制覆盖式写入</p>
</li>
<li>
<p><code>:[range]write! filename</code>: 将当前缓冲区内容另存为到 filename 文件中</p>
</li>
<li>
<p><code>:.,$ sort [option]</code>: 从当前行到末尾进行排序</p>
</li>
<li>
<ul>
<li><code>!</code>: 翻转顺序, 默认小在前, 翻转后大在前</li>
<li><code>i</code>: 忽略大小写</li>
<li><code>l</code>: ...</li>
<li><code>n</code>: ...</li>
<li><code>o</code>: ...</li>
<li><code>r</code>: ...</li>
<li><code>u</code>: ...</li>
<li><code>x</code>: ...</li>
</ul>
</li>
<li>
<p><code>:2,$ !sort -t',' -k2</code>: 使用外部 <code>sort</code> 程序进行排序, 以 <code>,</code> 为分隔符, 以第二项进行排序</p>
</li>
</ul>
<h2 id="insert-模式"><strong>Insert 模式</strong></h2>
<ul>
<li><code>&lt;C-p&gt;</code>: 选择上方补全</li>
<li><code>&lt;C-n&gt;</code>: 选择下方补全</li>
<li><code>⎋</code>: 退出插入模式(推荐)</li>
<li><code>&lt;C-c&gt;</code>: 退出插入模式</li>
<li><code>&lt;C-[&gt;</code>: 退出插入模式</li>
<li><code>&lt;C-u&gt;</code>: 向左删除到行首</li>
<li><code>&lt;C-w&gt;</code>: 向左删除一个单词</li>
<li><code>&lt;C-h&gt;</code>: 向左删除一个字符</li>
<li><code>&lt;C-t&gt;</code>: 整行向右偏移</li>
<li><code>&lt;C-d&gt;</code>: 整行向左偏移</li>
<li><code>&lt;C + r&gt;= &lt;function&gt;</code>: 进行计算并将结果输出到当前缓冲区中</li>
<li><code>&lt;C-v&gt;065</code>: 输入大写字母 A</li>
<li><code>&lt;C-v&gt;u{123}</code>: 按照 unicode 码以 10 进制来输入</li>
<li><code>&lt;C-v&gt;u{1234}</code>: 按照 unicode 码以 16 进制来输入</li>
<li><code>&lt;C-v&gt; &lt;Tab&gt;</code>: 无论 <code>expandtab</code> 选项是否开启都会插入制表符</li>
<li>插入模式中的粘贴操作参考这里</li>
</ul>
<h2 id="路径"><strong>路径</strong></h2>
<p>vim 的工作路径是使用中要格外注意的地方, 简单来说, 终端中的 vim 默认会把终端当前的路径作为其工作路径, 当然我们可以使用 <code>cd</code> 使其工作路径变更</p>
<ul>
<li><code>:cd [path]</code>: 设置此次vim的工作目录为path</li>
<li><code>:cd %:h</code>: cd 到当前缓冲区所属目录中</li>
<li><code>:cd ../</code>: cd 到上一级</li>
<li><code>:pwd</code>: 显示当前工作路径</li>
<li><code>:lcd [path]</code>: 设置当前窗口的工作目录为 path(与 cd 不同的是只会改变当前 window 的工作路径, 其他 window 的不受此影响)</li>
</ul>
<p>vim 为我们提供了一些可以使用的宏用来表示相关路径或文件名称:</p>
<ul>
<li><code>%:h</code>: 表示当前文件所在目录的相对工作目录路径(不含文件名及扩展)</li>
<li><code>%:p</code>: 表示当前文件所在目录的绝对路径(含文件名及扩展)</li>
<li><code>%:t</code>: 文件名及扩展</li>
<li><code>%:r</code>: 移除扩展之后的所有内容</li>
<li><code>%:e</code>: 扩展名</li>
</ul>
<p>在使用以上这几种宏时, 我们可以使用 <code>&lt;Tab&gt;</code> 使其自动展开, 有些命令不支持自动展开的话需要使用 <code>expand()</code> 命令</p>
<ul>
<li><code>echo expand('%:e')</code>: 打印当前文档扩展名, markdown 是 <code>md</code></li>
<li><code>cd %:h&lt;Tab&gt;</code>: cd 到当前缓冲区所属目录中, 在最后可以使用 <code>&lt;Tab&gt;</code> 进行自动展开</li>
<li><code>e %&lt;Tab&gt;</code>: 会自动扩展为当前文件含相对工作目录的路径全名</li>
</ul>
<h2 id="寄存器"><strong>寄存器</strong></h2>
<p>寄存器是 vim 的一种特有概念, 其他文本编辑器默认都会用系统剪贴板作为复制粘贴的根据地, 然后 vim 另辟蹊径使用多种不同类型寄存器作为临时内容存储位置. 我们可以在复制粘贴时使用指定的寄存器定制化我们的需求, 也可以在录制宏及使用宏时指定寄存器, 大大地提高了我们的工作效率.</p>
<p>很多刚使用 vim 的人会抱怨无法复制内容到 vim 外或 vim 内, 然后各种搜索如何使 vim 的默认复制操作与剪贴板交互, 最后定义了一大堆按键, 譬如 <code>&quot;*y</code>, <code>set clipboard=unnamed</code>, 其实大可不必, 寄存器是 vim 的高效操作方式之一, 接受了这种方式才能更好地利用 vim 来为我们服务(虽然刚开始适应的过程必然是痛苦的)</p>
<p>总的来说 Vim 的删除, 复制与粘贴命令以及定义宏时都会用到众多寄存器中的某一个. 可以通过给命令加 <code>&quot;{register}</code> 前缀的方式指定要用的寄存器. 若不指明, Vim 将缺省使用无名寄存器</p>
<ul>
<li>
<p>无名寄存器<br>
所有删除复制粘贴操作如果不显示指明寄存器类型的话使用的都是无名寄存器, 其标志符是 <code>&quot;&quot;</code>.</p>
</li>
<li>
<p>复制寄存器<br>
使用 <code>y</code> 复制后内容会被放到复制寄存器及无名寄存器中, 但是复制寄存器是稳定的, 无名寄存器的内容会时刻被重置替换. 其标志符是 <code>&quot;0</code></p>
</li>
<li>
<p>粘贴板寄存器<br>
用于与系统的其他应用中进行复制粘贴交互, 等于系统的剪贴板. 其标识符是 <code>&quot;*</code>(或 <code>&quot;+</code>)</p>
</li>
<li>
<p>黑洞寄存器<br>
所有放入黑洞寄存器的内容全部被丢弃, 相当于完全删除, 不留痕迹, 其标识符是 <code>&quot;_</code></p>
</li>
<li>
<p>有名寄存器<br>
以单个小写字母命名的寄存器, 可用于自定义存储空间, 一共有 26 个</p>
</li>
<li>
<p>特殊寄存器</p>
</li>
<li>
<ul>
<li><code>&quot;%</code>: 当前文件名</li>
<li><code>&quot;#</code>: 轮换文件名</li>
<li><code>&quot;.</code>: 上次插入的文本</li>
<li><code>&quot;:</code>: 上次执行的 Ex 命令</li>
<li><code>&quot;/</code>: 上次查找的模式</li>
</ul>
</li>
</ul>
<h3 id="使用方式"><strong>使用方式</strong></h3>
<ul>
<li><code>&quot;&quot;p</code>: 从无名寄存器中取值进行粘贴</li>
<li><code>&quot;ay</code>: 将内容复制到有名寄存器 <code>a</code></li>
<li><code>&quot;_y</code>: 将内容复制到黑洞寄存器, 相当于彻底地删除</li>
<li><code>&quot;ap</code>: 从自定义寄存器中取出内容进行粘贴</li>
<li><code>&quot;0p</code>: 从复制寄存器中取出内容进行粘贴, 默认的 p 是从无名寄存器取值</li>
<li><code>&quot;*p</code>: 从系统粘贴板寄存器中取出内容进行粘贴</li>
<li><code>&lt;C-r&gt;&quot;</code>: 在插入模式中将无名寄存器的内容粘贴进来</li>
<li><code>&lt;C-r&gt;*</code>: 在插入模式中将系统粘贴板寄存器的内容粘贴进来</li>
<li><code>&lt;C-r&gt;0</code>: 在插入模式中将复制寄存器的内容粘贴进来</li>
<li><code>&lt;C-r&gt;%</code>: 插入当前文件名(因为 &quot;% 寄存器中存储了当前文件名)</li>
<li><code>:reg a</code>: 查看有名寄存器 <code>a</code> 的内容</li>
<li><code>:reg *</code>: 查看粘贴板寄存器 <code>*</code> 的内容</li>
<li><code>:reg &quot;</code>: 查看无名寄存器 <code>&quot;</code> 的内容</li>
<li><code>:put a</code>: 将有名寄存器 <code>a</code> 的内容粘贴到当前缓冲区中, 与 <code>&quot;ap</code> 不同的是 <code>p</code> 用于只能在光标之前或光标之后进行粘贴, 但是 <code>put</code> 则会始终将内容粘贴到新的一行上</li>
<li><code>:d a</code>: 将内容删除到有名寄存器 <code>a</code> 中</li>
</ul>
<blockquote>
<p>❝使用 Visual Mode 时, 在选中的文本上使用 <code>p</code> 将直接替换该部分文本(替换后被替换的文本会被放入到无名寄存器中), 可用于解决需要删除然后粘贴但是会影响到无名寄存器的问题</p>
</blockquote>
<h2 id="vimdiff"><strong>vimdiff</strong></h2>
<figure data-type="image" tabindex="1"><img src="https://pic4.zhimg.com/80/v2-7b7f72df7db5d10e3d73ab21c15246bb_1440w.webp" alt="img" loading="lazy"></figure>
<p>git 与 vim 可以说是非常好的一对搭档了, 平时在终端中提交 commit 我们都少不了与 <code>vim</code>打交道, vimdiff 是 vim 提供的专门用于修正 git 冲突文件的一款工具</p>
<p>若想使用 vimdiff 作为冲突修改工具, 需要设置 <code>~/.gitconfig</code> 的以下项</p>
<pre><code class="language-text">[diff]
    tool = vimdiff
[merge]
    tool = vimdiff
</code></pre>
<p>在 vimdiff 中, 一共有四个窗口, 上面依次是 <code>LOCAL</code>, <code>BASE</code>, <code>REMOTE</code>, 底部则是一个最终的文件结果窗口, 整个过程我们只需要将光标在最下方窗口上上下移动, 使用 <code>diffget</code> 命令从 <code>LOCAL</code>, <code>BASE</code>, <code>REMOTE</code> 中选择需要使用哪一个作为本行的最终结果(当然也可以跳到上面的窗口中使用 diffput 放置结果到底部窗口上</p>
<ul>
<li><code>:diffget LOCAL</code>: 选择 LCOAL 作为本行最终结果</li>
<li><code>:diffget REMOTE</code>: 选择 REMOTE 作为本行最终结果</li>
<li><code>:diffget BASE</code>: 选择 BASE 作为本行最终结果</li>
<li><code>:diffput [num]</code>: 放置结果到缓冲区上, <code>num</code> 为缓冲区编号</li>
<li><code>:diffg L</code>: 这里 vim 为我们做了简略命令, 同样可用于 <code>REMTOE</code> 与 <code>BASE</code> 上</li>
<li><code>dp/do</code>: 如果只有两个文件则可以使用 <code>dp/do</code> 来替代 <code>:diffput/:diffget</code></li>
<li><code>:ls!</code>: 显示当前所有缓冲区的号码</li>
<li><code>[c</code>: conflict, 移动到上一个冲突处</li>
<li><code>]c</code>: conflict, 移动到下一个冲突处</li>
<li><code>:wqa</code>: 冲突修复完成保存退出, 如果仍然有文件冲突则进入下一个冲突</li>
<li><code>$git merge --continue</code>: 冲突全部解决完后在外界终端中使用 <code>git merge --continue</code>继续之前的 <code>merge</code> 操作</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vs2019连接本地虚拟机linux]]></title>
        <id>https://tangyin1.github.io/post/vs2019-lian-jie-ben-di-xu-ni-ji-linux/</id>
        <link href="https://tangyin1.github.io/post/vs2019-lian-jie-ben-di-xu-ni-ji-linux/">
        </link>
        <updated>2023-10-31T11:13:55.000Z</updated>
        <summary type="html"><![CDATA[<p>今天准备使用vs2019远程连接Linux进行一些小玩意，结果死活连不上。捣鼓了一会终于成功！</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天准备使用vs2019远程连接Linux进行一些小玩意，结果死活连不上。捣鼓了一会终于成功！</p>
<!-- more -->
<p>正常的步骤是 先在linux下下载ssh</p>
<p>执行</p>
<p><code>sudo apt install openssh-server</code>----下载ssh</p>
<p><code>sudo service ssh start</code>----启动ssh服务</p>
<p>然后</p>
<p>在 Visual Studio 中，依次选择菜单栏上的“工具”&gt;“选项”，以打开“选项”对话框。 然后，依次选择“跨平台”&gt;“连接管理器”，以打开“连接管理器”对话框</p>
<p>在“连接管理器”对话框中，选择“添加” 按钮，以添加新连接</p>
<p>然后按照要求填主机名 用户名 密码</p>
<p>正常来说到了这一步基本上就没啥了，会添加成功。但我今天死活都添加不上。</p>
<p>后面捣鼓了好久才发现一个解决办法    那就是    -------防火墙</p>
<p>可能是Windows和linux下面的防火墙把22端口给墙了，</p>
<p>于是乎我直奔防火墙进行修改</p>
<p>在windows下面</p>
<p>要在防火墙上打开SSH端口，你可以按照以下步骤进行操作：</p>
<ol>
<li>打开开始菜单并搜索&quot;Windows Defender 防火墙&quot;，然后打开防火墙设置。</li>
<li>在防火墙设置窗口中，点击&quot;高级设置&quot;链接。</li>
<li>在高级安全设置窗口中，你将看到&quot;入站规则&quot;和&quot;出站规则&quot;两个选项。这些规则控制了进入和离开计算机的网络流量。</li>
<li>如果你的虚拟机是在本地网络中，你需要在&quot;入站规则&quot;中创建一个新规则。右键点击&quot;入站规则&quot;，然后选择&quot;新建规则&quot;。</li>
<li>在新建入站规则向导中，选择&quot;端口&quot;选项，然后点击&quot;下一步&quot;。</li>
<li>选择&quot;特定本地端口&quot;，并输入SSH使用的端口号（默认为22）。点击&quot;下一步&quot;。</li>
<li>选择&quot;允许连接&quot;，然后点击&quot;下一步&quot;。</li>
<li>在&quot;配置配置文件&quot;中，选择适用于你的网络配置的选项。如果你不确定，可以选择默认选项&quot;域网络、专用网络和公用网络&quot;。点击&quot;下一步&quot;。</li>
<li>输入规则的名称和描述（可选），然后点击&quot;完成&quot;。</li>
</ol>
<p>在linux下</p>
<p>进入root模式</p>
<p>检查防火墙规则：运行以下命令查看当前的iptables规则：</p>
<p><code>sudo iptables -L</code></p>
<p>然后一看好像真没关于ssh 22的端口</p>
<p>于是</p>
<ul>
<li>
<p>允许SSH连接：如果没有针对SSH连接的规则，可以运行以下命令添加规则：</p>
<pre><code>sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT
</code></pre>
</li>
<li>
<p>保存规则：如果你的Linux虚拟机重启后需要保留规则，你需要保存iptables规则。运行以下命令保存规则：</p>
<pre><code>sudo iptables-save &gt; /etc/iptables/rules.v4
</code></pre>
</li>
</ul>
<p>然后再使用vs2019连接，连接成功！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搜索方法分享]]></title>
        <id>https://tangyin1.github.io/post/sou-suo-fang-fa-fen-xiang/</id>
        <link href="https://tangyin1.github.io/post/sou-suo-fang-fa-fen-xiang/">
        </link>
        <updated>2023-10-28T13:00:20.000Z</updated>
        <summary type="html"><![CDATA[<p>关于现在搜索能力的一些信息</p>
]]></summary>
        <content type="html"><![CDATA[<p>关于现在搜索能力的一些信息</p>
<!-- more -->
<h3 id="搜索方式的选择">搜索方式的选择</h3>
<h5 id="谷歌bing微信公众号短视频平台搜狗-百度等一系列国内搜索引擎">谷歌&gt;bing&gt;微信公众号&gt;短视频平台&gt;搜狗、百度等一系列国内搜索引擎</h5>
<h3 id="搜索技巧">搜索技巧</h3>
<h4 id="1关键字-限定关键字">1.关键字 +&quot;&quot;  （限定关键字）</h4>
<p>有时候想快速搜索到自己<font color='red'>想要</font>的东西，但有时会被大量搜索信息覆盖掉自己想要的信息时，这时只需要在需要搜索的词语加上英文的双引号就可以。</p>
<p>列如你想搜索  <font color='red'>易阳千喜</font> 并不是那个明星 <strong>易烊千玺</strong> 时，不加&quot;&quot;会出现大量关于易烊千玺的信息，这时候加上<font color='red'>&quot;&quot;</font>会减少大量不需要的信息。</p>
<h3 id="2intitle-限定标题">2.intitle （限定标题）</h3>
<p>在检索信息的时候，一般都是标题加上精简内容出现在我们的面前，有时候搜索相关标题会更好的让我们找到相关的文章或者其他内容。</p>
<p>使用方法： intitle :+你所需要搜索的内容</p>
<p>但这种只能限定一个关键字段</p>
<h3 id="3allintitle-限定标题多个关键字">3.allintitle (限定标题多个关键字)</h3>
<p>使用方法与intitle一样，但可以包含多个关键字</p>
<h3 id="4intext限定内容关键字">4.intext(限定内容关键字)</h3>
<p>搜索相关文章信息中的关键字，由于有时候网上标题党过多，内容并没有自己想要的内容，这时候再加上intext会更加精准的搜索到自己想要的内容，比如想要搜索标题含有李佳琪但内容中含有哭泣的信息，这时候就要搜索栏上输入</p>
<p>intitle:&quot;小杨哥&quot; intext:&quot;哭泣&quot;</p>
<h3 id="5inurl限定网址关键字">5.inurl(限定网址关键字)</h3>
<p>例如：搜索</p>
<p>李子柒 inurl:cctv</p>
<p>搜索到关于的都是关于cctv对李子柒的采访报道等</p>
<p>在这里再加一个网站：SimilarSites 可以搜索一个网站相似内容的网址、例如在里面搜索：www.bilibili.com</p>
<p>会出现youtube，知乎等和b站有着相似度的网址。</p>
<h3 id="6site限定网址来源">6：site(限定网址来源)</h3>
<p>后面需要接完整的域名，例如cctv.com bilibili.com</p>
<h3 id="7imagesize-限定图片尺寸大小">7.imagesize (限定图片尺寸大小)</h3>
<p>搜索语法：【搜索图片】+imagesize:[尺寸大小]</p>
<p>列如：</p>
<p>黑丝 imagesize:2903x1440</p>
<h3 id="8filetype-限定文件格式">8.filetype （限定文件格式）</h3>
<p>例如：研究报告 filetype:pdf</p>
<p>在搜索图片的时候也可以限定要的格式 例如 小猫咪 filetuype:jpg</p>
<h2 id="关于资源搜索方法">关于资源搜索方法</h2>
<h3 id="1电子书">1.电子书</h3>
<p>在国内建议使用，微信读书、得到、网站的话使用鸠摩搜书</p>
<p>使用谷歌的话，就直接搜  best free ebook download sistes 大部分出现的z-library      manybooks等</p>
<p>论文搜索 ：谷歌学术  scihub</p>
<h3 id="2ppt">2.PPT</h3>
<p>1.iSlide插件</p>
<p>2.canva.com（这是个非常好用的网址）</p>
<h3 id="3软件">3.软件</h3>
<p>https://alternativeto.net/</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[线程池的一些相关知识]]></title>
        <id>https://tangyin1.github.io/post/xian-cheng-chi-de-yi-xie-xiang-guan-zhi-shi/</id>
        <link href="https://tangyin1.github.io/post/xian-cheng-chi-de-yi-xie-xiang-guan-zhi-shi/">
        </link>
        <updated>2023-10-18T06:48:02.000Z</updated>
        <summary type="html"><![CDATA[<p>😀😀😀最近在b站上刷到一个关于线程池的课程，以前学os的时候也没认真学习相关代码知识，只是了解一下理论知识，知道一些阻塞，竞争，时间片轮转等等一些，以下是相关视频下面记得笔记。<br>
（不过存在一些问题还没有解决，在手写一个线程池的那里，没有正确写出，编译正常，但运行时会阻塞卡住，以后学习之后再来解决）😀😀😀</p>
]]></summary>
        <content type="html"><![CDATA[<p>😀😀😀最近在b站上刷到一个关于线程池的课程，以前学os的时候也没认真学习相关代码知识，只是了解一下理论知识，知道一些阻塞，竞争，时间片轮转等等一些，以下是相关视频下面记得笔记。<br>
（不过存在一些问题还没有解决，在手写一个线程池的那里，没有正确写出，编译正常，但运行时会阻塞卡住，以后学习之后再来解决）😀😀😀</p>
<!-- more -->
<h3 id="进程的概念">进程的概念</h3>
<p>进程就是运行中的程序</p>
<ul>
<li>
<p>线程就是进程中的进程</p>
</li>
<li>
<p>线程的最大数量取决于CPU的核心数，最大线程数并不等于cpu核数，一个核可以多线程</p>
</li>
</ul>
<h3 id="join">join()</h3>
<ol>
<li>
<p>主程序等待线程执行完毕：join()</p>
</li>
<li>
<p>分离线程：detach()</p>
</li>
<li>
<p>joinable():判断进程是否可以使用join函数，可以则返回true，否则返回false</p>
</li>
</ol>
<p>​    可能会出现阻塞状态，然后join会使子线程执行完毕，主线程才会执行</p>
<p>std：：ref  传递引用类型</p>
<h3 id="互斥量解决多线程数据共享问题">互斥量解决多线程数据共享问题</h3>
<ul>
<li>
<p>通过加锁解锁的方式来解决</p>
</li>
<li>
<p>在mutex头文件中</p>
</li>
<li>
<p><font color='red'>lock()加锁</font></p>
</li>
<li>
<p><font color='red'>unlock()解锁 </font></p>
</li>
</ul>
<p><strong>如果多线程程序每一次运行的结果和单线程运行的结果始终是<font color='red'>一样的</font>，那么你的线程就是<font color='red'>安全的</font></strong></p>
<h3 id="lock_guard-与unique_lock">lock_guard 与unique_lock</h3>
<p>lock_guard：互斥量封装类，用于<font color='red'>保护共享数据</font>，防止多个线程同时访问同一资源而导致的数据竞争问题</p>
<p>特点：</p>
<p>当析构函数被调用时，该互斥量会自动解锁</p>
<p>对象不能复制或者移动，因此它只能在局部作用域中使用</p>
<h3 id="stdunique_lock"><strong>std::unique_lock</strong></h3>
<p><code>std::unique_lock</code> 是 C++ 标准库中提供的一个互斥量封装类，用于在多线程程序中对互斥量进行加锁和解锁操作。它的主要特点是可以对互斥量进行更加灵活的管理，包括延迟加锁、条件变量、超时等。<font color='red'>在实际开发过程中使用的很频繁</font></p>
<p><code>std::unique_lock</code> 提供了以下几个成员函数：</p>
<ul>
<li>
<p><code>lock()</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁。</p>
</li>
<li>
<p><code>try_lock()</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则函数立即返回 <code>false</code>，否则返回 <code>true</code>。</p>
</li>
<li>
<p><code>try_lock_for(const std::chrono::duration&lt;Rep, Period&gt;&amp; rel_time)</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间。</p>
</li>
<li>
<p><code>try_lock_until(const std::chrono::time_point&lt;Clock, Duration&gt;&amp; abs_time)</code>：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间点。</p>
</li>
<li>
<p><code>unlock()</code>：对互斥量进行解锁操作。</p>
</li>
</ul>
<p>除了上述成员函数外，<code>std::unique_lock</code> 还提供了以下几个构造函数：</p>
<ul>
<li><code>unique_lock() noexcept = default</code>：默认构造函数，创建一个未关联任何互斥量的 <code>std::unique_lock</code> 对象。</li>
<li><code>explicit unique_lock(mutex_type&amp; m)</code>：构造函数，使用给定的互斥量 <code>m</code> 进行初始化，并对该互斥量进行加锁操作。</li>
<li><code>unique_lock(mutex_type&amp; m, defer_lock_t) noexcept</code>：构造函数，使用给定的互斥量 <code>m</code> 进行初始化，但不对该互斥量进行加锁操作。</li>
<li><code>unique_lock(mutex_type&amp; m, try_to_lock_t) noexcept</code>：构造函数，使用给定的互斥量 <code>m</code> 进行初始化，并尝试对该互斥量进行加锁操作。如果加锁失败，则创建的 <code>std::unique_lock</code> 对象不与任何互斥量关联。</li>
<li><code>unique_lock(mutex_type&amp; m, adopt_lock_t) noexcept</code>：构造函数，使用给定的互斥量 <code>m</code> 进行初始化，并假设该互斥量已经被当前线程成功加锁。</li>
</ul>
<h3 id="call_once与其使用场景">call_once与其使用场景</h3>
<p>单例设计模式是一种常见的设计模式，用于确保某个类只能创建一个实例。由于单例实例是全局唯一的，因此在多线程环境中使用单例模式时，需要考虑线程安全的问题</p>
<p>懒汉模式、饿汉模式</p>
<h3 id="异步并发">异步并发</h3>
<ul>
<li>
<p>async、future</p>
<p>是C++11引入的一个函数模板，用于异步执行一个函数，并返回一个std::future对象，表示异步操作的结果。使用std::async可以方便地进行异步编程，<font color='red'>避免了手动创建线程和管理线程的麻烦。</font></p>
</li>
<li>
<p>packaged</p>
<p>在C++中，packaged_task是一个类模板，用于将一个可调用对象（如函数、函数对象或Lambda表达式）封装成一个异步操作，并返回一个std::future对象，表示异步操作的结果。packaged_task可以方便地将一个函数或可调用对象转换成一个异步操作，供其他线程使用。</p>
</li>
</ul>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;future&gt;
using namespace std;

int func()
{
	int a = 0;
	for (int i=0; i &lt; 1000; i++)
	{
		a++;

	}
	return a;

}

int main()
{
	//future&lt;int&gt; result = async(launch::async, func);
	packaged_task&lt;int()&gt;task(func);
	auto result = task.get_future();
	thread t1(move(task));
	cout &lt;&lt; func() &lt;&lt; endl;
	t1.join();
	cout &lt;&lt; result.get() &lt;&lt; endl;//需要get拿到a，否则会报错，类似进程中数据竞争问题
	return 0;
}
</code></pre>
<ul>
<li>
<p><font color='red'>promise</font></p>
<p>在C++中，promise是一个类模板，用于在一个线程中产生一个值，并在另一个线程中获取这个值。promise通常与future和async一起使用，用于实现异步编程。可以在主线程中拿到子线程生成的值。</p>
</li>
</ul>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;future&gt;
using namespace std;
void func(promise&lt;int&gt;&amp;f)
{
	f.set_value(100);
}
int main()
{
	promise&lt;int&gt;f;
	auto fu= f.get_future();
	thread t1(func, ref(f));
	t1.join();
	cout &lt;&lt; fu.get() &lt;&lt; endl;

	return 0;

}




</code></pre>
<h3 id="原子变量">原子变量</h3>
<h4 id="atomic">atomic：</h4>
<p>是 C++11 标准库中的一个模板类，用于实现多线程环境下的原子操作。它提供了一种线程安全的方式来访问和修改共享变量，可以避免多线程环境中的数据竞争问题。原子加锁比自己去手动加锁解锁的效率是更高的。</p>
<p>以下是一些常用的 <code>std::atomic</code> 操作：</p>
<ol>
<li>
<p><code>load()</code>：将 <code>std::atomic</code> 变量的值加载到当前线程的本地缓存中，并返回这个值。</p>
</li>
<li>
<p><code>store(val)</code>：将 <code>val</code> 的值存储到 <code>std::atomic</code> 变量中，并保证这个操作是原子性的。</p>
</li>
<li>
<p><code>exchange(val)</code>：将 <code>val</code> 的值存储到 <code>std::atomic</code> 变量中，并返回原先的值。</p>
</li>
<li>
<p><code>compare_exchange_weak(expected, val)</code> 和 <code>compare_exchange_strong(expected, val)</code>：比较 <code>std::atomic</code> 变量的值和 <code>expected</code> 的值是否相同，如果相同，则将 <code>val</code> 的值存储到 <code>std::atomic</code> 变量中，并返回 <code>true</code>；否则，将 <code>std::atomic</code> 变量的值存储到 <code>expected</code> 中，并返回 <code>false</code>。</p>
</li>
</ol>
<p>以下是那个线程池的代码：</p>
<pre><code class="language-c++">#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;mutex&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
#include&lt;condition_variable&gt;
#include&lt;functional&gt;
class ThreadPool {
public:
	ThreadPool(int numThreads ):stop (false)
	{
		for (int i = 0; i &lt; numThreads; i++)
		{
			threads.emplace_back([this]
				{
					while (1)
					{
						std::unique_lock&lt;std::mutex&gt; lock(mtx);
						condition.wait(lock, [this] {
							return stop || !tasks.empty();
							});
						if (stop &amp;&amp; tasks.empty())
						{
							return;
						}
						std::function&lt;void()&gt;task(std::move(tasks.front()));
						tasks.pop();
						lock.unlock();
						task();
					}
				});
		}

	}

	~ThreadPool()
	{
		std::unique_lock&lt;std::mutex&gt; lock(mtx);
		stop = true;
		condition.notify_all();
		for(auto &amp;t:threads)
		{
			t.join();
		}
	}
	template&lt;class F, class... Args&gt;
	void enqueau(F &amp;&amp; f,Args&amp;&amp;... args)//万能引用
	{
		std::function&lt;void()&gt;task=
			std::bind(std::forward&lt;F&gt;(f),
			std::forward&lt;Args&gt;(args)...);//完美转换
		
		{
			std::unique_lock&lt;std::mutex&gt; lock(mtx);
			tasks.emplace(std::move(task));
		}
		condition.notify_one();
	}
	
private:
	std::vector&lt;std::thread&gt; threads;
	std::queue&lt;std::function &lt;void()&gt;&gt; tasks;
	std::mutex mtx;
	std::condition_variable condition;
	bool stop;
};

int main()
{
	ThreadPool pool(2);

	for(int i=0;i&lt;4;i++)
	{ 
		pool.enqueau([i] {
			std::cout &lt;&lt; &quot;task : &quot; &lt;&lt; i &lt;&lt; &quot;is running&quot;  &lt;&lt; std::endl;
			std::this_thread::sleep_for(std::chrono::seconds(1));
			std::cout &lt;&lt; &quot;task : &quot; &lt;&lt; i &lt;&lt; &quot;is down&quot; &lt;&lt; std::endl;
			});
		
	}
	return 0;

}</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[关于Docker的一些基础普及]]></title>
        <id>https://tangyin1.github.io/post/guan-yu-docker-de-yi-xie-ji-chu-pu-ji/</id>
        <link href="https://tangyin1.github.io/post/guan-yu-docker-de-yi-xie-ji-chu-pu-ji/">
        </link>
        <updated>2023-09-16T13:05:40.000Z</updated>
        <summary type="html"><![CDATA[<p>😜😜😜最近在b站上刷到一个关于Docker的知识，然后自己又找了一下相关的资料进行补充，算是一种科普吧。😜😜😜</p>
]]></summary>
        <content type="html"><![CDATA[<p>😜😜😜最近在b站上刷到一个关于Docker的知识，然后自己又找了一下相关的资料进行补充，算是一种科普吧。😜😜😜</p>
<!-- more -->
<h1 id="1-什么是docker">1 什么是Docker</h1>
<p>docker是一个用Go语言实现的开源项目，可以让我们方便的创建和使用容器，docker将程序以及程序所有的依赖都打包到docker container，这样你的程序可以在任何环境都会有一致的表现，这里程序运行的依赖也就是容器就好比集装箱，容器所处的操作系统环境就好比货船或港口，程序的表现只和集装箱有关系(容器)，和集装箱放在哪个货船或者哪个港口(操作系统)没有关系。</p>
<p>因此我们可以看到docker可以屏蔽环境差异，也就是说，只要你的程序打包到了docker中，那么无论运行在什么环境下程序的行为都是一致的。<br>
此外docker的另一个好处就是快速部署，这是当前互联网公司最常见的一个应用场景，一个原因在于容器启动速度非常快，另一个原因在于只要确保一个容器中的程序正确运行，那么你就能确信无论在生产环境部署多少都能正确运行。</p>
<h1 id="2-docker和虚拟机的区别">2 Docker和虚拟机的区别</h1>
<p>Docker直接用的是物理机的os及物理资源、虚拟机需要加上一层hupervisor层 ，比虚拟机轻量化很多，列如你现在去下载一个centos的系统镜像，虚拟机的镜像大概需要3-4G，但docker的镜像大概只有300Mb左右，而且相比于虚拟机消耗的资源更少，可以看作一个小型的Linux的沙盒环境来使用。</p>
<h1 id="3-docker的工作原理">3、Docker的工作原理：</h1>
<p>Docker是一个开源的容器化平台，它通过利用操作系统级虚拟化技术，将应用程序以及其依赖项打包成一个独立的容器。Docker使用Linux内核中的容器技术（如像命名空间和控制组）来实现轻量级隔离，并提供了一个统一的接口和工具集，使得容器的创建、部署和管理变得简单和高效。</p>
<h1 id="4-docker镜像">4、Docker镜像：</h1>
<p>Docker镜像是Docker中的核心概念，它是一个只读的模板，包含了用于创建容器的文件系统。镜像可以包含操作系统、库、应用程序和其它依赖项。镜像是通过层（Layer）的概念构建的，每一层都是对上一层的增量修改。这种分层的结构使得镜像的构建和发布非常高效，并且可以共享和重复使用。</p>
<h1 id="5-docker容器">5、Docker容器：</h1>
<p>Docker容器是从镜像创建的运行实例。容器是独立、可移植且可隔离的，可以在任何支持Docker的环境中运行。每个容器都有自己的文件系统、网络和进程空间。容器使用镜像作为基础，启动时会在镜像的上一层创建一个可写的容器层。容器可以启动、停止、删除和暂停，使得应用程序的交付和管理非常灵活。</p>
<h1 id="6-容器创建的方式">6、容器创建的方式：</h1>
<p>在Docker中，有多种方式可以创建容器：</p>
<ul>
<li>使用Dockerfile：Dockerfile是一个文本文件，其中包含了一系列的指令，用于描述如何构建镜像。通过Dockerfile，可以自动化构建和配置镜像，并在此基础上创建容器。</li>
<li>从现有容器创建：可以基于一个已有的容器创建新的容器。这种方式是通过复制现有容器的文件系统和状态来实现的，可以在原有容器的基础上进行修改和扩展。</li>
<li>使用Docker镜像仓库：Docker镜像仓库（如Docker Hub）提供了许多已经创建好的镜像，可以直接从仓库中下载并创建容器。</li>
</ul>
<h1 id="7-容器创建命令详解">7、容器创建命令详解：</h1>
<p>要创建容器，可以使用<code>docker run</code>命令。以下是常用的参数和选项：</p>
<ul>
<li><code>-d</code>：后台运行容器。</li>
<li><code>-p</code>：将容器的端口映射到宿主机的端口。</li>
<li><code>-v</code>：将宿主机的目录挂载到容器中，实现数据共享。</li>
<li><code>--name</code>：指定容器的名称。</li>
<li><code>-e</code>：配置容器的环境变量。</li>
<li><code>--rm</code>：容器停止后自动删除。</li>
<li><code>--network</code>：指定容器所属的网络。</li>
<li><code>--link</code>：连接多个容器。</li>
<li><code>-it</code>：以交互模式启动容器。</li>
</ul>
<p>综上所述，Docker是一个强大的容器化平台，通过镜像和容器的概念，实现了应用程序的轻量级隔离和高效部署。使用Docker，开发者可以更快速地开发、交付和运行应用程序，并方便地进行扩展和管理。</p>
<h2 id="最后附上一些相关资料">最后附上一些相关资料</h2>
<p>bilibili 相关资料视频介绍：<a href="https://b23.tv/beMRblG">Docker详解，7分钟学会-哔哩哔哩</a><br>
知乎高赞文章介绍：<a href="https://zhuanlan.zhihu.com/p/187505981">什么是Dockers</a><br>
<a href="https://docs.docker.com/engine/install">docker安装官方说明</a><br>
<a href="https://hub.docker.com">dockerHub镜像仓库</a></p>
]]></content>
    </entry>
</feed>