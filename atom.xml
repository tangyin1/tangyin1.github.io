<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://tangyin1.github.io</id>
    <title>Gridea</title>
    <updated>2025-03-11T02:18:29.445Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://tangyin1.github.io"/>
    <link rel="self" href="https://tangyin1.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://tangyin1.github.io/images/avatar.png</logo>
    <icon>https://tangyin1.github.io/favicon.ico</icon>
    <rights>All rights reserved 2025, Gridea</rights>
    <entry>
        <title type="html"><![CDATA[C++八股]]></title>
        <id>https://tangyin1.github.io/post/cba-gu/</id>
        <link href="https://tangyin1.github.io/post/cba-gu/">
        </link>
        <updated>2025-03-11T01:29:10.000Z</updated>
        <summary type="html"><![CDATA[<p>常见C++八股问题，常看常新，看完这个以后还需要继续深入其他问题，列如opencv，opengl，qt等从事相关行业的具体知识。例外，还需补充相关数据结构，数据库等知识<br>
<img src="https://tangyin1.github.io/post-images/1741657230550.jfif" alt="" loading="lazy"></p>
]]></summary>
        <content type="html"><![CDATA[<p>常见C++八股问题，常看常新，看完这个以后还需要继续深入其他问题，列如opencv，opengl，qt等从事相关行业的具体知识。例外，还需补充相关数据结构，数据库等知识<br>
<img src="https://tangyin1.github.io/post-images/1741657230550.jfif" alt="" loading="lazy"></p>
<!-- more -->
<h3 id="1讲一讲封装-继承-多态是什么">1.讲一讲封装、继承、多态是什么？</h3>
<p><strong>封装</strong>：将具体实现过程和数据封装成一个类，只能通过接口进行访问，降低耦合性，使类成为一个具有内部数据的自我隐藏能力、功能独立的软件模块。意义：保护或防止代码在无意之中被破坏，保护类中的成员，不让类中以外的程序直接访问或者修改，只能通过提供的公共接口访问。</p>
<p><strong>继承</strong>：子类继承父类的特征和行为，复用了基类的<strong>全体数据</strong>和<strong>成员函数</strong>，具有从基类复制而来的<strong>数据成员</strong>和<strong>成员函数</strong>（基类私有成员可被继承，但是无法被访问），其中<strong>构造函数、析构函数、友元函数、静态数据成员、静态成员函数</strong>都不能被继承。基类中成员的访问方式只能决定派生类能否访问它们。增强了代码耦合性，当父类中的成员变量或者类本身被final关键字修饰时，修饰的类不能被继承，修饰的成员函数不能重写或修改。意义：基类的程序代码可以被派生类服用，提高了软件复用的效率，缩短了软件开发的周期</p>
<p><strong>多态</strong>：不同继承类的对象对同一消息做出不同的响应，基类的指针指向或绑定到派生类的对象，使得基类指针呈现不同的表现形式。意义：对已存在的代码具有可替代性，对代码具有可扩充性，新增子类不会影响已存在类的各种性质，在程序中体现了灵活多样的操作，提高了使用效率，简化了对应用代码的编写和修改过程。</p>
<h3 id="2多态的实现原理实现方式是什么以及多态的优点特点">2.多态的实现原理（实现方式）是什么？以及多态的优点（特点）？</h3>
<p><strong>实现方式</strong>：多态分为<strong>动态多态</strong>（动态多态是利用虚函数实现运行时的多态，即在系统编译的时候并不知道程序将要调用哪一个函数，只有在运行到这里的时候才能确定接下来会跳转到哪一个函数。）和<strong>静态多态</strong>（又称编译期多态，即在系统编译期间就可以确定程序将要执行哪个函数），其中<strong>动态多态</strong>是通过虚函数实现的，虚函数是类的成员函数，存在存储虚函数指针的表叫做<a href="https://so.csdn.net/so/search?q=%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8&amp;spm=1001.2101.3001.7020">虚函数表</a>，虚函数表是一个存储类成员虚函数的指针，每个指针都指向调用它的地方，当子类调用虚函数时，就会去虚表里面找自己对应的函数指针，从而实现“谁调用、实现谁”从而实现多态。而<strong>静态多态</strong>则是通过函数重载（函数名相同，参数不同，两个函数在同一作用域），运算符重载，和重定义（又叫隐藏，指的是在继承关系中，子类实现了一个和父类名字一样的函数，（只关注函数名，和参数与返回值无关）这样的话子类的函数就把父类的同名函数隐藏了。隐藏只与函数名有关，与参数没有关系.）来实现的。</p>
<p><strong>优点</strong>：加强代码的可扩展性，可替换性，增强程序的灵活性，提高使用效率，简化对应用代码的编写和修改过程。</p>
<h3 id="3final标识符的作用是什么">3.final标识符的作用是什么？</h3>
<p>放在类的后面表示该类无法被继承，也就是阻止了从类的继承，放在虚函数后面该虚函数无法被重写，表示阻止虚函数的重载</p>
<h3 id="4虚函数是怎么实现的它存放在哪里在内存的哪个区什么时候生成的">4.虚函数是怎么实现的？它存放在哪里在内存的哪个区？什么时候生成的</h3>
<p>在C++中，虚函数的实现原理基于两个关键概念：虚函数表和虚函数指针</p>
<p>虚函数表：每个包含虚函数的类都会生成一个虚函数表，其中存储着该类中所有虚函数的地址。虚函数表是一个由指针构成的数组，每个指针指向一个虚函数的实现代码。</p>
<p>虚函数指针：在对象的内存布局中，编译器会添加一个额外的指针，称为虚函数指针或虚表指针。这个指针指向该对象对应的虚函数表，从而让程序能够动态的调用虚函数。</p>
<p>当一个基类指针或引用调用虚函数时，编译器会使用虚表指针来查找该对象对应的虚函数表，并根据函数在虚函数表中的位置来调用正确的虚函数。</p>
<p>在编译阶段生成，虚函数和普通函数一样存放在代码段，只是它的指针又存放在了虚表之中。</p>
<h3 id="5智能指针的本质是什么它们的实现原理是什么">5.<a href="https://so.csdn.net/so/search?q=%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88&amp;spm=1001.2101.3001.7020">智能指针</a>的本质是什么，它们的实现原理是什么？</h3>
<p>智能指针本质是一个封装了一个原始C++指针的类模板，为了确保动态内存的安全性而产生的。实现原理是通过一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源。</p>
<h3 id="6匿名函数的本质是什么他的优点是什么">6.<a href="https://so.csdn.net/so/search?q=%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020">匿名函数</a>的本质是什么？他的优点是什么？</h3>
<p>匿名函数<strong>本质</strong>上是一个对象，在其定义的过程中会创建出一个栈对象，内部通过重载()符号实现函数调用的外表。</p>
<p><strong>优点</strong>：使用匿名函数，可以免去函数的声明和定义。这样匿名函数仅在调用函数的时候才会创建函数对象，而调用结束后立即释放，所以匿名函数比非匿名函数更节省空间。</p>
<h3 id="7右值引用是什么为什么要引入右值引用">7.右值引用是什么，为什么要引入右值引用？</h3>
<p><strong>右值引用是</strong>为一个临时变量取别名，它只能绑定到一个临时变量或表达式（将亡值）上。实际开发中我们可能需要对右值进行修改（实现移动语义时就需要）而右值引用可以对右值进行修改。</p>
<p><strong>为什么</strong>：</p>
<p>1.为了支持移动语义，右值引用可以绑定到临时对象、表达式等右值上，这些右值在生命周期结束后就会被销毁，因此可以在右值引用中窃取其资源，从而避免昂贵的复制操作，实现高效的移动语义。</p>
<p>2.完美转发：右值引用可以绑定到任何类型的右值上，可以将其作为参数传递给函数，并在函数内部将其“转发”到其他函数中，从而实现完美转发。</p>
<p>3.拓展可变参数模板，实现更加灵活的模板编程。</p>
<h3 id="8左值引用和指针的区别">8.左值引用和指针的区别？</h3>
<p><strong>是否初始化</strong>：指针可以不用初始化，引用必须初始化</p>
<p><strong>性质不同</strong>：指针是一个变量，引用是对被引用的对象取一个别名</p>
<p><strong>占用内存单元不同</strong>：指针有自己的空间地址，引用和被引用对象占同一个空间。</p>
<h3 id="9指针是什么">9.指针是什么？</h3>
<p>指针全名为指针变量，计算机在存储数据是有序存放的，为了能够使用存放的地址，就需要一个地址来区别每个数据的位置，指针变量就是用来存放这些地址的变量。</p>
<h3 id="10weak_ptr真的不计数是否有计数方式在哪分配的空间">10.weak_ptr真的不计数？是否有计数方式，在哪分配的空间。</h3>
<p>计数，控制块中有强弱引用计数，如果是使用make_shared初始化的函数则它所在的控制块空间是在所引用的shared_ptr中同一块的空间，若是new则控制器所分配的内存与shared_ptr本身所在的空间不在同一块内存。</p>
<h3 id="11malloc的内存分配的方式有什么缺点">11.malloc的内存分配的方式，有什么缺点？</h3>
<p>malloc并不是系统调用，而是C库中的函数，用于动态内存分配，在使用malloc分配内存的时候会有两种方式向操作系统申请堆内存</p>
<p><strong>方式1</strong>：当用户分配的内存小于128KB时通过brk()系统调用从堆分配内存，实现方式：将堆顶指针向高地址移动，获取内存空间，如果使用free释放空间，并不会将内存归还给操作系统，而是会缓存在malloc的内存池中，待下次使用</p>
<p><strong>方式2</strong>：当用户分配的内存大于128KB时通过mmap()系统调用在文件映射区域分配内存，实现方式为：使用私有匿名映射的方式，在文件映射区分配一块内存，也就是从文件映射区拿了一块内存，free释放内存的时候，会把内存归还给操作系统，内存得到真正释放</p>
<p><strong>缺点</strong>：容易造成内存泄漏和过多的内存碎片，影响系统正常运行，还得注意判断内存是否分配成功，而且内存释放后（使用free函数之后指针变量p本身保存的地址并没有改变），需要将p的赋值为NULL拴住野指针。</p>
<h3 id="111为什么不全部使用mmap来分配内存">11.1为什么不全部使用mmap来分配内存？</h3>
<p>因为向操作系统申请内存的时候，是要通过系统调用的，执行系统调用要进入内核态，然后再回到用户态，状态的切换会耗费不少时间，所以申请内存的操作应该避免频繁的系统调用，如果都使用mmap来分配内存，等于每次都要执行系统调用。另外，因为mmap分配的内存每次释放的时候都会归还给操作系统，于是每次mmap分配的虚拟地址都是缺页状态，然后在第一次访问该虚拟地址的时候就会触发缺页中断。</p>
<h3 id="112为什么不全部都用brk">11.2为什么不全部都用brk</h3>
<p>如果全部使用brk申请内存那么随着程序频繁的调用malloc和free，尤其是小块内存，堆内将产生越来越多的不可用的内存碎片。</p>
<h3 id="12传入一个指针它如何确定具体要清理多少空间呢">12.传入一个指针，它如何确定具体要清理多少空间呢？</h3>
<p>我们在申请内存的时候，会多分配16字节的内存，里面保存了内存块的详细信息，free会对传入的内存地址向左偏移16字节，然后分析出当前内存块的大小，就知道要释放多大的内存空间了。</p>
<h3 id="13define和const的区别是什么">13.define和const的区别是什么？</h3>
<p><strong>编译阶段</strong>：define是在编译预处理阶段进行简单的文本替换，const是在编译阶段确定其值</p>
<p><strong>安全性</strong>：define定义的宏常量没有数据类型，只是进行简单的替换，不会进行类型安全检查；const定义的常量是有类型的，是要进行类型判断的</p>
<p><strong>内存占用</strong>：define定义的宏常量，在程序中使用多少次就会进行多少次替换，内存中有多个备份，占用的是代码段的内存；const定义常量占用静态存储区域的空间，程序运行过程中只有一份</p>
<p><strong>调试</strong>：define定义的宏常量不能调试，因为在预编译阶段就已经进行替换了；const定义的常量是可以进行调试的。</p>
<h3 id="14程序运行的步骤是什么">14.程序运行的步骤是什么</h3>
<p><strong>预编译</strong>：将头文件编译，进行宏替换，输出.i文件</p>
<p><strong>编译</strong>：将其转化为汇编语言文件，主要做词法分析，语义分析以及检查错误，检查无误后将代码翻译成汇编语言，生成.s文件</p>
<p><strong>汇编</strong>：汇编器将汇编语言文件翻译成机器语言，生成.o文件</p>
<p><strong>链接</strong>：将目标文件和库链接到一起，生成可执行文件.exe</p>
<h3 id="15锁的底层原理是什么">15.锁的底层原理是什么？</h3>
<p>锁的底层是通过CAS，atomic 机制实现。</p>
<p><strong>CAS****机制</strong>：全称为Compare And Swap（比较相同再交换）可以将比较和交换操作转换为原子操作，CAS操作依赖于三个值：内存中的值V，旧的预估值X，要修改的新值B，如果旧的预估值X等于内存中的值V，就将新的值B保存在内存之中。（就是每一个线程从主内存复制一个变量副本后，进行操作，然后对其进行修改，修改完后，再刷新回主内存前。再取一次主内存的值，看拿到的主内存的新值与当初保存的快照值，是否一样，如果不一样，说明有其他线程修改，本次修改放弃，重试。）</p>
<p><strong>atomic****机制</strong>：如16问。</p>
<h3 id="16原子操作是什么">16.原子操作是什么？</h3>
<p>原子操作是指不会被线程调度机制打断的操作，这种操作一旦开始，就一直运行到结束，中间不会有任何切换到另一个线程。</p>
<p><strong>原理是</strong>：在X86的平台下，CPU提供了在指令执行期间对总线加锁的手段，CPU中有一根引线#HLOCK pin连接到北桥，如果汇编语言的程序在程序中的一条指令前面加上了前缀“LOCK”，经过汇编之后的机器码就使CPU在执行这条指令的时候把#HLOCKpin的电平拉低持续到这条指令结束的时候放开，从而把总线锁住，这样别的CPU就暂时不能够通过总线访问内存了，保证了多处理器环境中的原子性。</p>
<h3 id="17class与struct的区别">17.class与struct的区别</h3>
<p>默认继承权限不同：class默认继承的是private继承，struct默认是public继承。</p>
<p>Class还可用于定义模板参数，但是关键字struct不能同于定义模板参数，C++保留struct关键字，原因是保证与C语言的向下兼容性，为了保证百分百的与C语言中的struct向下兼容，，C++把最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性的限制。</p>
<h3 id="18内存对齐是什么为什么要进行内存对齐内存对齐有什么好处">18.内存对齐是什么？为什么要进行内存对齐？内存对齐有什么好处？</h3>
<p>内存对齐是处理器为了提高处理性能而对存取数据的起始地址所提出的一种要求。</p>
<p>有些CPU可以访问任意地址上的任意数据，而有些CPU只能在特定的地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时将进行对齐，这就具有平台的移植性。CPU每次寻址有时需要消耗时间的，并且CPU访问内存的时候并不是逐个字节访问，而是以字长为单位访问，所以数据结构应该尽可能地在自然边界上对齐，如果访问未对齐内存，处理器需要做多次内存访问，而对齐的内存访问可以减少访问次数，提升性能。</p>
<p><strong>优</strong>：提高程序的运行效率，增强程序的可移植性。</p>
<h3 id="19进程之间的通信方式有哪些">19.进程之间的通信方式有哪些？</h3>
<p><strong>管道</strong>：管道分为匿名管道和命名管道，管道本质上是一个内核中的一个缓存，当进程创建管道后会返回两个文件描述符，一个写入端一个输出端。缺点：半双工通信，一个管道只能一个进程写，一个进程读。不适合进程间频繁的交换数据</p>
<p><strong>消息队列</strong>：可以边发边收，但是每个消息体都有最大长度限制，队列所包含的消息体的总数量也有上限并且在通信过程中存在用户态和内核态之间的数据拷贝问题</p>
<p><strong>共享内存</strong>：解决了消息队列存在的内核态和用户态之间的数据拷贝问题。</p>
<p><strong>信号量</strong>：本质上是一个计数器，当使用共享内存的通信方式时，如果有多个进程同时往共享内存中写入数据，有可能先写的进程的内容被其他进程覆盖了，信号量就用于实现进程间的互斥和同步PV操作不限于信号量+-1，而且可以任意加减正整数</p>
<p><strong>信号</strong></p>
<p><strong>套接字</strong></p>
<h3 id="20线程之间的通信方式有哪些">20.线程之间的通信方式有哪些？</h3>
<p>信号量</p>
<p>条件变量</p>
<p>互斥量</p>
<h3 id="21介绍一下socket中的多路复用及其他们的优缺点epoll的水平和边缘触发模式">21.介绍一下socket中的多路复用，及其他们的优缺点，epoll的水平和边缘触发模式</h3>
<p>select、poll、epoll都是IO多路复用的一种机制，可以监视多个文件描述符，一旦某个文件描述符进入读或写就绪状态，就能够通知系统进行相应的读写操作。</p>
<p><strong>Select优点</strong>：可移植性好，因为在某些Unix系统中并不支持poll和epoll</p>
<p>对于超时时间提供了更好的精度：微妙，而poll和epoll都是毫秒级</p>
<p><strong>Select缺点</strong>：支持监听的文件描述符fd的数量有限制，最大数量默认是1024个</p>
<p>Select需要维护一个用来存放文件描述符的数据结构，每次调用select都需要把fd集合从用户区拷贝到内核区，而select系统调用后有需要把fd集合从内核区拷贝到用户区，这个系统开销在fd数量很多的时候会很大。</p>
<p><strong>Poll优点（相对于select而言）</strong>：没有最大文件描述符数量的限制，poll基于链表存储主要解决了这个最大文件描述符数量的限制（当然，他还是有限制的，上限为操作系统能支持的能开启的最大文件描述符数量），优化了编程接口，减少了函数调用参数，并且，每次调用select函数时，都必须重置该函数的三个fd_set类型的参数值，而poll不需要重置。</p>
<p><strong>Poll缺点</strong>：poll和select一样同样都需要维护一个用来存放文件描述符的数据结构，当注册的文件描述符无限多时，会使得用户态和内核区之间传递该数据结构的复制开销很大。每次poll系统调用时，需要把文件描述符fd从用户态拷贝到内核区，然后poll系统调用返回前，又需要把文件描述符fd集合从内核区拷贝到用户区，这个内存拷贝的系统开销在fd数量很多的时候会很大。</p>
<p><strong>Epoll优点</strong>：和poll一样没有最大文件描述符数量的限制，epoll虽然也需要维护用来存放文件描述符的数据结构（epoll_event），但是它只需要将该数据结构拷贝一次，不需要重复拷贝，并且它只在调用epoll_ctl系统调用时拷贝一次要监听的文件描述符数据结构到内核区，在调用epoll_wait的时候不需要再把所有的要监听的文件描述符重复拷贝进内核区，这就解决了select和poll种内存复制开销的问题。</p>
<p><strong>Epoll缺点</strong>：目前只有Linux操作系统支持epoll，不支持跨平台使用，而Unix操作系统上是使用kqueue</p>
<p><strong>Epoll水平触发（LT）</strong>：对于读操作，只要缓冲区内容不为空，LT模式返回读就绪。</p>
<p>对于写操作，只要缓冲区还不满，LT模式会返回写就绪。</p>
<p><strong>Epoll边缘触发（ET）</strong>：对于读操作，当缓冲区由不可读变为可读的时候，有新数据到达时，进程修改了EPOLL_CTL_MOD修改EPOLLIN事件时</p>
<p>在ET模式下，缓冲区从不可读变成可读，会唤醒应用进程，缓冲区数据变少的情况，则不会再唤醒应用进程。</p>
<p>当被监控的文件描述符上有可读写事件发生时，epoll_wait()会通知处理程序去读写。如果这次没有把数据全部读写完(如读写缓冲区太小)，那么下次调用epoll_wait()时，它不会通知你，也就是它只会通知你一次，直到该文件描述符上出现第二次可读写事件才会通知你。通常配合将文件描述符设置为非阻塞状态一起使用，这种模式比水平触发效率高，系统不会充斥大量你不关心的就绪文件描述符。</p>
<h3 id="24类的生命周期">24.类的生命周期</h3>
<p>类从被加载到内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。其中验证，准备，解析三个部分统称为连接</p>
<p>全局对象在main开始前被创建，main退出后被销毁。</p>
<p>静态对象在第一次进行作用域时被创建，在main退出后被销毁。</p>
<p>局部对象在进入作用域时被创建，在退出作用域时被销毁。</p>
<p>New创建的对象直到内存被释放的时候都存在。</p>
<h3 id="25父类的构造函数和析构函数是否能为虚函数这样操作导致的结果">25.父类的构造函数和析构函数是否能为虚函数？这样操作导致的结果？</h3>
<p>构造函数不能为虚函数，虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的vptr指针指向，该指针存放在对象的内部空间之中，需要调用构造函数完成初始化，如果构造函数为虚函数，那么调用构造函数就需要去寻找vptr，但此时vptr还没有完成初始化，导致无法构造对象。</p>
<p>析构函数可以且经常为虚函数：当我们使用父类指针指向子类时，只会调用父类的析构函数，子类的析构函数不会被调用，容易造成内存泄漏。</p>
<h3 id="26多线程为什么会发生死锁死锁是什么死锁产生的条件如何解决死锁">26.多线程为什么会发生死锁，死锁是什么？死锁产生的条件，如何解决死锁？</h3>
<p>因为在多进程中易发生多进程对资源进行竞争，如果一个进程集合里面的每一个进程都在等待这个集合中的其他一个进程才能继续往下执行，若无外力他们将无法推进，这种情况就是死锁。产生死锁的四个条件：互斥条件、请求和保持条件、不可剥夺条件、环路等待条件。解决死锁的方法就是破坏上述任意一种条件。</p>
<h3 id="27描述一下面向过程和面向对象">27.描述一下面向过程和面向对象</h3>
<p><strong>面向对象</strong>：就是将问题分解为各个对象，建立对象的目的不是为了完成一个步骤，而是为了描述某个事物在整个解决问题的步骤中的行为，相比面向过程，代码更易维护和复用。但是代码效率相对较低。</p>
<p><strong>面向过程</strong>：就是将问题分析出解决问题的步骤，然后将这些步骤一步一步的实现，使用的时候一个一个调用就好。代码效率更高但是代码复用率低，不易维护。</p>
<h3 id="28c中左值和右值是什么i是左值还是右值i和i哪个效率更高">28.C++中左值和右值是什么？++i是左值还是右值，++i和i++哪个效率更高？</h3>
<p>第一小问结合本文第七和第八问，++i是左值，因为++i返回的是一个左值没有发生拷贝，所以效率更高。（++i是左值，i++是右值。因为++i返回i本身，而i++返回i的值。）</p>
<h3 id="29介绍一下vector-list的底层实现原理和优缺点">29.介绍一下vector、list的底层实现原理和优缺点</h3>
<p><strong>Vector优点</strong>：可使用下标随机访问，尾插尾删效率高。</p>
<p><strong>缺点</strong>：前面部分的插入删除效率低，扩容有消耗，可能存在一定的空间浪费。</p>
<p><strong>底层</strong>是由一块连续的内存空间组成，由三个指针实现的分别是头指针（表示目前使用空间的头），尾指针（表示目前使用空间的尾）和可用空间尾指针实现</p>
<p><strong>List优点</strong>：按需申请内存，不需要扩容，不会造成内存空间浪费。在任意位置的插入删除下效率高。</p>
<p><strong>缺点</strong>：不支持下标随机访问</p>
<p><strong>底层</strong>是由双向链表实现的</p>
<h3 id="30静态变量在哪里初始化在哪一个阶段初始化都存放在全局区域">30.静态变量在哪里初始化？在哪一个阶段初始化？（都存放在全局区域）</h3>
<p>静态变量，全局变量，常量都在编译阶段完成初始化和内存分配。其他变量都是在编译阶段进行初始化，运行阶段内存分配.。</p>
<h3 id="31如何实现多进程">31.如何实现多进程？</h3>
<p>在Linux中C++使用fork函数来创建进程</p>
<p>而windows中C++使用createprocess来创建进程</p>
<h3 id="32空对象指针为什么能调用函数">32.空对象指针为什么能调用函数？</h3>
<p>在类的初始化的时候，编译器会将它的函数分配到类的外部，这也包括静态成员函数，这样做主要是为了节省内存，如果我们在调用类中的的成员函数时没有使用类中的任何成员变量，它不会使用到this指针所以可以正常调用这个函数。</p>
<h3 id="33shared_ptr线程安全吗">33.shared_ptr线程安全吗？</h3>
<p>智能指针中的引用计数是线程安全的，但是智能指针所指向的对象的线程安全问题，智能指针没有做任何保障线程不安全。也就是说它所管理的资源可以线程安全的释放，只保证线程安全的管理资源的生命期，不保证其资源可以线程安全地被访问。</p>
<h3 id="34push_back左值和右值的区别是什么">34.push_back()左值和右值的区别是什么？</h3>
<p>如果push_back（）的参数是左值，则使用它拷贝构造新对象，如果是右值，则使用它移动构造新对象.。</p>
<h3 id="35move底层是怎么实现的">35.move底层是怎么实现的？</h3>
<p>Move的功能是将一个左值引用强制转化为右值引用，继而可以通过右值引用使用该值，以用于移动语义，从实现原理上讲基本等同一个强制类型转换。</p>
<p>优点：可以将左值变成右值而避免拷贝构造，将对象的状态所有权从一个对象转移到另一个对象，只是转移，没有内存搬迁或者内存拷贝。</p>
<h3 id="36完美转发的原理是什么">36.完美转发的原理是什么？</h3>
<p>完美转发是指函数模板可以将自己的参数完美的转发给内部调用的其他函数，完美是指不仅能够准确的转发参数的值，还能保证被转发参数的左、右值属性不变，使用引用折叠的规则，将传递进来的左值以左值传递出来，将传递进来的右值以右值的方式传出。</p>
<h3 id="37空类中有什么函数">37.空类中有什么函数？</h3>
<p>默认构造函数、默认拷贝构造函数、默认析构函数、默认赋值运算符</p>
<p>取值运算符、const取值运算符</p>
<h3 id="38explicit用在哪里有什么作用">38.explicit用在哪里？有什么作用？</h3>
<p>只能用于修饰只有一个参数的类构造函数（有一个例外就是，当除了第一个参数以外的其他参数都有默认值的时候此关键字依然有效），它的作用是表明该构造函数是显示的，而非隐式的，跟它对应的另一个关键字是implicit，意思是隐藏的，类构造函数默认情况下声明为implicit。作用是防止类构造函数的隐式自动转换。</p>
<h3 id="39成员变量初始化的顺序是什么">39.成员变量初始化的顺序是什么？</h3>
<p>成员变量在使用初始化列表初始化时，与构造函数中初始化成员列表的顺序无关，只与定义成员变量的顺序有关。如果不使用初始化列表初始化，在构造函数内初始化时，此时与成员变量在构造函数中的位置有关。类中const成员常量必须在构造函数初始化列表中初始化。类中static成员变量，只能在类外初始化。</p>
<p><strong>顺序</strong>：基类的静态变量或全局变量，派生类的静态变量或者全局变量，基类的成员变量，派生类的成员变量。</p>
<h3 id="40指针占用的大小是多少">40.指针占用的大小是多少？</h3>
<p>64位电脑上占8字节，32位的占4字节，我们平时所说的计算机多少位是指计算机CPU中通用寄存器一次性处理、传输、暂时保存的信息的最大长度。即CPU在单位时间内能一次处理的二进制的位数，因此CPU所能访问的内存所有地址由多少位组成，而8比特位表示1字节，就可以得出在不同位数的机器中指针的大小。</p>
<h3 id="41野指针和内存泄漏是什么如何避免">41.野指针和内存泄漏是什么？如何避免？</h3>
<p><strong>内存泄漏</strong>：是指程序中以动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果</p>
<p>避免：使用智能指针管理资源，在释放对象数组时使用delete[]，尽量避免在堆上分配内存</p>
<p><strong>野指针</strong>：指向一个已删除的对象或未申请访问受限内存区域的指针。</p>
<p>避免：对指针进行初始化，用已合法的可访问内存地址对指针初始化，指针用完释放内存，将指针赋值nullptr。</p>
<h3 id="42malloc和new的区别是什么">42.malloc和new的区别是什么？</h3>
<p>Malloc/free是标准库函数，new/delete是C++运算符</p>
<p>Malloc分配内存失败返回空，new失败抛异常</p>
<p>New/delete会调用构造析构函数，malloc/free不会，所以他们无法满足动态对象的要求。</p>
<p>New返回有类型的指针，malloc返回无类型的指针</p>
<p>分配内存的位置：malloc从堆上动态分配内存，new是从自由存储区为对象动态分配内存（取决于operator new的实现，可以为堆还可以是静态存储区）</p>
<p>New申请内存的步骤：调用operator new函数，分配一块足够大，且原始的，未命名的内存空间来存储特定类型的对象。运行相应的构造函数来构造对象，并为其传入初值，返回一个指向该对象的指针。</p>
<p>Delete：先调用对象的析构函数，再调用operator delete函数释放内存空间</p>
<h3 id="43多线程会发生什么问题线程同步有哪些手段">43.多线程会发生什么问题？线程同步有哪些手段？</h3>
<p>会引发资源竞争的问题，频繁上锁会导致程序运行效率低下，甚至会导致发生死锁。</p>
<p><strong>线程同步手段</strong>：使用atomic原子变量，使用互斥量也就是上锁，使用条件变量或信号量制约对共享资源的并发访问。</p>
<h3 id="44什么是stl">44.什么是STL？</h3>
<p>它是C++标准库的重要组成部分，不仅是一个可复用的组件库也是一个包含了数据结构与算法的软件架构，它拥有六大组件分别是：仿函数，算法，迭代器，空间配置器，容器，配接器</p>
<h3 id="45对比迭代器和指针的区别">45.对比迭代器和指针的区别</h3>
<p>迭代器不是指针，是一个模板类，通过重载了指针的一些操作符模拟了指针的一些功能，迭代器返回的是对象引用而不是对象的值。</p>
<p>指针能够指向函数而迭代器不行迭代器只能指向容器</p>
<h3 id="46线程有哪些状态线程锁有哪些">46.线程有哪些状态，线程锁有哪些？</h3>
<p><strong>五种状态</strong>：创建，就绪，运行，阻塞，死亡</p>
<p><strong>线程锁的种类</strong>：互斥锁，条件锁，自旋锁，读写锁，递归锁</p>
<h3 id="47解释说明一下map和unordered_map">47.解释说明一下map和unordered_map</h3>
<p>Map内部实现是一个红黑树，内部所有的元素都是有序的，而hashmap则是内部实现了一个哈希表，内部存储元素是无序的</p>
<p><strong>Map优点</strong>：有序性，其次是内部实现的是一个红黑树，使得很多操作都可以在logn的复杂度下可以实现效率较高。</p>
<p><strong>Map缺点</strong>：空间占用率高</p>
<p><strong>Unorderedmap优点</strong>：查找效率非常高。缺点：哈希表的建立比较费时间</p>
<h3 id="48vector中的push_back和emplace_back的区别-以及使用场景">48.vector中的push_back()和emplace_back()的区别、以及使用场景</h3>
<p>当使用Push_back时会先调用类的有参构造函数创建一个临时变量，再将这个元素拷贝或者移动到容器之中，而emplace_back则是直接在容器尾部进行构造比push_back少进行一次构造函数调用。在大部分场景中emplace_back可以替换push_back，但是push_back会比emplace_back更加安全，emplace_back只能用于直接在容器中构造新元素的情况，如果要将现有的对象添加到容器中则需要使用push_back</p>
<h3 id="49如何实现线程安全除了加锁还有没有其他的方式">49.如何实现线程安全，除了加锁还有没有其他的方式？</h3>
<p>除了锁之外还可以使用互斥量（防止多个线程来同时访问共享资源，从而避免数据竞争的问题），原子操作（原子操作是不可分割的，使用原子操作可以确保在多线程环境中操作是安全的），条件变量（协调线程之间的协作，用来在线程之间传递信号，从而控制线程的执行流程）等方式</p>
<h3 id="50vector扩容resize和reserve的区别">50.vector扩容，resize和reserve的区别</h3>
<p>使用resize改变的是vector的大小（size），可能会添加或删除元素。<br>
使用reserve改变的是vector的容量（capacity），不会改变当前元素的数量，仅仅是为了优化内存使用和性能。</p>
<h3 id="51vector扩容为了避免重复扩容做了哪些机制">51.vector扩容为了避免重复扩容做了哪些机制？</h3>
<p>当vector内存不够时本身内存会以1.5或者2倍的增长，以减少扩容次数</p>
<p>引入了reserve，自定义vector最大容量</p>
<h3 id="52c中空类的大小是多少">52.C++中空类的大小是多少？</h3>
<p>1字节</p>
<h3 id="53weak_ptr是怎么实现的">53.weak_ptr是怎么实现的？</h3>
<p>实现依赖于计数器和寄存器实现的，计数器用来记录弱引用的数量，寄存器用来存储shared_ptr</p>
<h3 id="54虚函数的底层原理是什么">54.虚函数的底层原理是什么？</h3>
<p>虚函数表和虚表指针，详细看本文第四问。</p>
<h3 id="55一个函数fint-aint-b其中a和b的地址关系是什么">55.一个函数f(int a,int b)，其中a和b的地址关系是什么？</h3>
<p>a和b的地址是相邻的。</p>
<h3 id="56移动构造和拷贝构造的区别是什么">56.移动构造和拷贝构造的区别是什么？</h3>
<p>移动构造函数本质上是基于指针的拷贝，实现对堆区内存所有权的移交，在一些特定场景下，可以减少不必要的拷贝。比如用一个临时对象或者右值对象初始化类实例时。我们可以使用move()函数，将一个左值对象转变为右值对象。而拷贝构造则是将传入的对象复制一份然后放进新的内存中</p>
<h3 id="57lamda表达式捕获列表捕获的方式有哪些如果是引用捕获要注意什么">57.lamda表达式捕获列表捕获的方式有哪些？如果是引用捕获要注意什么？</h3>
<p>按值捕获和引用捕获，默认的引用捕获可能会导致悬挂引用，引用捕获会导致闭包包含一个局部变量的引用或者形参的引用，如果一个由lambda创建的闭包的生命周期超过了局部变量或者形参的生命期，那么闭包的引用将会空悬。解决方法是对个别参数使用值捕获</p>
<h3 id="58哈希碰撞的处理方法">58.哈希碰撞的处理方法</h3>
<p><strong>开放定址法</strong>：当遇到哈希冲突时，去寻找一个新的空闲的哈希地址。</p>
<p><strong>再哈希法</strong>：同时构造多个哈希函数，等发生哈希冲突时就使用其他哈希函数知道不发生冲突为止，虽然不易发生聚集，但是增加了计算时间</p>
<p><strong>链地址法</strong>：将所有的哈希地址相同的记录都链接在同一链表中</p>
<p><strong>建立公共溢出区</strong>：将哈希表分为基本表和溢出表，将发生冲突的都存放在溢出表中</p>
<h3 id="59unordered_map的扩容过程">59.unordered_map的扩容过程</h3>
<p>当unordered_map中的元素数量达到桶的负载因子（0.75）时，会重新分配桶的数量（通常会按照原有桶的数量*2的方式进行扩容，但是具体的增长策略也可以通过修改容器中的max_load_factor成员变量来进行调整），并将所有的元素重新哈希到新的桶中。</p>
<h3 id="60vector如何判断应该扩容size和capacity">60.vector如何判断应该扩容？（size和capacity）</h3>
<p>由当前容器内元素数量的大小和容器最大大小进行比较如果二者相等就会进行扩容，一般是1.5倍，部分的有两倍</p>
<h3 id="61构造函数是否能声明为虚函数为什么什么情况下为错误">61.构造函数是否能声明为虚函数？为什么？什么情况下为错误？</h3>
<p>构造函数不能为虚函数，虚函数的调用是通过虚函数表来查找的，而虚函数表由类的实例化对象的vptr指针指向，该指针存放在对象的内部空间之中，需要调用构造函数完成初始化，如果构造函数为虚函数，那么调用构造函数就需要去寻找vptr，但此时vptr还没有完成初始化，导致无法构造对象。</p>
<h3 id="62类中static函数是否能声明为虚函数">62.类中static函数是否能声明为虚函数？</h3>
<p>不能，因为类中的static函数是所有类实例化对象所共有的，没有this指针，而虚函数依靠vptr和vtable来处理，vptr是一个指针，在类中的构造函数中生成，并且只能通过this指针访问，对于静态成员函数来说，他没有this指针，无法访问vptr，因此static函数无法声明为虚函数</p>
<h3 id="63哪些函数不能被声明为虚函数">63.哪些函数不能被声明为虚函数？</h3>
<p>构造函数，内联函数（内联函数有实体，在编译时展开，没有this指针），静态成员函数，友元函数（C++不支持友元函数的继承），非类成员函数</p>
<h3 id="64如何保证类的对象只能被开辟在堆上将构造函数声明为私有-单例">64.如何保证类的对象只能被开辟在堆上？（将构造函数声明为私有、单例）</h3>
<p>将构造函数设置为私有，这样只能使用new运算符来建立对象，但是我们必须准备一个destory函数来进行内存的释放，然后将析构函数设置为protected，提供一个public的static函数来完成构造，类似于单例模式</p>
<p>如果在栈上分配呢？则是重载new操作符，使得new操作符的功能为空，这样就使得外层程序无法在堆上分配对象，只可以在栈上分配</p>
<h3 id="65讲讲你理解的虚基类">65.讲讲你理解的虚基类</h3>
<p>虚基类是 C++ 中一种特殊的类，用于解决多继承所带来的“菱形继承”问题。如果一个派生类同时从两个基类派生，而这两个基类又共同继承自同一个虚基类，就会形成一个“菱形”继承结构，导致派生类中存在两份共同继承的虚基类的实例，从而引发一系列的问题。</p>
<p>为了解决这个问题，我们可以将虚基类作为共同基类，并在派生类中采用虚继承的方式。</p>
<p>虚继承会使得派生类中只存在一份共同继承的虚基类的实例，从而避免了多个实例之间的冲突。</p>
<p>虚基类是可以被实例化的。</p>
<h3 id="66c哪些运算符不能被重载">66.C++哪些运算符不能被重载？</h3>
<p>成员访问操作符，域解析操作符，条件运算符之类的不能重载。其中并不推荐对逗号运算符，逻辑或逻辑与之类运算符进行重载，容易造成歧义。</p>
<h3 id="67动态链接和静态链接的区别动态链接的原理是什么">67.动态链接和静态链接的区别，动态链接的原理是什么？</h3>
<p><strong>区别</strong>：他们的最大区别就是在于链接的时机不同，静态链接是在形成可执行程序前，而动态链接的进行则是程序执行时。</p>
<p><strong>静态库</strong>：就是将库中的代码包含到自己的程序之中，每个程序链接静态库后，都会包含一份独立的代码，当程序运行起来时，所有这些重复的代码都需要占用独立的存储空间，显然很浪费计算机资源。</p>
<p><strong>动态库</strong>：不会将代码直接复制到自己程序中，只会留下调用接口，程序运行时再去将动态库加载到内存中，所有程序只会共享这一份动态库，因此动态库也被称为共享库。</p>
<p><strong>动态链接原理</strong>：是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件</p>
<h3 id="68c中怎么编译c语言代码">68.C++中怎么编译C语言代码？</h3>
<p>使用extern“C”让C++代码按照C语言的方式去编译</p>
<h3 id="69未初始化的全局变量和初始化的全局变量放在哪里">69.未初始化的全局变量和初始化的全局变量放在哪里？</h3>
<p>初始化的全局变量存放在数据段，数据段数据静态分配。</p>
<p>未初始化的全局变量存放在BSS（Block Started By Symbol）段,属于静态内存分配</p>
<h3 id="70说一下内联函数及其优缺点">70.说一下内联函数及其优缺点</h3>
<p>内联函数是在编译期将函数体内嵌到程序之中，以此来节省函数调用的开销。</p>
<p>**优点：**是节省了函数调用的开销，让程序运行更加快速。</p>
<p>**缺点：**是如果函数体过长，频繁使用内联函数会导致代码编译膨胀问题。不能递归执行</p>
<h3 id="71c11中的auto是怎么实现自动识别类型的模板是怎样实现转化成不同类型的">71.C++11中的auto是怎么实现自动识别类型的？模板是怎样实现转化成不同类型的？</h3>
<p>auto仅仅只是一个占位符，在编译期间它会被真正的类型替代，或者说C++中变量必须要有明确类型的，只是这个类型是由编译器自己推导出来的。函数模板是一个蓝图，它本身并不是函数，是编译器用使用方式具体类型函数的模具，所以模板其实就是将原本应该我们做重复的事情交给了编译器。</p>
<h3 id="72map和set的区别和底层实现是什么map取值的-findat方法的区别at有越界检查功能">72.map和set的区别和底层实现是什么？map取值的 find，[]，at方法的区别(at有越界检查功能)</h3>
<p>都是红黑树，find查找需要判断返回的结果才知道有没有查询成功。[]不管有没有就是0，如果原先不存在该key，则插入，如果存在则覆盖插入，at方法则会进行越界检查，这会损失性能，如果存在则返回它的值，如果不存在则抛出异常。</p>
<h3 id="73详细说一说fcntl的作用">73.详细说一说fcntl的作用</h3>
<p><strong>作用</strong>：用于控制打开的文件描述符的一些属性和行为。</p>
<p><strong>有五个功能</strong>：</p>
<p>1.复制一个现有的描述符(cmd=F_DUPFD)</p>
<p>2.获得/设置文件描述符标记（cmd=F_GETFD或F_SETFD）</p>
<p>3.获取/设置文件状态标记（cmd=F_GETFL或F_SETFL）</p>
<p>4.获取设置异步IO所有权（cmd=F_GETOWN或F_SETFL）</p>
<p>5.获取设置记录锁（cmd=F_GETLK或F_SET）</p>
<h3 id="74c的面向对象主要体现在那些方面">74.C++的面向对象主要体现在那些方面？</h3>
<p>体现在C++引入了面向对象的一些特征，例如加入了封装继承多态的特点。（然后介绍一下封装继承多态）</p>
<h3 id="75介绍一下extern-c关键字为什么会有这个关键字">75.介绍一下extern C关键字，为什么会有这个关键字？</h3>
<p>是用来实现在C++代码段中用C语言的方式来编译代码，是C++为了兼容C语言所加入的关键字</p>
<h3 id="76讲一讲迭代器失效及其解决方法">76.讲一讲迭代器失效及其解决方法</h3>
<p><strong>序列式容器迭代器失效</strong>：当当前元素的迭代器被删除后，后面所有元素的迭代器都会失效，他们都是一块连续存储的空间，所以当使用erase函数操作时，其后的每一个元素都会向前移动一个位置，此时可以使用erase函数操作可以返回下一个有效的迭代器。</p>
<p><strong>Vector迭代器失效问题总结</strong>：1.当执行了erase方法时，指向删除节点的迭代器全部失效，指向删除节点之后的全部迭代器也失效。</p>
<p>2.当进行push_back方法时，end操作返回的迭代器肯定失效。</p>
<p>3.当插入一个元素后，capacity返回值与没有插入元素之前相比有改变，则需要重新加载整个容器，此时first和end操作返回的迭代器失效。</p>
<p>4.当插入一个元素后，如果空间未重新分配，指向插入位置之前的元素的迭代器依然有效，但指向插入元素之后元素的迭代器全部失效。</p>
<p><strong>Deque迭代器失效总结</strong>：1.对于deque，插入到除首尾位置之外的任何位置都会导致迭代器、指针和引用都会失效，如果在首尾位置添加元素，迭代器会失效，但是指针和引用不会失效。</p>
<p>2.如果在首尾之外的任何位置删除元素，那么指向被删除元素外其他元素的迭代器都会失效。3.如果在其首部和尾部删除元素则只会使指向被删除元素的迭代器失效。</p>
<p><strong>关联型容器迭代器失效</strong>：删除当前的迭代器，仅仅会使当前的迭代器失效，只要erase时，递增当前迭代器即可。</p>
<h3 id="77编译器是如何实现重载的">77.编译器是如何实现重载的？</h3>
<p>在编译时，编译器如果遇到了函数，就会在符号表里面命名一个符号来存放函数的地址，如果函数的使用在定义之前编译，无法在符号表中找到对应函数地址，则先标记为“？”（暂时未知），在全部编译结束后的链接过程将“？”在符号表里找到并替代为相应的函数地址，如果函数的定义在使用之前编译，则可以直接在符号表里找到对应函数地址直接使用，而在C语言中的符号表是以函数名为符号来存储函数地址，函数名相同的重载函数的地址应该不同，于是符号表中存在两个同符号的函数地址，在查找使用时会存在歧义和冲突。而C++符号表中的符号不是以函数名命名的，称为函数名修饰规则，虽然函数名相同，但是函数参数等其他属性不同，取的符号也不同，所以不会产生查询歧义的问题，使得函数可以重载。</p>
<h3 id="78什么是函数调用约定">78.什么是函数调用约定？</h3>
<p>函数调用约定就是对函数调用的一个约束和规定，描述了函数参数是怎么传递和由谁清除堆栈的。它决定了，函数参数传递的方式（是否采用寄存器传递参数，采用哪个寄存器传递参数，参数压栈的顺序等），函数调用结束后栈指针由谁恢复（被调用的函数恢复还是调用者恢复），函数修饰名的产生方法。</p>
<p><strong>__stdcall</strong>：是standardcall的缩写，是C++的标准调用方式，规则如下：所有参数从右到左依次入栈，如果是调用类成员的话，最后一个入栈的是this指针。被调用函数自动清理堆栈，返回值在EAX。函数修饰名约定：VC将函数编译后会在函数名前面加上下划线前缀，在函数名后加上“@”和参数的字节数。</p>
<p><strong>__cdecl</strong>：是C DECLaration的缩写（declaration，声明），表示C语言的默认函数调用方法，规定如下：所有参数从右往左依次入栈，所有参数由调用者清除，称为手动清栈。返回值在EAX中。函数修饰名约定：VC将函数编译后会在函数名前面加上下划线前缀，由于由调用者清理栈，所以允许可变参数函数存在。</p>
<p><strong>__fastcall</strong>：是快速调用约定，通过寄存器来传送参数，规则如下：用ECX和EDX传送前两个双字（DWORD）或更小的参数，剩下的参数仍然自右向左压栈传送。被调用函数在返回前清理传送参数的内存栈，返回值在EAX中。函数修饰名约定：VC将函数编译后会在函数名前面加上“@”前缀，在函数名后加上“@”和参数的字节数。</p>
<p><strong>__thiscall</strong>：是唯一一个不能明确指明的函数修饰符，thiscall只能用于处理C++类成员函数的调用，同时thiscall也是C++成员函数缺省的调用约定，由于成员函数调用还有一个this指针，因此必须特殊处理，规定如下：采用栈传递参数，参数从右向左入栈，如果参数个数确定，this指针通过TCX传递给被调用者，如果参数个数不确定，this指针在所有参数压栈后被压入堆栈。对参数个数不确定的，调用者清理堆栈，否则由被调函数清理堆栈，__thiscal不是关键字，程序员不能使用l</p>
<p><strong>__pascal</strong>：与__stdcall一样，在VC中已经被废弃</p>
<h3 id="79使用条件变量的时候需要注意什么">79.使用条件变量的时候需要注意什么？</h3>
<p>当signal先于wait时，该信号会丢失，不会被后续的wait捕获</p>
<p>条件变量wait时，条件的判断和wait操作需要锁来保证原子性，要保证这一点，需要生产者在生产资源、cond signal时加和cond wait相同的锁，这样就会保证cond wait和cond signal先后顺序不会有问题，无论是谁先执行，都不会存在任何问题。</p>
<h3 id="80类内普通成员函数可以调用类内静态变量吗类内静态成员函数可以访问类内普通变量吗">80.类内普通成员函数可以调用类内静态变量吗，类内静态成员函数可以访问类内普通变量吗？</h3>
<p>类内普通成员函数可以调用类内静态变量，因为类内静态变量在编译时就已经完成了初始化和内存分配，类内普通函数调用类内静态变量说明类已经完成实例化，所以可以调用。静态函数可以直接访问静态变量，静态函数不能直接访问非静态变量，但是可以通过将类实例化对象后，静态函数去访问对象的非静态成员变量。</p>
<h3 id="81强制类型转换有哪几种类型分别有什么特点原理是什么">81.强制类型转换有哪几种类型，分别有什么特点？原理是什么？</h3>
<h4 id="static_cast用于数据类型的强制转换强制将一种数据类型转化为另一种数据类型">Static_cast：用于数据类型的强制转换，强制将一种数据类型转化为另一种数据类型。</h4>
<p><strong>主要用法</strong>：</p>
<p>1.用于类层次结构中基类和派生类之间指针或引用的转换，进行上行切换（把派生类的指针或引用转换成基类表示）是安全的，进行下行转换（把基类的指针或引用转换为派生类表示），由于没有动态类型检查，所以是不安全的。</p>
<p>2.用于基本类型之间的转换，如把int转换成char，这种类型的转换也需要开发人员来保证</p>
<p>3.把空指针转换成目标类型的空指针。</p>
<p>4.把任意类型的表达式转换成void类型</p>
<p>5.涉及到类时，只能在有相互联系的类型中进行相互转换，不一定包含虚函数</p>
<p><strong>注意</strong>：不能转换掉表达式中的const，volitale，__unaligned属性</p>
<h4 id="const_cast用于强制去除类似于const这种不能被修改的常数特性">Const_cast：用于强制去除类似于const这种不能被修改的常数特性。</h4>
<p><strong>用法</strong>：</p>
<p>1.用来修改类型的const或者volatile属性，除了const或volatile修饰之外，type_id和expression的类型是一样的。</p>
<p>2.常量指针被转化为非常量指针，并且仍然指向原来的对象</p>
<p>3.常量引用被转换为非常量引用，并且仍指向原来的对象，常量对象被转换成非常量对象。</p>
<p>注意：const_cast不适用于去除变量的常量性，而是去除指向常数对象的指针或引用的常量性，即去除常量性的对象必须为指针或者引用。</p>
<h4 id="reinterpret_cast用于改变指针或引用的类型将指针或引用类型转换成一个足够长的整形将整形转换为指针或引用">Reinterpret_cast：用于改变指针或引用的类型，将指针或引用类型转换成一个足够长的整形，将整形转换为指针或引用。</h4>
<p><strong>用法</strong>：</p>
<p>1.传入类型必须是一个指针，引用，算术类型，函数指针，成员函数或成员指针</p>
<p>2.它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针。</p>
<p>注意：在强制转换的过程中只是比特位的拷贝，咋使用中必须特别谨慎。</p>
<h4 id="dynamic_cast其他三种都是在编译时完成的它是在运行时处理的运行时要进行类型检查">Dynamic_cast：其他三种都是在编译时完成的，它是在运行时处理的，运行时要进行类型检查。</h4>
<p><strong>用法</strong>：</p>
<p>1.不能用于内置的基本数据类型的强制转换。</p>
<p>2.如果转换成功会返回一个指向类的指针或者引用，转换失败会返回NULL。</p>
<p>3.进行转换的时候基类中一定要有虚函数，否则编译不通过（因为类中存在虚函数就说明它有想让基类指针或引用指向派生类对象的情况，此时转换才有意义）。</p>
<p>4.在类的转换时，在类层次间进行上行转换时，与static_cast的转换效果是一样的，在下行转换时，它具有类型检查功能，比static_cast更安全。</p>
<p><strong>注意</strong>：向下转换的成功与否还与将要转换的类型有关，即要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败。如果转换目标是指针类型转换失败，则结果返回0，如果是引用类型则抛出std::bad_cast异常</p>
<p>原理：改变了其内存二进制的存储形式。</p>
<h3 id="82回调函数是什么为什么要有回调函数有什么优缺点回调的本质是什么">82.回调函数是什么，为什么要有回调函数？有什么优缺点？回调的本质是什么？</h3>
<p>回调函数是指使用者自己定义一个函数，实现这个函数的程序内容，然后别人把这个函数（入口地址）作为参数传入别人的函数中，由别人的函数在运行时来调用的函数，简单说就是放发生某种事件时，系统或其他函数将会自动调用你定义的一段函数。</p>
<p>可以把调用者和被调用者分开。调用者不关心谁是被调用者，所以它只需要知道的，只是一个存在某种特定类型原型，某些限制条件的被调用函数。</p>
<p><strong>优点</strong>：</p>
<p>可以让实现方根据回调方的多种形态进行不同的处理和操作</p>
<p>可以让实现方，根据自己的需要定制回调方的不同形态</p>
<p>可以将耗时的操作隐藏在回调方，不影响实现方其他信息的展示。</p>
<p>让代码的逻辑更加集中，更加易读。</p>
<p><strong>缺点</strong>：</p>
<p>回调函数过多会导致代码难以维护</p>
<p>回调函数容易造成资源竞争：如果回调函数中有共享资源访问，容易出现资源争抢，导致程序出错</p>
<p>代码可读性差，可能会破坏代码的结构和可读性</p>
<p><strong>本质</strong>：是将函数当作参数使用，目的是为了使程序更加普适。</p>
<h3 id="83linux中的信号有哪些">83.Linux中的信号有哪些？</h3>
<p>SIGINT：终端中断符，默认动作：终止。当用户按中断键（Ctrl+C）时，终端驱动程序产生此信号并发送至前台进程组中的每一个进程，当一个进程在运行时失控，特别是在终端输出大量信息时，常用此信号终止它。</p>
<p>SIGQUIT：终端退出符，默认动作：终止+core。当用户在终端按退出键（Ctrl+\）时，终端驱动程序产生此信号，并发送给前台进程中所有进程，此信号不仅终止前台进程组，同时产生一个core文件。</p>
<p>SIGILL：非法硬件指令，默认动作：终止+core。此信号表示进程已执行一条非法硬件指令</p>
<p>SIGRAP：硬件故障，默认动作：终止+core。指示一个实现定义的硬件故障</p>
<p>SIGBUG：硬件故障，默认动作：终止+core。指示一个实现定义的硬件故障，当出现某些类型的内存故障时，常产生此信号。</p>
<p>SIGKILL：终止，默认动作：终止。这是两个不能被捕捉或忽略的信号之一，它向系统管理员提供一个可以杀死任一进程的可靠方法</p>
<p>SIGSEGV：无效的内存引用，默认动作：终止+core。指示进程进行了一次无效的内存引用，通常说明程序有错，比如 访问了一个未经初始化的指针。</p>
<p>SIGALRM：定时器超时，默认动作：终止。如果在管道的读进程终止时写管道，则产生此信号，当类型为SOCK_STREAM的套接字已不再连接时，进程写该套接字也产生此信号。</p>
<p>SIGTERM：终止，默认动作：终止。这是由kill命令发出的系统默认终止信号，由于该信号是由应用程序捕获的，所以使用SIGTERM也让程序有机会在退出之前做好清理工作，与SIGKILL不同的是，SIGKILL不能捕捉。</p>
<p>SIGCONT：使暂停进程继续，默认动作：忽略。此进程发送给需要运行但是目前状态是暂停的进程，如果接收到此信号的进程处于暂停状态则继续运行，否则忽略。</p>
<p>SIGURG：紧急情况，默认动作：忽略。通知进程发生一个紧急情况，在网络上街到带外的数据时，可以选择产生此信号</p>
<p>SIGPOLL：可轮询事件，默认动作：终止。产生条件当一个可轮询设备上发生一个特定事件时产生</p>
<p>SIGIO：异步IO，默认动作：终止。产生异步IO时产生</p>
<p>还有很多就不全部放进来了，全部链接：<a href="https://blog.csdn.net/lqc132/article/details/121277357?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169301157416800182721632%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169301157416800182721632&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-121277357-null-null.142%5Ev93%5Econtrol&amp;utm_term=Linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E6%9C%89%E5%93%AA%E4%BA%9B&amp;spm=1018.2226.3001.4187" title="Linux信号一览_linux 信号表_lqc132的博客-CSDN博客">Linux信号一览_linux 信号表_lqc132的博客-CSDN博客</a></p>
<h3 id="84什么是尾递归">84.什么是尾递归？</h3>
<p>尾递归时递归的一种特殊情形，尾递归时一种特殊的尾调用，即在尾部直接调用自身的递归函数。核心思想是边调用便产生结果。</p>
<p><strong>原理</strong>：当编译器检测到一个函数调用是尾递归的时候，它会覆盖当前的活动记录而不是在栈中创建一个新的。编译器可以做到这一点，因为递归调用是当前活跃期内最后一条待执行的语句，于是当这个调用返回时栈帧中并没有其他事情可以做，因此也就没有保存栈帧的必要了，通过覆盖当前的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效率会变得更高。</p>
<p><strong>特点</strong>：在尾部调用的是函数自身，可通过优化使得计算仅占用常量栈空间</p>
<h3 id="85为什么会有栈溢出为什么栈会设置容量">85.为什么会有栈溢出，为什么栈会设置容量？</h3>
<p>栈空间是预设的，它通常用于存放临时变量，如果你在函数内部定义一个局部变量，空间超出了设置的栈空间大小，就会溢出。不仅如此，如果函数嵌套太多，也会发生栈溢出，因为函数没有结束前，函数占用的变量也不被释放，占用了栈空间。</p>
<p>原因：是栈的地址空间必须连续，如果任其任意成长，会给内存管理带来困难。对于多线程程序来说，每个线程都必须分配一个栈，因此没办法让默认值太大。</p>
<h3 id="86二叉树和平衡二叉树的区别">86.二叉树和平衡二叉树的区别</h3>
<p>二叉树没有平衡因子的限制，而平衡二叉树有。</p>
<p>二叉树可能退化为链表，而平衡二叉树不会。</p>
<h3 id="87平衡二叉树的优缺点">87.平衡二叉树的优缺点</h3>
<p>优点：避免了二叉排序树可能出现最极端情况（退化为链表），其平均查找的时间复杂度为logN</p>
<p>缺点：对AVL树做一些结构修改的操作，性能非常低下，比如：插入时要维护其绝对平衡，旋转的次数比较多，更差的是在删除时，有可能一直要让旋转持续到根的位置。</p>
<h3 id="88什么是this指针为什么存在this指针">88.什么是this指针，为什么存在this指针？</h3>
<p>类和对象中的成员函数存储在公共的代码段，不同的对象调用成员函数时编译器为了知道具体操作的是哪一个对象给每个“非静态的成员函数”增加了一个隐藏的指针参数，让该指针指向当前对象，在函数体中所有成员变量的操作，都是通过这个指针来完成的由编译器自动完成。</p>
<h3 id="89什么是重载-重写-隐藏">89.什么是重载、重写、隐藏？</h3>
<p>重载：函数名相同，函数参数不同，两个函数在同一作用域</p>
<p>重写：两个函数分别在子类和父类中，函数名，返回值，参数均相同，函数必须为虚函数</p>
<p>隐藏：在继承关系中，子类实现了一个和父类名字名字一样的函数。这样子类的函数就把父类的同名函数隐藏了。隐藏只与函数名有关。</p>
<h3 id="90静态成员函数可以是虚函数吗为什么">90.静态成员函数可以是虚函数吗？为什么？</h3>
<p>它不属于类中的任何一个对象或示例，属于类共有的一个函数，不依赖于对象调用，静态成员函数没有this指针，无法放进虚函数表。</p>
<h3 id="91构造函数可以为虚函数吗为什么">91.构造函数可以为虚函数吗？为什么？</h3>
<p>虚表指针是存储在对象的内存空间，当调虚函数时，是通过虚表指针指向的虚表里的函数地址进行调用的。如果将构造函数定义为虚函数，就要通过虚表指针指向的虚表的构造函数地址来调用。而构造函数是实例化对象，定义为虚函数后，对象空间还没有实例化，那就没有虚表指针，自然无法调用构造函数，那构造函数就失去意义，所以不能将构造函数定义为虚函数。</p>
<h3 id="92make_shared函数的优点缺点">92.make_shared函数的优点，缺点？</h3>
<p>优点：减少了内存分配的次数，降低了系统开销，提高了效率，使用new构造的话至少会进行两次内存分配，（一次为智能指针本身，一次为共享指针的控制块）</p>
<p>缺点：当构造函数是保护或者私有的时候无法使用make_shared函数。</p>
<p>会导致weak_ptr保持控制块，的生命周期，连带着保持了对象分配的内存，只有当最后一个weakptr离开作用域时，内存才会被释放，对于内存要求高的场景来说，是一个需要注意的问题。</p>
<h3 id="93函数调用进行的操作">93.函数调用进行的操作：</h3>
<p>1.将参数压栈：按照参数顺序的逆序进行，如果参数中有对象则先进行拷贝构造</p>
<p>2.保存返回地址：即函数调用结束返回后接着执行的语句的地址</p>
<p>3.保护维护函数栈帧信息的寄存器内容如，SP（堆栈指针），FP（栈帧指针）等。</p>
<p>4.保存一些通用寄存器的内容：应为有些通用寄存器会被所有函数用到，所以在函数调用之前，这些寄存器就可能已经放置了对函数有用的信息。</p>
<p>5.调用函数，函数执行完毕</p>
<p>6.恢复通用寄存器的值</p>
<p>7.恢复保存函数栈帧信息的那些寄存器的值</p>
<p>8.通过移动栈指针，销毁函数的栈帧</p>
<p>9.将保存的返回地址出栈，并赋给寄存器。</p>
<p>10.通过移动栈指针，回收传给函数的参数所占用的空间</p>
<h3 id="参考链接">参考链接：</h3>
<p><a href="https://blog.csdn.net/XiaoFengsen/article/details/125937918?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169286515016800182717940%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169286515016800182717940&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-125937918-null-null.142%5Ev93%5Econtrol&amp;utm_term=C%2B%2B%E5%85%AB%E8%82%A1%E6%96%87&amp;spm=1018.2226.3001.4187" title="C++面经八股文_c++面试八股文_何处微尘的博客-CSDN博客">C++面经八股文_c++面试八股文_何处微尘的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/zcc1229936385/article/details/120497544?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169286515016800182717940%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169286515016800182717940&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-120497544-null-null.142%5Ev93%5Econtrol&amp;utm_term=C%2B%2B%E5%85%AB%E8%82%A1%E6%96%87&amp;spm=1018.2226.3001.4187" title="C++面试八股文快问快答の基础篇_c++八股文_谁吃薄荷糖的博客-CSDN博客">C++面试八股文快问快答の基础篇_c++八股文_谁吃薄荷糖的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/m0_62807361?type=blog" title="txinyu的博客_-CSDN博客">txinyu的博客_-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/Vermont_/article/details/84557065?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169301144416800197095380%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169301144416800197095380&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-84557065-null-null.142%5Ev93%5Econtrol&amp;utm_term=%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E9%80%92%E5%BD%92&amp;spm=1018.2226.3001.4187" title="详解什么是尾递归（通俗易懂，示例讲解）_Allen Chou的博客-CSDN博客">详解什么是尾递归（通俗易懂，示例讲解）_Allen Chou的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/weixin_45796387/article/details/114994648?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169301146316800197038426%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169301146316800197038426&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114994648-null-null.142%5Ev93%5Econtrol&amp;utm_term=%E4%BA%8C%E5%8F%89%E6%A0%91&amp;spm=1018.2226.3001.4187" title="数据结构--二叉树--详解_清欢有道的博客-CSDN博客">数据结构--二叉树--详解_清欢有道的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_41786318/article/details/80540838?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169301148216777224445633%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169301148216777224445633&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-80540838-null-null.142%5Ev93%5Econtrol&amp;utm_term=%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%88%E4%BC%9A%E8%AE%BE%E7%BD%AE%E5%AE%B9%E9%87%8F&amp;spm=1018.2226.3001.4187" title="为什么要限制栈的大小？_栈大小限制_千么漾漾的博客-CSDN博客">为什么要限制栈的大小？_栈大小限制_千么漾漾的博客-CSDN博客</a></p>
<p><a href="http://www.slyar.com/blog/variable-overflow-static.html" title="C语言 全局变量和局部变量的大小限制 - Slyar Home">C语言 全局变量和局部变量的大小限制 - Slyar Home</a></p>
<p><a href="https://blog.csdn.net/liuhuiyi/article/details/8207021?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169301148216777224445633%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169301148216777224445633&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-3-8207021-null-null.142%5Ev93%5Econtrol&amp;utm_term=%E4%B8%BA%E4%BB%80%E4%B9%88%E6%A0%88%E4%BC%9A%E8%AE%BE%E7%BD%AE%E5%AE%B9%E9%87%8F&amp;spm=1018.2226.3001.4187" title="程序中关于堆栈大小的划定_任务堆栈大小怎么确定_liuhuiyi的博客-CSDN博客">程序中关于堆栈大小的划定_任务堆栈大小怎么确定_liuhuiyi的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/daaikuaichuan/article/details/84797234?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169301154316800197022117%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169301154316800197022117&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-84797234-null-null.142%5Ev93%5Econtrol&amp;utm_term=%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88&amp;spm=1018.2226.3001.4187" title="回调函数详解_~青萍之末~的博客-CSDN博客">回调函数详解_<sub>青萍之末</sub>的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/lqc132/article/details/121277357?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169301157416800182721632%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169301157416800182721632&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-121277357-null-null.142%5Ev93%5Econtrol&amp;utm_term=Linux%E4%B8%AD%E7%9A%84%E4%BF%A1%E5%8F%B7%E6%9C%89%E5%93%AA%E4%BA%9B&amp;spm=1018.2226.3001.4187" title="Linux信号一览_linux 信号表_lqc132的博客-CSDN博客">Linux信号一览_linux 信号表_lqc132的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_58325487/article/details/124785521?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169301160716800185892815%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169301160716800185892815&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-124785521-null-null.142%5Ev93%5Econtrol&amp;utm_term=this%E6%8C%87%E9%92%88&amp;spm=1018.2226.3001.4187" title="[ C++ ] 一篇带你了解C++中隐藏的this指针_c++ this_小白又菜的博客-CSDN博客">[ C++ ] 一篇带你了解C++中隐藏的this指针_c++ this_小白又菜的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_39736982/article/details/82380689?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169301162816800227438387%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169301162816800227438387&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-82380689-null-null.142%5Ev93%5Econtrol&amp;utm_term=%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F&amp;spm=1018.2226.3001.4187" title="条件变量详细解说_清风徐来Groot的博客-CSDN博客">条件变量详细解说_清风徐来Groot的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/lujiandong1/article/details/49872763?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169301164316800192266164%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169301164316800192266164&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-49872763-null-null.142%5Ev93%5Econtrol&amp;utm_term=%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%A4%B1%E6%95%88&amp;spm=1018.2226.3001.4187" title="迭代器失效的几种情况总结_迭代器失效 性能_BYR_jiandong的博客-CSDN博客">迭代器失效的几种情况总结_迭代器失效 性能_BYR_jiandong的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/qq_43700779/article/details/123406329?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169301166216800197016162%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=169301166216800197016162&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-123406329-null-null.142%5Ev93%5Econtrol&amp;utm_term=C%2B%2B%E5%BC%BA%E5%88%B6%E8%BD%AC%E5%8C%96&amp;spm=1018.2226.3001.4187" title="C++的四种强制转换_c++强制转换_酒馆店小二的博客-CSDN博客">C++的四种强制转换_c++强制转换_酒馆店小二的博客-CSDN博客</a></p>
<p><a href="https://blog.csdn.net/lemonxiaoxiao/article/details/125850216?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=vectorresize&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-125850216.142%5Ev93%5Econtrol&amp;spm=1018.2226.3001.4187" title="【C++】vector的reserve()和resize()用法_vector resize_Amelie_xiao的博客-CSDN博客">【C++】vector的reserve()和resize()用法_vector resize_Amelie_xiao的博客-CSDN博客</a></p>
<p><a href="https://en.cppreference.com/w/" title="cppreference.com">cppreference.com</a></p>
<p><a href="https://blog.csdn.net/chenlong_cxy" title="2021dragon_C++,leetcode,C语言-CSDN博客">2021dragon_C++,leetcode,C语言-CSDN博客</a></p>
<h3 id="参考书籍">参考书籍：</h3>
<p>STL源码剖析，Unix网络编程，effective C++，C++PrimePlus</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++面经分享]]></title>
        <id>https://tangyin1.github.io/post/t/</id>
        <link href="https://tangyin1.github.io/post/t/">
        </link>
        <updated>2024-08-29T05:48:45.000Z</updated>
        <summary type="html"><![CDATA[<p>一些常见面试题搜集</p>
]]></summary>
        <content type="html"><![CDATA[<p>一些常见面试题搜集</p>
<!-- more -->
<h1 id="1-语言基础-cc">1. 语言基础 (C/C++)</h1>
<h4 id="0-指针和引用的区别">（0） 指针和引用的区别</h4>
<ul>
<li>指针是一个新的变量，指向另一个变量的地址，我们可以通过访问这个地址来修改另一个变量；而引用是一个别名，对引用的操作就是对变量的本身进行操作</li>
<li>指针可以有多级，引用只有一级</li>
<li>传参的时候，使用指针的话需要解引用才能对参数进行修改，而使用引用可以直接对参数进行修改</li>
<li>指针的大小一般是4个字节，引用的大小取决于被引用对象的大小</li>
<li>指针可以为空，引用不可以。</li>
</ul>
<h4 id="1在函数参数传递的时候什么时候使用指针什么时候使用引用">（1）在函数参数传递的时候，什么时候使用指针，什么时候使用引用？</h4>
<ul>
<li>需要返回函数内局部变量的内存的时候用指针。使用指针传参需要开辟内存，用完要记得释放指针，不然会内存泄漏。而返回局部变量的引用是没有意义的</li>
<li>对栈空间大小比较敏感（比如递归）的时候使用引用。使用引用传递不需要创建临时变量，开销要更小</li>
<li>类对象作为参数传递的时候使用引用，这是C++类对象传递的标准方式</li>
</ul>
<h4 id="2-堆和栈有什么区别">（2） 堆和栈有什么区别</h4>
<ul>
<li>从定义上：堆是由new和malloc开辟的一块内存，由程序员手动管理，栈是编译器自动管理的内存，存放函数的参数和局部变量。</li>
<li>堆空间因为会有频繁的分配释放操作，会产生内存碎片</li>
<li>堆的生长空间向上，地址越来越大，栈的生长空间向下，地址越来越小</li>
</ul>
<h4 id="3堆快一点还是栈快一点字节提前批一面">（3）堆快一点还是栈快一点？（字节提前批一面）</h4>
<p>栈快一点。因为操作系统会在底层对栈提供支持，会分配专门的寄存器存放栈的地址，栈的入栈出栈操作也十分简单，并且有专门的指令执行，所以栈的效率比较高也比较快。而堆的操作是由C/C++函数库提供的，在分配堆内存的时候需要一定的算法寻找合适大小的内存。并且获取堆的内容需要两次访问，第一次访问指针，第二次根据指针保存的地址访问内存，因此堆比较慢。</p>
<h4 id="4-new和delete是如何实现的new-与-malloc的异同处">（4） new和delete是如何实现的，new 与 malloc的异同处</h4>
<p>在new一个对象的时候，首先会调用malloc为对象分配内存空间，然后调用对象的构造函数。delete会调用对象的析构函数，然后调用free回收内存。</p>
<p>new与malloc都会分配空间，但是new还会调用对象的构造函数进行初始化，malloc需要给定空间大小，而new只需要对象名</p>
<h4 id="5既然有了mallocfreec中为什么还需要newdelete呢">（5）既然有了malloc/free，C++中为什么还需要new/delete呢？</h4>
<p>https://blog.csdn.net/leikun153/article/details/80612130</p>
<ul>
<li>malloc/free和new/delete都是用来申请内存和回收内存的。</li>
<li>在对非基本数据类型的对象使用的时候，对象创建的时候还需要执行构造函数，销毁的时候要执行析构函数。而malloc/free是库函数，是已经编译的代码，所以不能把构造函数和析构函数的功能强加给malloc/free。</li>
</ul>
<h4 id="6-c和c的区别">（6） C和C++的区别</h4>
<p>包括但不限于：</p>
<ul>
<li>C是面向过程的语言，C++是面向对象的语言，C++有“封装，继承和多态”的特性。封装隐藏了实现细节，使得代码模块化。继承通过子类继承父类的方法和属性，实现了代码重用。多态则是“一个接口，多个实现”，通过子类重写父类的虚函数，实现了接口重用。</li>
<li>C和C++内存管理的方法不一样，C使用malloc/free，C++除此之外还用new/delete</li>
<li>C++中还有函数重载和引用等概念，C中没有</li>
</ul>
<h4 id="7delete和delete的区别">（7）delete和delete[]的区别</h4>
<ul>
<li>
<p>delete只会调用一次析构函数，而delete[]会调用每个成员的析构函数</p>
</li>
<li>
<p>用new分配的内存用delete释放，用new[]分配的内存用delete[]释放</p>
</li>
</ul>
<h4 id="8-c-java的联系与区别包括语言特性-垃圾回收-应用场景等java的垃圾回收机制">（8） C++、Java的联系与区别，包括语言特性、垃圾回收、应用场景等（java的垃圾回收机制）</h4>
<p>包括但不限于：</p>
<ul>
<li>C++ 和Java都是面向对象的语言，C++是编译成可执行文件直接运行的，JAVA是编译之后在JAVA虚拟机上运行的，因此JAVA有良好的跨平台特性，但是执行效率没有C++ 高。</li>
<li>C++的内存管理由程序员手动管理，JAVA的内存管理是由Java虚拟机完成的，它的垃圾回收使用的是标记-回收算法</li>
<li>C++有指针，Java没有指针，只有引用</li>
<li>JAVA和C++都有构造函数，但是C++有析构函数但是Java没有</li>
</ul>
<h4 id="9c和python的区别">（9）C++和python的区别</h4>
<p>包括但不限于：</p>
<ol>
<li>python是一种脚本语言，是解释执行的，而C++是编译语言，是需要编译后在特定平台运行的。python可以很方便的跨平台，但是效率没有C++高。</li>
<li>python使用缩进来区分不同的代码块，C++使用花括号来区分</li>
<li>C++中需要事先定义变量的类型，而python不需要，python的基本数据类型只有数字，布尔值，字符串，列表，元组等等</li>
<li>python的库函数比C++的多，调用起来很方便</li>
</ol>
<h4 id="10-struct和class的区别">（10） Struct和class的区别</h4>
<ul>
<li>使用struct时，它的成员的访问权限默认是public的，而class的成员默认是private的</li>
<li>struct的继承默认是public继承，而class的继承默认是private继承</li>
<li>class可以用作模板，而struct不能</li>
</ul>
<h4 id="11-define-和const的联系与区别编译阶段-安全性-内存占用等">（11） define 和const的联系与区别（编译阶段、安全性、内存占用等）</h4>
<p>联系：它们都是定义常量的一种方法。</p>
<p>区别：</p>
<ul>
<li>define定义的常量没有类型，只是进行了简单的替换，可能会有多个拷贝，占用的内存空间大，const定义的常量是有类型的，存放在静态存储区，只有一个拷贝，占用的内存空间小。</li>
<li>define定义的常量是在预处理阶段进行替换，而const在编译阶段确定它的值。</li>
<li>define不会进行类型安全检查，而const会进行类型安全检查，安全性更高。</li>
<li>const可以定义函数而define不可以。</li>
</ul>
<h4 id="12-在c中const的用法定义用途">（12） 在C++中const的用法（定义，用途）</h4>
<ul>
<li>const修饰类的成员变量时，表示常量不能被修改</li>
<li>const修饰类的成员函数，表示该函数不会修改类中的数据成员，不会调用其他非const的成员函数</li>
</ul>
<h4 id="13-c中的static用法和意义">（13） C++中的static用法和意义</h4>
<p>static的意思是静态的，可以用来修饰变量，函数和类成员。</p>
<ul>
<li>
<p>变量：被static修饰的变量就是静态变量，它会在程序运行过程中一直存在，会被放在静态存储区。局部静态变量的作用域在函数体中，全局静态变量的作用域在这个文件里。</p>
</li>
<li>
<p>函数：被static修饰的函数就是静态函数，静态函数只能在本文件中使用，不能被其他文件调用，也不会和其他文件中的同名函数冲突。</p>
</li>
<li>
<p>类：而在类中，被static修饰的成员变量是类静态成员，这个静态成员会被类的多个对象共用。被static修饰的成员函数也属于静态成员，不是属于某个对象的，访问这个静态函数不需要引用对象名，而是通过引用类名来访问。</p>
</li>
</ul>
<p>【note】静态成员函数要访问非静态成员时，要用过对象来引用。局部静态变量在函数调用结束后也不会被回收，会一直在程序内存中，直到该函数再次被调用，它的值还是保持上一次调用结束后的值。</p>
<p>注意和const的区别。const强调值不能被修改，而static强调唯一的拷贝，对所有类的对象都共用。</p>
<h4 id="14-计算下面几个类的大小">（14） 计算下面几个类的大小：</h4>
<pre><code class="language-C++">class A {};
int main(){
  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;
  A a; 
  cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;
  return 0;
}

</code></pre>
<p>空类的大小是1， 在C++中空类会占一个字节，这是为了让对象的实例能够相互区别。具体来说，空类同样可以被实例化，并且每个实例在内存中都有独一无二的地址，因此，编译器会给空类隐含加上一个字节，这样空类实例化之后就会拥有独一无二的内存地址。当该空白类作为基类时，该类的大小就优化为0了，子类的大小就是子类本身的大小。这就是所谓的空白基类最优化。</p>
<p>空类的实例大小就是类的大小，所以sizeof(a)=1字节,如果a是指针，则sizeof(a)就是指针的大小，即4字节。</p>
<pre><code class="language-C++">class A { virtual Fun(){} };
int main(){
  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);
  A a; 
  cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4(32位机器)/8(64位机器);
  return 0;
}
</code></pre>
<p>因为有虚函数的类对象中都有一个虚函数表指针 __vptr，其大小是4字节<br></p>
<pre><code class="language-C++">class A { static int a; };
int main(){
  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 1;
  A a; 
  cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 1;
  return 0;
}
</code></pre>
<p>静态成员存放在静态存储区，不占用类的大小, 普通函数也不占用类大小</p>
<pre><code class="language-C++">class A { int a; };
int main(){
  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4;
  A a; 
  cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4;
  return 0;
}
</code></pre>
<pre><code class="language-C++">class A { static int a; int b; };;
int main(){
  cout&lt;&lt;sizeof(A)&lt;&lt;endl;// 输出 4;
  A a; 
  cout&lt;&lt;sizeof(a)&lt;&lt;endl;// 输出 4;
  return 0;
}
</code></pre>
<p>静态成员a不占用类的大小，所以类的大小就是b变量的大小 即4个字节</p>
<h4 id="15-c的stl介绍这个系列也很重要建议侯捷老师的这方面的书籍与视频其中包括内存管理allocator函数实现机理多线程实现等">（15） C++的STL介绍（这个系列也很重要，建议侯捷老师的这方面的书籍与视频），其中包括内存管理allocator，函数，实现机理，多线程实现等</h4>
<p>C++ STL从广义来讲包括了三类：算法，容器和迭代器。</p>
<ul>
<li>算法包括排序，复制等常用算法，以及不同容器特定的算法。</li>
<li>容器就是数据的存放形式，包括序列式容器和关联式容器，序列式容器就是list，vector等，关联式容器就是set，map等。</li>
<li>迭代器就是在不暴露容器内部结构的情况下对容器的遍历。</li>
</ul>
<h4 id="16-stl源码中的hash表的实现">（16） STL源码中的hash表的实现</h4>
<p>STL中的hash表就unordered_map。使用的是哈希进行实现（注意与map的区别）。它记录的键是元素的哈希值，通过对比元素的哈希值来确定元素的值。</p>
<p>unordered_map的底层实现是hashtable，采用开链法（也就是用桶）来解决哈希冲突，当桶的大小超过8时，就自动转为红黑树进行组织。</p>
<h4 id="17解决哈希冲突的方式">（17）解决哈希冲突的方式？</h4>
<ol>
<li>线性探查。该元素的哈希值对应的桶不能存放元素时，循序往后一一查找，直到找到一个空桶为止，在查找时也一样，当哈希值对应位置上的元素与所要寻找的元素不同时，就往后一一查找，直到找到吻合的元素，或者空桶。</li>
<li>二次探查。该元素的哈希值对应的桶不能存放元素时，就往后寻找1<sup>2,2</sup>2,3<sup>2,4</sup>2.....i^2个位置。</li>
<li>双散列函数法。当第一个散列函数发生冲突的时候，使用第二个散列函数进行哈希，作为步长。</li>
<li>开链法。在每一个桶中维护一个链表，由元素哈希值寻找到这个桶，然后将元素插入到对应的链表中，STL的hashtable就是采用这种实现方式。</li>
<li>建立公共溢出区。当发生冲突时，将所有冲突的数据放在公共溢出区。</li>
</ol>
<h4 id="18-stl中unordered_map和map的区别">（18） STL中unordered_map和map的区别</h4>
<ul>
<li>unordered_map是使用哈希实现的，占用内存比较多，查询速度比较快，是常数时间复杂度。它内部是无序的，需要实现==操作符。</li>
<li>map底层是采用红黑树实现的，插入删除查询时间复杂度都是O(log(n))，它的内部是有序的，因此需要实现比较操作符(&lt;)。</li>
</ul>
<h4 id="19-stl中vector的实现">（19） STL中vector的实现</h4>
<p>STL中的vector是封装了动态数组的顺序容器。不过与动态数组不同的是，vector可以根据需要自动扩大容器的大小。具体策略是每次容量不够用时重新申请一块大小为原来容量两倍的内存，将原容器的元素拷贝至新容器，并释放原空间，返回新空间的指针。</p>
<p>在原来空间不够存储新值时，每次调用push_back方法都会重新分配新的空间以满足新数据的添加操作。如果在程序中频繁进行这种操作，还是比较消耗性能的。</p>
<h4 id="20-vector使用的注意点及其原因频繁对vector调用push_back对性能的影响和原因">（20） vector使用的注意点及其原因，频繁对vector调用push_back()对性能的影响和原因。</h4>
<p>如果需要频繁插入，最好先指定vector的大小，因为vector在容器大小不够用的时候会重新申请一块大小为原容器两倍的空间，并将原容器的元素拷贝到新容器中，并释放原空间，这个过程是十分耗时和耗内存的。频繁调用push_back()会使得程序花费很多时间在vector扩容上，会变得很慢。这种情况可以考虑使用list。</p>
<h4 id="21c中vector和list的区别">（21）C++中vector和list的区别</h4>
<p>vector和数组类似，拥有一段连续的内存空间。vector申请的是一段连续的内存，当插入新的元素内存不够时，通常以2倍重新申请更大的一块内存，将原来的元素拷贝过去，释放旧空间。因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。</p>
<p>list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n); 但由于链表的特点，能高效地进行插入和删除。</p>
<p>vector拥有一段连续的内存空间，能很好的支持随机存取，因此vector::iterator支持“+”，“+=”，“&lt;”等操作符。</p>
<p>list的内存空间可以是不连续，它不支持随机访问，因此list::iterator则不支持“+”、“+=”、“&lt;”等</p>
<p>vector::iterator和list::iterator都重载了“++”运算符。</p>
<p>总之，如果需要高效的随机存取，而不在乎插入和删除的效率，使用vector;</p>
<p>如果需要大量的插入和删除，而不关心随机存取，则应使用list。</p>
<h4 id="22-c中的重载和重写的区别">（22） C++中的重载和重写的区别：</h4>
<ul>
<li>重载（overload）是指函数名相同，参数列表不同的函数实现方法。它们的返回值可以不同，但返回值不可以作为区分不同重载函数的标志。</li>
<li>重写（overwide）是指函数名相同，参数列表相同，只有方法体不相同的实现方法。一般用于子类继承父类时对父类方法的重写。子类的同名方法屏蔽了父类方法的现象称为隐藏。</li>
</ul>
<p>详见：https://blog.csdn.net/weixin_30379911/article/details/99497160</p>
<h4 id="23-c-内存管理热门问题">（23） C ++内存管理（热门问题）</h4>
<p>https://blog.csdn.net/qq_43152052/article/details/98889139</p>
<p>在C++中，内存分成5个区，他们分别是堆、栈、全局/静态存储区和常量存储区和代码区。</p>
<ul>
<li>栈，在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</li>
<li>堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</li>
<li>全局/静态存储区，内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放静态数据（局部static变量，全局static变量）、全局变量和常量。</li>
<li>常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量字符串，不允许修改。</li>
<li>代码区，存放程序的二进制代码</li>
</ul>
<p>关于这个有很多种说法，有的会增加一个自由存储区，存放malloc分配得到的内存，与堆相似。</p>
<h4 id="24-介绍面向对象的三大特性并且举例说明每一个">（24） 介绍面向对象的三大特性，并且举例说明每一个。</h4>
<p>面向对象的三大特性是：封装，继承和多态。</p>
<ul>
<li>封装隐藏了类的实现细节和成员数据，实现了代码模块化，如类里面的private和public；</li>
<li>继承使得子类可以复用父类的成员和方法，实现了代码重用；</li>
<li>多态则是“一个接口，多个实现”，通过父类调用子类的成员，实现了接口重用，如父类的指针指向子类的对象。</li>
</ul>
<h4 id="25-多态的实现和下个问题一起回答">（25） 多态的实现（和下个问题一起回答）</h4>
<p>C++ 多态包括编译时多态和运行时多态，编译时多态体现在函数重载和模板上，运行时多态体现在虚函数上。</p>
<ul>
<li>虚函数：在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时将会根据对象的实际类型来调用相应的函数。如果对象类型是派生类，就调用派生类的函数；如果对象类型是基类，就调用基类的函数.</li>
</ul>
<h4 id="26-c虚函数相关虚函数表虚函数指针虚函数的实现原理热门重要">（26） C++虚函数相关（虚函数表，虚函数指针），虚函数的实现原理（热门，重要）</h4>
<p>C++的虚函数是实现多态的机制。它是通过虚函数表实现的，虚函数表是每个类中存放虚函数地址的指针数组，类的实例在调用函数时会在虚函数表中寻找函数地址进行调用，如果子类覆盖了父类的函数，则子类的虚函数表会指向子类实现的函数地址，否则指向父类的函数地址。一个类的所有实例都共享同一张虚函数表。</p>
<p>详见：<a href="https://blog.csdn.net/lihao21/article/details/50688337">C++虚函数表剖析</a></p>
<ul>
<li>如果多重继承和多继承的话，子类的虚函数表长什么样子？<br>
多重继承的情况下越是祖先的父类的虚函数更靠前，多继承的情况下越是靠近子类名称的类的虚函数在虚函数表中更靠前。详见：https://blog.csdn.net/qq_36359022/article/details/81870219</li>
</ul>
<h4 id="27-实现编译器处理虚函数表应该如何处理">（27） 实现编译器处理虚函数表应该如何处理</h4>
<p>编译器处理虚函数的方法是：<br>
如果类中有虚函数，就将虚函数的地址记录在类的虚函数表中。派生类在继承基类的时候，如果有重写基类的虚函数，就将虚函数表中相应的函数指针设置为派生类的函数地址，否则指向基类的函数地址。<br>
为每个类的实例添加一个虚表指针（vptr），虚表指针指向类的虚函数表。实例在调用虚函数的时候，通过这个虚函数表指针找到类中的虚函数表，找到相应的函数进行调用。<br>
详见：<a href="https://blog.csdn.net/iFuMI/article/details/51088091">虚函数的作用及其底层实现机制</a></p>
<h4 id="28-基类的析构函数一般写成虚函数的原因">（28） 基类的析构函数一般写成虚函数的原因</h4>
<p>首先析构函数可以为虚函数，当析构一个指向子类的父类指针时，编译器可以根据虚函数表寻找到子类的析构函数进行调用，从而正确释放子类对象的资源。</p>
<p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向子类的父类指针时，只会调用父类的析构函数而不调用子类析构函数，这样就会造成子类对象析构不完全造成内存泄漏。</p>
<h4 id="29-构造函数为什么一般不定义为虚函数">（29） 构造函数为什么一般不定义为虚函数</h4>
<p>1）因为创建一个对象时需要确定对象的类型，而虚函数是在运行时确定其类型的。而在构造一个对象时，<strong>由于对象还未创建成功，编译器无法知道对象的实际类型</strong>，是类本身还是类的派生类等等</p>
<p>2）虚函数的调用需要虚函数表指针，而该指针存放在对象的内存空间中；若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表地址用来调用虚函数即构造函数了</p>
<h4 id="30-构造函数或者析构函数中调用虚函数会怎样">（30） 构造函数或者析构函数中调用虚函数会怎样</h4>
<p>在构造函数中调用虚函数，由于当前对象还没有构造完成，此时调用的虚函数指向的是基类的函数实现方式。</p>
<p>在析构函数中调用虚函数，此时调用的是子类的函数实现方式。</p>
<h4 id="31-纯虚函数">（31） 纯虚函数</h4>
<p>纯虚函数是只有声明没有实现的虚函数，是对子类的约束，是接口继承</p>
<p>包含纯虚函数的类是抽象类，它不能被实例化，只有实现了这个纯虚函数的子类才能生成对象</p>
<p>使用场景：当这个类本身产生一个实例没有意义的情况下，把这个类的函数实现为纯虚函数，比如动物可以派生出老虎兔子，但是实例化一个动物对象就没有意义。并且可以规定派生的子类必须重写某些函数的情况下可以写成纯虚函数。</p>
<h4 id="32-静态绑定和动态绑定的介绍">（32） 静态绑定和动态绑定的介绍</h4>
<p><a href="https://www.cnblogs.com/lizhenghn/p/3657717.html">C++中的静态绑定和动态绑定</a></p>
<p>静态绑定也就是将该对象相关的属性或函数绑定为它的静态类型，也就是它在声明的类型，在编译的时候就确定。在调用的时候编译器会寻找它声明的类型进行访问。</p>
<p>动态绑定就是将该对象相关的属性或函数绑定为它的动态类型，具体的属性或函数在运行期确定，通常通过虚函数实现动态绑定。</p>
<h4 id="33-深拷贝和浅拷贝的区别举例说明深拷贝的安全性">（33） 深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）</h4>
<p>浅拷贝就是将对象的指针进行简单的复制，原对象和副本指向的是相同的资源。</p>
<p>而深拷贝是新开辟一块空间，将原对象的资源复制到新的空间中，并返回该空间的地址。</p>
<p>深拷贝可以避免重复释放和写冲突。例如使用浅拷贝的对象进行释放后，对原对象的释放会导致内存泄漏或程序崩溃。</p>
<h4 id="34-对象复用的了解零拷贝的了解">（34） 对象复用的了解，零拷贝的了解</h4>
<p>对象复用指得是设计模式，对象可以采用不同的设计模式达到复用的目的，最常见的就是继承和组合模式了。</p>
<p>零拷贝指的是在进行操作时，避免CPU从一处存储拷贝到另一处存储。在Linux中，我们可以减少数据在内核空间和用户空间的来回拷贝实现，比如通过调用mmap()来代替read调用。</p>
<blockquote>
<p>用程序调用mmap()，磁盘上的数据会通过DMA被拷贝的内核缓冲区，接着操作系统会把这段内核缓冲区与应用程序共享，这样就不需要把内核缓冲区的内容往用户空间拷贝。应用程序再调用write(),操作系统直接将内核缓冲区的内容拷贝到socket缓冲区中，这一切都发生在内核态，最后，socket缓冲区再把数据发到网卡去。</p>
</blockquote>
<h4 id="35-介绍c所有的构造函数">（35） 介绍C++所有的构造函数</h4>
<p>C++中的构造函数主要有三种类型：默认构造函数、重载构造函数和拷贝构造函数</p>
<ul>
<li>默认构造函数是当类没有实现自己的构造函数时，编译器默认提供的一个构造函数。</li>
<li>重载构造函数也称为一般构造函数，一个类可以有多个重载构造函数，但是需要参数类型或个数不相同。可以在重载构造函数中自定义类的初始化方式。</li>
<li>拷贝构造函数是在发生对象复制的时候调用的。</li>
</ul>
<h4 id="36-什么情况下会调用拷贝构造函数三种情况">（36） 什么情况下会调用拷贝构造函数（三种情况）</h4>
<ul>
<li>
<p>对象以值传递的方式传入函数参数</p>
<blockquote>
<p>如 <code>void func(Dog dog){};</code></p>
</blockquote>
</li>
<li>
<p>对象以值传递的方式从函数返回</p>
<blockquote>
<p>如 <code>Dog func(){ Dog d; return d;}</code></p>
</blockquote>
</li>
<li>
<p>对象需要通过另外一个对象进行初始化</p>
</li>
</ul>
<p>详见：<a href="https://blog.csdn.net/lwbeyond/article/details/6202256">C++拷贝构造函数详解</a></p>
<h4 id="37-结构体内存对齐方式和为什么要进行内存对齐">（37） 结构体内存对齐方式和为什么要进行内存对齐？</h4>
<p>因为结构体的成员可以有不同的数据类型，所占的大小也不一样。同时，由于CPU读取数据是按块读取的，内存对齐可以使得CPU一次就可以将所需的数据读进来。</p>
<p>对齐规则：</p>
<ul>
<li>第一个成员在与结构体变量偏移量为0的地址</li>
<li>其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。</li>
<li>对齐数=编译器默认的一个对齐数 与 该成员大小的较小值。</li>
<li>linux 中默认为4</li>
<li>vs 中的默认值为8<br>
结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）</li>
</ul>
<h4 id="38-内存泄露的定义如何检测与避免">（38） 内存泄露的定义，如何检测与避免？</h4>
<p>动态分配内存所开辟的空间，在使用完毕后未手动释放，导致一直占据该内存，即为内存泄漏。</p>
<p>造成内存泄漏的几种原因：</p>
<p>1）类的构造函数和析构函数中new和delete没有配套</p>
<p>2）在释放对象数组时没有使用delete[]，使用了delete</p>
<p>3）没有将基类的析构函数定义为虚函数，当基类指针指向子类对象时，如果基类的析构函数不是virtual，那么子类的析构函数将不会被调用，子类的资源没有正确释放，因此造成内存泄露</p>
<p>4）没有正确的清楚嵌套的对象指针</p>
<p>避免方法：</p>
<ol>
<li>malloc/free要配套</li>
<li>使用智能指针；</li>
<li>将基类的析构函数设为虚函数；</li>
</ol>
<h4 id="39-c的智能指针有哪些">（39） C++的智能指针有哪些</h4>
<p>C++中的智能指针有auto_ptr,shared_ptr,weak_ptr和unique_ptr。智能指针其实是将指针进行了封装，可以像普通指针一样进行使用，同时可以自行进行释放，避免忘记释放指针指向的内存地址造成内存泄漏。</p>
<ul>
<li>auto_ptr是较早版本的智能指针，在进行指针拷贝和赋值的时候，新指针直接接管旧指针的资源并且将旧指针指向空，但是这种方式在需要访问旧指针的时候，就会出现问题。</li>
<li>unique_ptr是auto_ptr的一个改良版，不能赋值也不能拷贝，保证一个对象同一时间只有一个智能指针。</li>
<li>shared_ptr可以使得一个对象可以有多个智能指针，当这个对象所有的智能指针被销毁时就会自动进行回收。（内部使用计数机制进行维护）</li>
<li>weak_ptr是为了协助shared_ptr而出现的。它不能访问对象，只能观测shared_ptr的引用计数，防止出现死锁。</li>
</ul>
<h4 id="40-调试程序的方法">（40） 调试程序的方法</h4>
<ul>
<li>通过设置断点进行调试</li>
<li>打印log进行调试</li>
<li>打印中间结果进行调试</li>
</ul>
<h4 id="41-遇到coredump要怎么调试">（41） 遇到coredump要怎么调试</h4>
<p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
<ul>
<li>使用gdb命令对core文件进行调试</li>
</ul>
<p>以下例子在Linux上编写一段代码并导致segment fault 并产生core文件</p>
<pre><code>mkdir coredumpTest
vim coredumpTest.cpp
</code></pre>
<p>在编辑器内键入</p>
<pre><code>#include&lt;stdio.h&gt;
int main(){
    int i;
    scanf(&quot;%d&quot;,i);//正确的应该是&amp;i,这里使用i会导致segment fault
    printf(&quot;%d\n&quot;,i);
    return 0;
}
</code></pre>
<p>编译</p>
<pre><code>g++ coredumpTest.cpp -g -o coredumpTest
</code></pre>
<p>运行</p>
<pre><code>./coredumpTest
</code></pre>
<p>使用gdb调试coredump</p>
<pre><code>gdb [可执行文件名] [core文件名]
</code></pre>
<h4 id="42-inline关键字说一下-和宏定义有什么区别">（42） inline关键字说一下 和宏定义有什么区别</h4>
<p>inline是内联的意思，可以定义比较小的函数。因为函数频繁调用会占用很多的栈空间，进行入栈出栈操作也耗费计算资源，所以可以用inline关键字修饰频繁调用的小函数。编译器会在编译阶段将代码体嵌入内联函数的调用语句块中。</p>
<p>1、内联函数在编译时展开，而宏在预编译时展开</p>
<p>2、在编译的时候，内联函数直接被嵌入到目标代码中去，而宏只是一个简单的文本替换。</p>
<p>3、内联函数可以进行诸如类型安全检查、语句是否正确等编译功能，宏不具有这样的功能。</p>
<p>4、宏不是函数，而inline是函数</p>
<p>5、宏在定义时要小心处理宏参数，一般用括号括起来，否则容易出现二义性。而内联函数不会出现二义性。</p>
<p>6、inline可以不展开，宏一定要展开。因为inline指示对编译器来说，只是一个建议，编译器可以选择忽略该建议，不对该函数进行展开。</p>
<p>7、宏定义在形式上类似于一个函数，但在使用它时，仅仅只是做预处理器符号表中的简单替换，因此它不能进行参数有效性的检测，也就不能享受C++编译器严格类型检查的好处，另外它的返回值也不能被强制转换为可转换的合适的类型，这样，它的使用就存在着一系列的隐患和局限性。</p>
<h4 id="43-模板的用法与适用场景-实现原理">（43） 模板的用法与适用场景 实现原理</h4>
<p>用template &lt;typename T&gt;关键字进行声明，接下来就可以进行模板函数和模板类的编写了</p>
<p>编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，这次编译只会进行一个语法检查，并不会生成具体的代码。在运行时对代码进行参数替换后再进行编译，生成具体的函数代码。</p>
<h4 id="44-成员初始化列表的概念为什么用成员初始化列表会快一些性能优势">（44） 成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？</h4>
<p>成员初始化列表就是在类或者结构体的构造函数中，在参数列表后以冒号开头，逗号进行分隔的一系列初始化字段。如下：</p>
<pre><code>class A{
int id;
string name;
FaceImage face;
A(int&amp; inputID,string&amp; inputName,FaceImage&amp; inputFace):id(inputID),name(inputName),face(inputFace){} // 成员初始化列表
};
</code></pre>
<p>因为使用成员初始化列表进行初始化的话，会直接使用传入参数的拷贝构造函数进行初始化，省去了一次执行传入参数的默认构造函数的过程，否则会调用一次传入参数的默认构造函数。所以使用成员初始化列表效率会高一些。<br><br>
另外，有三种情况是必须使用成员初始化列表进行初始化的：</p>
<ul>
<li>常量成员的初始化，因为常量成员只能初始化不能赋值</li>
<li>引用类型</li>
<li>没有默认构造函数的对象必须使用成员初始化列表的方式进行初始化</li>
</ul>
<p>详见<a href="https://www.cnblogs.com/graphics/archive/2010/07/04/1770900.html">C++ 初始化列表</a></p>
<h4 id="45-用过c11吗知道c11新特性吗有面试官建议熟悉c11">（45） 用过C11吗，知道C11新特性吗？（有面试官建议熟悉C11）</h4>
<ul>
<li>
<p>自动类型推导auto：auto的自动类型推导用于从初始化表达式中推断出变量的数据类型。通过auto的自动类型推导，可以大大简化我们的编程工作</p>
</li>
<li>
<p>nullptr<br>
：nullptr是为了解决原来C++中NULL的二义性问题而引进的一种新的类型，因为NULL实际上代表的是0，而nullptr是void*类型的</p>
</li>
<li>
<p>lambda表达式：它类似Javascript中的闭包，它可以用于创建并定义匿名的函数对象，以简化编程工作。Lambda的语法如下：<br>
<code>[函数对象参数](操作符重载函数参数)mutable或exception声明-&gt;返回值类型{函数体}</code></p>
</li>
<li>
<p>thread类和mutex类</p>
</li>
<li>
<p>新的智能指针 unique_ptr和shared_ptr</p>
</li>
<li>
<p>更多详见：https://blog.csdn.net/caogenwangbaoqiang/article/details/79438279</p>
</li>
</ul>
<h4 id="46-c的调用惯例简单一点c函数调用的压栈过程">（46） C++的调用惯例（简单一点C++函数调用的压栈过程）</h4>
<p>函数的调用过程：</p>
<p>1）从栈空间分配存储空间</p>
<p>2）从实参的存储空间复制值到形参栈空间</p>
<p>3）进行运算</p>
<p>形参在函数未调用之前都是没有分配存储空间的，在函数调用结束之后，形参弹出栈空间，清除形参空间。</p>
<p>数组作为参数的函数调用方式是地址传递，形参和实参都指向相同的内存空间，调用完成后，形参指针被销毁，但是所指向的内存空间依然存在，不能也不会被销毁。</p>
<p>当函数有多个返回值的时候，不能用普通的 return 的方式实现，需要通过传回地址的形式进行，即地址/指针传递。</p>
<h4 id="47-c的四种强制转换">（47） C++的四种强制转换</h4>
<p>四种强制类型转换操作符分别为：static_cast、dynamic_cast、const_cast、reinterpret_cast</p>
<ul>
<li>
<p>1）static_cast ：<br>
用于各种隐式转换。具体的说，就是用户各种基本数据类型之间的转换，比如把int换成char，float换成int等。以及派生类（子类）的指针转换成基类（父类）指针的转换。</p>
<blockquote>
<p>特性与要点：</p>
<ol>
<li>它没有运行时类型检查，所以是有安全隐患的。</li>
<li>在派生类指针转换到基类指针时，是没有任何问题的，在基类指针转换到派生类指针的时候，会有安全问题。</li>
<li>static_cast不能转换const，volatile等属性</li>
</ol>
</blockquote>
</li>
<li>
<p>2）dynamic_cast：<br>
用于动态类型转换。具体的说，就是在基类指针到派生类指针，或者派生类到基类指针的转换。<br>
dynamic_cast能够提供运行时类型检查，只用于含有虚函数的类。<br>
dynamic_cast如果不能转换返回NULL。</p>
</li>
<li>
<p>3）const_cast：<br>
用于去除const常量属性，使其可以修改 ，也就是说，原本定义为const的变量在定义后就不能进行修改的，但是使用const_cast操作之后，可以通过这个指针或变量进行修改; 另外还有volatile属性的转换。</p>
</li>
<li>
<p>4）reinterpret_cast<br>
几乎什么都可以转，用在任意的指针之间的转换，引用之间的转换，指针和足够大的int型之间的转换，整数到指针的转换等。但是不够安全。</p>
</li>
</ul>
<h4 id="48string的底层实现">（48）string的底层实现</h4>
<p>string继承自basic_string,其实是对char*进行了封装，封装的string包含了char*数组，容量，长度等等属性。</p>
<p>string可以进行动态扩展，在每次扩展的时候另外申请一块原空间大小两倍的空间（2^n），然后将原字符串拷贝过去，并加上新增的内容。</p>
<h4 id="49一个函数或者可执行文件的生成过程或者编译过程是怎样的">（49）一个函数或者可执行文件的生成过程或者编译过程是怎样的</h4>
<p>预处理，编译，汇编，链接</p>
<ul>
<li>预处理： 对预处理命令进行替换等预处理操作</li>
<li>编译：代码优化和生成汇编代码</li>
<li>汇编：将汇编代码转化为机器语言</li>
<li>链接：将目标文件彼此链接起来</li>
</ul>
<h4 id="50setmap和vector的插入复杂度">（50）set，map和vector的插入复杂度</h4>
<p>set,map的插入复杂度就是红黑树的插入复杂度，是log(N)。</p>
<p>unordered_set,unordered_map的插入复杂度是常数，最坏是O(N).</p>
<p>vector的插入复杂度是O(N),最坏的情况下（从头插入）就要对所有其他元素进行移动，或者扩容重新拷贝</p>
<h4 id="51定义和声明的区别">（51）定义和声明的区别</h4>
<ul>
<li>
<p>声明是告诉编译器变量的类型和名字，不会为变量分配空间</p>
</li>
<li>
<p>定义就是对这个变量和函数进行内存分配和初始化。需要分配空间，同一个变量可以被声明多次，但是只能被定义一次</p>
</li>
</ul>
<h4 id="52typdef和define区别">（52）typdef和define区别</h4>
<p>#define是预处理命令，在预处理是执行简单的替换，不做正确性的检查</p>
<p>typedef是在编译时处理的，它是在自己的作用域内给已经存在的类型一个别名</p>
<h4 id="53被free回收的内存是立即返还给操作系统吗为什么">（53）被free回收的内存是立即返还给操作系统吗？为什么</h4>
<p>https://blog.csdn.net/YMY_mine/article/details/81180168</p>
<p>不是的，被free回收的内存会首先被ptmalloc使用双链表保存起来，当用户下一次申请内存的时候，会尝试从这些内存中寻找合适的返回。这样就避免了频繁的系统调用，占用过多的系统资源。同时ptmalloc也会尝试对小块内存进行合并，避免过多的内存碎片。</p>
<h4 id="54引用作为函数参数以及返回值的好处">（54）引用作为函数参数以及返回值的好处</h4>
<p>对比值传递，引用传参的好处：</p>
<p>1）在函数内部可以对此参数进行修改</p>
<p>2）提高函数调用和运行的效率（因为没有了传值和生成副本的时间和空间消耗）</p>
<p>如果函数的参数实质就是形参，不过这个形参的作用域只是在函数体内部，也就是说实参和形参是两个不同的东西，要想形参代替实参，肯定有一个值的传递。函数调用时，值的传递机制是通过“形参=实参”来对形参赋值达到传值目的，产生了一个实参的副本。即使函数内部有对参数的修改，也只是针对形参，也就是那个副本，实参不会有任何更改。函数一旦结束，形参生命也宣告终结，做出的修改一样没对任何变量产生影响。</p>
<p>用引用作为返回值最大的好处就是在内存中不产生被返回值的副本。</p>
<p>但是有以下的限制：</p>
<p>1）不能返回局部变量的引用。因为函数返回以后局部变量就会被销毁</p>
<p>2）不能返回函数内部new分配的内存的引用。虽然不存在局部变量的被动销毁问题，可对于这种情况（返回函数内部new分配内存的引用），又面临其它尴尬局面。例如，被函数返回的引用只是作为一 个临时变量出现，而没有被赋予一个实际的变量，那么这个引用所指向的空间（由new分配）就无法释放，造成memory leak</p>
<p>3）可以返回类成员的引用，但是最好是const。因为如果其他对象可以获得该属性的非常量的引用，那么对该属性的单纯赋值就会破坏业务规则的完整性。</p>
<h4 id="55友元函数和友元类">（55）友元函数和友元类</h4>
<p>https://www.cnblogs.com/zhuguanhao/p/6286145.html</p>
<p>友元提供了不同类的成员函数之间、类的成员函数和一般函数之间进行数据共享的机制。通过友元，一个不同函数或者另一个类中的成员函数可以访问类中的私有成员和保护成员。友元的正确使用能提高程序的运行效率，但同时也破坏了类的封装性和数据的隐藏性，导致程序可维护性变差。</p>
<p>1）友元函数</p>
<p>有元函数是定义在类外的普通函数，不属于任何类，可以访问其他类的私有成员。但是需要在类的定义中声明所有可以访问它的友元函数。</p>
<pre><code>#include &lt;iostream&gt;

using namespace std;

class A
{
public:
    friend void set_show(int x, A &amp;a);      //该函数是友元函数的声明
private:
    int data;
};

void set_show(int x, A &amp;a)  //友元函数定义，为了访问类A中的成员
{
    a.data = x;
    cout &lt;&lt; a.data &lt;&lt; endl;
}
int main(void)
{
    class A a;

    set_show(1, a);

    return 0;
}
</code></pre>
<p>一个函数可以是多个类的友元函数，但是每个类中都要声明这个函数。</p>
<p>2）友元类</p>
<p>友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。<br>
但是另一个类里面也要相应的进行声明</p>
<pre><code>#include &lt;iostream&gt;

using namespace std;

class A
{
public:
   friend class C;                         //这是友元类的声明
private:
   int data;
};

class C             //友元类定义，为了访问类A中的成员
{
public:
   void set_show(int x, A &amp;a) { a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;}
};

int main(void)
{
   class A a;
   class C c;

   c.set_show(1, a);

   return 0;
}
</code></pre>
<p>使用友元类时注意：</p>
<p>(1) 友元关系不能被继承。</p>
<p>(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。</p>
<p>(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</p>
<h5 id="56-说一下volatile关键字的作用">（56） 说一下volatile关键字的作用</h5>
<p>volatile的意思是“脆弱的”，表明它修饰的变量的值十分容易被改变，所以编译器就不会对这个变量进行优化（CPU的优化是让该变量存放到CPU寄存器而不是内存），进而提供稳定的访问。每次读取volatile的变量时，系统总是会从内存中读取这个变量，并且将它的值立刻保存。</p>
<h4 id="57-stl中的sort算法是用什么实现的stable_sort呢">（57） STL中的sort()算法是用什么实现的，stable_sort()呢</h4>
<p>STL中的sort是用快速排序和插入排序结合的方式实现的，stable_sort()是归并排序。</p>
<h4 id="58vector会迭代器失效吗什么情况下会迭代器失效">（58）vector会迭代器失效吗？什么情况下会迭代器失效？</h4>
<p>https://www.cnblogs.com/qingjiaowoxiaoxioashou/p/5874572.html</p>
<ul>
<li>会</li>
<li>当vector在插入的时候，如果原来的空间不够，会将申请新的内存并将原来的元素移动到新的内存，此时指向原内存地址的迭代器就失效了，first和end迭代器都失效</li>
<li>当vector在插入的时候，end迭代器肯定会失效</li>
<li>当vector在删除的时候，被删除元素以及它后面的所有元素迭代器都失效。</li>
</ul>
<h4 id="58为什么c没有实现垃圾回收">（58）为什么C++没有实现垃圾回收？</h4>
<ul>
<li>首先，实现一个垃圾回收器会带来额外的空间和时间开销。你需要开辟一定的空间保存指针的引用计数和对他们进行标记mark。然后需要单独开辟一个线程在空闲的时候进行free操作。</li>
<li>垃圾回收会使得C++不适合进行很多底层的操作。</li>
</ul>
<h1 id="2-计网相关">2. 计网相关</h1>
<h4 id="1-建立tcp服务器的各个系统调用">（1） 建立TCP服务器的各个系统调用</h4>
<p>建立TCP服务器连接的过程中主要通过以下系统调用序列来获取某些函数，这些系统调用主要包括：socket（），bind（），listen（），accept（），send（）和recv（）。<br>
详见：<a href="https://blog.csdn.net/qq_37964547/article/details/81429627">建立TCP 服务器的系统调用</a></p>
<h4 id="2-继上一题说明socket网络编程有哪些系统调用其中close是一次就能直接关闭的吗半关闭状态是怎么产生的">（2） 继上一题，说明socket网络编程有哪些系统调用？其中close是一次就能直接关闭的吗，半关闭状态是怎么产生的？</h4>
<pre><code>socket()    创建套接字   
bind()      绑定本机端口    
connect()   建立连接     （TCP三次握手在调用这个函数时进行）
listen()    监听端口
accept()    接受连接
recv(), read(), recvfrom()  数据接收
send(), write(), sendto()   数据发送
close(), shutdown() 关闭套接字
</code></pre>
<p>使用close()时，只有当套接字的引用计数为0的时候才会终止连接，而用shutdown()就可以直接关闭连接</p>
<p>详见：<a href="https://blog.csdn.net/junjun150013652/article/details/37994907">网络编程Socket之TCP之close/shutdown详解</a></p>
<p>TCP连接与断开详解： https://www.cnblogs.com/felixzh/p/8359066.html</p>
<h4 id="3-对路由协议的了解与介绍-内部网关协议igp包括ripospf和外部网关协议egp和bgp">（3） 对路由协议的了解与介绍。内部网关协议IGP包括RIP，OSPF，和外部网关协议EGP和BGP.</h4>
<ul>
<li>
<p>RIP“路由信息协议(Route Information Protocol)”的简写，主要传递路由信息，通过每隔30秒广播一次路由表，维护相邻路由器的位置关系，同时根据收到的路由表信息使用动态规划的方式计算自己的路由表信息。RIP是一个距离矢量路由协议,最大跳数为16跳,16跳以及超过16跳的网络则认为目标网络不可达。</p>
</li>
<li>
<p>OSPF：详见：https://zhuanlan.zhihu.com/p/41341540</p>
</li>
</ul>
<h4 id="4-udp如何实现可靠传输">（4） UDP如何实现可靠传输</h4>
<p>因为UDP是无连接的协议，所以在传输层上无法保证可靠传输，要想实现可靠传输，只能从应用层实现。需要实现seq/ack机制，重传机制和窗口确认机制。</p>
<p>就要接收方收到UDP之后回复个确认包，发送方有个机制，收不到确认包就要重新发送，每个包有递增的序号，接收方发现中间丢了包就要发重传请求，当网络太差时候频繁丢包，防止越丢包越重传的恶性循环，要有个发送窗口的限制，发送窗口的大小根据网络传输情况调整，调整算法要有一定自适应性。</p>
<p>作者：姚冬<br>
链接：https://www.zhihu.com/question/283995548/answer/661809748<br>
来源：知乎<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<h4 id="5-tcp和udp的区别">（5） TCP和UDP的区别</h4>
<ul>
<li>TCP是面向连接的协议，提供的是可靠传输，在收发数据前需要通过三次握手建立连接，使用ACK对收发的数据进行正确性检验。而UDP是无连接的协议，不管对方有没有收到或者收到的数据是否正确。</li>
<li>TCP提供流量控制和拥塞控制，而UDP没有。</li>
<li>TCP对系统资源的要求高于UDP，所以速度也比UDP慢。</li>
<li>TCP数据包是没有边界的，会出现粘包的问题，UDP包是独立的，不会出现粘包问题。</li>
<li>所以在应用方面，如果强调数据的完整性和正确性用TCP，当要求性能和速度的时候，使用UDP更加合适。</li>
</ul>
<p>注：单凭TCP是不能保证完整性的，要是有黑客伪造TCP包，是无法识别的。</p>
<h4 id="6-tcp和udp相关的协议与端口号">（6） TCP和UDP相关的协议与端口号</h4>
<p>TCP族的协议有HTTP，HTTPS，SMTP，TelNet，FTP等，UDP族的协议有DNS，DHCP等等。<br>
详见：https://blog.csdn.net/qq_22080999/article/details/81105051</p>
<h4 id="7-tcpudpip等首部的认识http请求报文构成">（7） TCP（UDP，IP）等首部的认识（http请求报文构成）</h4>
<p>TCP的头部大致包括：源端口，目的端口，序号，确认号，偏移位，标志位，校验和等等</p>
<p>UDP的头部则包括：源端口，目的端口，长度，校验和。</p>
<p>IP数据包的头部包括：源IP地址，目的IP地址，协议，校验和，总长度等等</p>
<p>详见：https://blog.csdn.net/zhangliangzi/article/details/52554439</p>
<h4 id="8-网页解析的过程与实现方法">（8） 网页解析的过程与实现方法</h4>
<p>这里仅展示浏览器解析服务器响应的过程，URL解析和交互的完整过程在(9)</p>
<ul>
<li>首先是html文档解析，浏览器会将html文档生成解析树，也就是DOM树，它由dom元素以及属性节点组成。</li>
<li>然后浏览器加载过程中如果遇到了外部css文件或者图片资源，还会另外发送请求来获取css文件和资源，这个请求通常是异步的，不会影响html文档的加载。</li>
<li>不过如果浏览器在加载时遇到了js文件，则会挂起渲染的线程，等待js文件加载解析完毕才恢复html的渲染线程。</li>
<li>然后是css解析，将css文件解析为样式表对象来渲染DOM树。</li>
</ul>
<h4 id="9-在浏览器中输入url后执行的全部过程如wwwbaiducom">（9）    在浏览器中输入URL后执行的全部过程（如www.baidu.com）</h4>
<ol>
<li>首先是域名解析，客户端使用DNS协议将URL解析为对应的IP地址；</li>
<li>然后建立TCP连接，客户端与服务器通过三次握手建立TCP连接；</li>
<li>接着是http连接，客户端向服务器发送http连接请求； （http连接无需额外连接，直接通过已经建立的TCP连接发送）</li>
<li>服务器对客户端发来的http请求进行处理，并返回响应；</li>
<li>客户端接收到http响应，将结果渲染展示给用户。</li>
</ol>
<h4 id="10-网络层分片的原因与具体实现">（10） 网络层分片的原因与具体实现</h4>
<p>因为在链路层中帧的大小通常都有限制，比如在以太网中帧的最大大小（MTU）就是1500字节。如果IP数据包加上头部后大小超过1500字节，就需要分片。</p>
<p>IP分片和完整IP报文差不多拥有相同的IP头，16位ID域对于每个分片都是一致的，这样才能在重新组装的时候识别出来自同一个IP报文的分片。在IP头里面，16位识别号唯一记录了一个IP包的ID，具有同一个ID的IP分片将会重新组装；而13位片偏移则记录了某IP片相对整个包的位置；而这两个表中间的3位标志则标志着该分片后面是否还有新的分片。这三个标志就组成了IP分片的所有信息(将在后面介绍)，接受方就可以利用这些信息对IP数据进行重新组织。<br>
详见：https://blog.csdn.net/gettogetto/article/details/72851734</p>
<h4 id="11-tcp的三次握手与四次挥手的详细介绍tcp连接建立与断开是热门问题">（11） TCP的三次握手与四次挥手的详细介绍（TCP连接建立与断开是热门问题）</h4>
<ul>
<li>三次握手</li>
</ul>
<p>第一次握手：首先client给server发送连接请求报文，在这个报文中，包含了SYN=1，client_seq=任意值i，发送之后处于SYN-SENT状态，这是第一次握手</p>
<p>第二次握手：server端接收到了这个请求，并分配资源，同时给client返回一个ACK报文，这个报文中呢包含了这些字段，标志位SYN和ACK都为1，而小ack为i+1，此时位于SYN-RCVD状态，这是第二次握手</p>
<p>第三次握手：client收到server发来的ACK信息后呢，他会看到server发过来的小ack是i+1，这时他知道了server收到了消息，也给server回一个ACK报文，报文中同样包含了ACK=1这样的消息，同时呢，还包括了client_ack=k+1这样的字段，这样呢三次握手之后，连接就建立了，client进入established（已建立连接）状态<br>
<img src="fig/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="三次握手.png" loading="lazy"></p>
<ul>
<li>四次挥手断开连接：</li>
</ul>
<p>TCP断开连接通常是由一方主动，一方被动的，这里我们假设client主动，server被动<br>
第一次挥手：当client没有数据要发送给server了，他会给server发送一个FIN报文，告诉server：“我已经没有数据要发给你了，但是你要是还想给我发数据的话，你就接着发，但是你得告诉我你收到我的关闭信息了”，这是第一次挥手，挥手之后client进入FIN_WAIT_1的第一阶段</p>
<p>第二次挥手：当server收到client发来的FIN报文后，告诉client：“我收到你的FIN消息了，但是你等我发完的”此时给client返回一个ACK信息，并且呢ack=seq+1，这是第二次挥手，挥手之后呢server进入CLOSE_WAIT阶段，而client收到之后处于FIN_WAIT_2第二阶段</p>
<p>第三次挥手：当server发完所有数据时，他会给client发送一个FIN报文，告诉client说“我传完数据了，现在要关闭连接了”，然后呢server变成LAST_ACK状态，等着client最后的ACK信息，这是第三次挥手</p>
<p>第四次挥手：当client收到这个FIN报文时，他会对这个消息进行确认，即给server发ACK信息，但是它不相信网络，怕server收不到信息，它会进入TIME_WAIT状态，万一server没收到ACK消息它可以可以重传，而当server收到这个ACK信息后，就正式关闭了tcp连接，处于CLOSED状态，而client等待了2MSL这样长时间后还没等到消息，它知道server已经关闭连接了，于是乎他自己也断开了，这是第四次挥手，这样tcp连接就断开了<br>
<img src="fig/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png" alt="fig/四次挥手.png" loading="lazy"></p>
<h4 id="12-tcp握手以及每一次握手客户端和服务器端处于哪个状态">（12） TCP握手以及每一次握手客户端和服务器端处于哪个状态</h4>
<p>见上</p>
<h4 id="13-为什么使用三次握手两次握手可不可以">（13） 为什么使用三次握手，两次握手可不可以？</h4>
<p>如果使用两次握手的话，三次握手中的最后一次缺失，服务器不能确认客户端的接收能力。</p>
<p>举两个例子，第一种是黑客会伪造大量SYN请求发送给服务器，服务器立即确认并建立连接，分配资源，但是这一系列连接并不是真实存在的，这大大浪费了服务器的资源并且阻塞了正常用户的连接，这种也叫SYN洪泛攻击。第二种是服务器返回给客户端的ACK数据包可能会在传输的过程中丢失，而客户端没有收到该ACK数据包而拒绝接收服务器接下来发送的数据，于是服务器一直在发送，客户端一直在拒绝，形成死锁。</p>
<h4 id="14-time_wait的意义为什么要等于2msl">（14） TIME_WAIT的意义（为什么要等于2MSL）</h4>
<p>TIME_WAIT是指四次挥手中客户端接收了服务端的FIN报文并发送ACK报文给服务器后，仍然需要等待2MSL时间的过程。虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可以最后一个ACK丢失。如果客户端发送的ACK发生丢失，服务器会再次发送FIN报文给客户端，所以TIME_WAIT状态就是用来重发可能丢失的ACK报文。</p>
<h4 id="15-超时重传机制不太高频">（15） 超时重传机制（不太高频）</h4>
<h4 id="16-tcp怎么保证可靠性">（16） TCP怎么保证可靠性？</h4>
<p><strong>（校序重流拥）</strong></p>
<ul>
<li>
<p>校验和<br>
发送的数据包的二进制相加然后取反，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到此报文段。</p>
</li>
<li>
<p>确认应答+序列号<br>
TCP给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p>
</li>
<li>
<p>超时重传<br>
当TCP发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
</li>
<li>
<p>流量控制<br>
TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。<br>
接收方有即时窗口（滑动窗口），随ACK报文发送</p>
</li>
<li>
<p>拥塞控制<br>
当网络拥塞时，减少数据的发送。<br>
发送方有拥塞窗口，发送数据前比对接收方发过来的即使窗口，取小</p>
</li>
</ul>
<p>慢启动、拥塞避免、快速重传、快速恢复</p>
<h4 id="17-流量控制的介绍采用滑动窗口会有什么问题死锁可能糊涂窗口综合征">（17） 流量控制的介绍，采用滑动窗口会有什么问题（死锁可能，糊涂窗口综合征）？</h4>
<p>所谓流量控制就是让发送方发送速率不要过快，让接收方来得及接收。利用TCP报文段中的窗口大小字段来控制发送方的发送窗口不大于接收方发回的窗口大小就可以实施流量控制。</p>
<p>考虑一种特殊的情况，就是接收方若没有缓存足够使用，就会发送零窗口大小的报文，此时发送放将发送窗口设置为0，停止发送数据。之后接收方有足够的缓存，发送了非零窗口大小的报文，但是这个报文在中途丢失的，那么发送方的发送窗口就一直为零导致死锁。</p>
<p>解决这个问题，TCP为每一个连接设置一个持续计时器（persistence timer）。只要TCP的一方收到对方的零窗口通知，就启动该计时器，周期性的发送一个零窗口探测报文段。对方就在确认这个报文的时候给出现在的窗口大小（注意：TCP规定，即使设置为零窗口，也必须接收以下几种报文段：零窗口探测报文段、确认报文段和携带紧急数据的报文段）。</p>
<h4 id="18-tcp滑动窗口协议">（18） tcp滑动窗口协议</h4>
<p>详见 <a href="https://blog.csdn.net/wdscq1234/article/details/52444277">TCP-IP详解：滑动窗口SlidingWindow</a>和<a href="https://www.cnblogs.com/alifpga/p/7675850.html">TCP滑动窗口</a></p>
<p>TCP的滑动窗口用来控制接收方和发送方的发送速率，避免拥塞的发生。滑动窗口其实就是接收端的缓冲区大小，用来告诉发送方对它发送的数据有多大的缓冲空间。在接收方的滑动窗口已知的情况下，当接收方确认了连续的数据序列之后，发送方的滑动窗口向后滑动，发送下一个数据序列。</p>
<p>接收方会在每个ACK数据包中附带自己当前的接受窗口（滑动窗口）的大小，方便发送方进行控制。</p>
<h4 id="19-拥塞控制和流量控制的区别">（19） 拥塞控制和流量控制的区别</h4>
<p>拥塞控制是防止过多的数据注入到网络中，导致网络发生拥塞；而流量控制是防止发送方一下子发送过多的数据到接收方，导致接收方缓存放不下。两种算法都是对发送方的行为进行控制的。</p>
<h4 id="20-tcp拥塞控制算法名字极其重要">（20） TCP拥塞控制，算法名字？（极其重要）</h4>
<p><img src="fig/%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6.png" alt="拥塞控制" loading="lazy"><br>
防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载，拥塞控制自然也是控制发送者的流量，拥塞控制有四种算法，<strong>慢启动、拥塞避免，快速重传和快速恢复</strong></p>
<p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞窗口和接受窗口的较小值。</p>
<p>（1）<strong>慢启动</strong>。慢启动算法的思路是当主机开始发送数据时，先以比较小的拥塞窗口进行发送，然后每次翻倍，也就是说，由小到大逐渐增加拥塞窗口的大小，而这个大小是指数增长的，即1、2、4、8、16<br>
*为了防止拥塞窗口cwnd增长过大引起网络拥塞，还要另外设置一个慢启动阈值ssthresh状态变量，当拥塞窗口的大小超过慢启动阈值的时候（ cwnd &gt; ssthresh 时），停止使用慢开始算法而改用拥塞避免算法</p>
<p>（2）<strong>拥塞避免</strong>。拥塞避免算法的思路是让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。</p>
<p>（3）<strong>快速重传</strong>。当发送端连续收到三个重复的ack时，表示该数据段已经丢失，需要重发。此时慢启动阈值ssth变为原来一半，拥塞窗口cwnd变为ssth+3，然后+1+1的发（每一轮rtt+1）</p>
<p>（4）<strong>快速恢复</strong>。当超过设定的时间没有收到某个报文段的ack时，表示网络拥塞，慢启动阈值ssth变为原来一半，拥塞窗口cwnd=1，进入慢启动阶段</p>
<h4 id="21-http协议与tcp的区别与联系">（21） http协议与TCP的区别与联系</h4>
<p>联系：Http协议是建立在TCP协议基础之上的，当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个到服务器的连接通道，当本次请求需要的数据传输完毕后，Http会立即将TCP连接断开，这个过程是很短的。</p>
<p>区别：HTTP和TCP位于不同的网络分层。TCP是传输层的协议，定义的是数据传输和连接的规范，而HTTP是应用层的，定义的是数据的内容的规范。<br>
建立一个TCP请求需要进行三次握手，而由于http是建立在tcp连接之上的，建立一个http请求通常包含请求和响应两个步骤。</p>
<h4 id="22-http10和http11的区别">（22） http/1.0和http/1.1的区别</h4>
<p>HTTP 协议老的标准是 HTTP/1.0 ，目前最通用的标准是 HTTP/1.1 。<br>
HTTP1.0 只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，但是最新的http/1.0加入了长连接，只需要在客户端给服务器发送的http报文头部加入Connection:keep-alive<br>
HTTP 1.1 支持持久连接，默认进行持久连接，在一个 TCP 连接上可以传送多个 HTTP 请求和响应，减少了建立和关闭连接的消耗和延迟。</p>
<h4 id="23-http的请求方法有哪些get和post的区别">（23） http的请求方法有哪些？get和post的区别。</h4>
<p>HTTP的请求方法包括GET，POST，PUT，DELETE四种基本方法。（四种方法中只有POST不是操作幂等性的）</p>
<p>get和post的区别：</p>
<ol>
<li>get方法不会修改服务器上的资源，它的查询是没有副作用的，而post有可能会修改服务器上的资源</li>
<li>get可以保存为书签，可以用缓存来优化，而post不可以</li>
<li>get把请求附在url上，而post把参数附在http包的包体中</li>
<li>浏览器和服务器一般对get方法所提交的url长度有限制，一般是1k或者2k，而对post方法所传输的参数大小限制为80k到4M不等</li>
<li>post可以传输二进制编码的信息，get的参数一般只支持ASCII</li>
</ol>
<h4 id="24-http的状态码-403-201等等是什么意思">（24） http的状态码 403 201等等是什么意思</h4>
<p>详见 <a href="https://blog.csdn.net/u011630575/article/details/46636535">HTTP状态码的含义</a></p>
<p>常见的状态码有：</p>
<blockquote>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
<li>400 - 请求无效</li>
<li>403 - 禁止访问</li>
</ul>
</blockquote>
<h4 id="25-http和https的区别由http升级为https需要做哪些操作">（25） http和https的区别，由http升级为https需要做哪些操作</h4>
<p>http 是超文本传输协议，信息是明文传输， https 则是具有安全性的 ssl 加密传输协议<br>
http 和 https 使用的是完全不同的连接方式，用的端口也不一样，前者是 80 ，后者是 443<br>
http 的连接很简单，是无状态的； HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比http 协议安全。<br>
https 协议需要到 ca 申请证书，一般免费证书较少，因而需要一定费用<br>
https://www.cnblogs.com/wqhwe/p/5407468.html</p>
<h4 id="26-https的具体实现怎么确保安全性">（26） https的具体实现，怎么确保安全性</h4>
<p><strong>SSL是传输层的协议</strong></p>
<p>https包括非对称加密和对称加密两个阶段，在客户端与服务器建立连接的时候使用非对称加密，连接建立以后使用的是对称加密。</p>
<ol>
<li>客户使用https的URL访问Web服务器，要求与Web服务器建立SSL连接</li>
<li>Web服务器收到客户端请求后，会将网站的公钥传送一份给客户端，私钥自己保存。</li>
<li>客户端的浏览器根据双方同意的安全等级，生成对称加密使用的密钥，称为会话密钥，然后利用网站的公钥将会话密钥加密，并传送给网站</li>
<li>Web服务器利用自己的私钥解密出会话密钥。</li>
<li>Web服务器利用会话密钥加密与客户端之间的通信，这个过程是对称加密的过程。</li>
</ol>
<p>服务器第一次传给客户端的公钥其实是CA对网站信息进行加密的数字证书</p>
<p>客户端的对称加密密钥其实是三个随机数的哈希（1. 客户端第一次给服务端发送请求时附带的随机数 2. 服务器返回时的随机数 3. 客户端收到返回时的随机数）</p>
<h4 id="27-tcp三次握手时的第一次的seq序号是怎样产生的">（27） TCP三次握手时的第一次的seq序号是怎样产生的</h4>
<p>第一次的序号是随机序号，但也不是完全随机，它是使用一个ISN算法得到的。</p>
<p>seq = C + H (源IP地址，目的IP地址，源端口，目的端口)。其中，C是一个计时器，每隔一段时间值就会变大，H是消息摘要算法，输入是一个四元组（源IP地址，目的IP地址，源端口，目的端口）。</p>
<h4 id="28-一个机器能够使用的端口号上限是多少为什么可以改变吗那如果想要用的端口超过这个限制怎么办">（28） 一个机器能够使用的端口号上限是多少，为什么？可以改变吗？那如果想要用的端口超过这个限制怎么办？</h4>
<p>65536.因为TCP的报文头部中源端口号和目的端口号的长度是16位，也就是可以表示2^16=65536个不同端口号，因此TCP可供识别的端口号最多只有65536个。但是由于0到1023是知名服务端口，所以实际上还要少1024个端口号。</p>
<p>而对于服务器来说，可以开的端口号与65536无关，其实是受限于Linux可以打开的文件数量，并且可以通过MaxUserPort来进行配置。</p>
<h4 id="29-对称密码和非对称密码体系">（29） 对称密码和非对称密码体系</h4>
<p>https://blog.csdn.net/qq_29689487/article/details/81634057</p>
<ul>
<li>对称加密：加密和解密使用的密钥是同一个
<ul>
<li>优点：计算量小，算法速度快，加密效率高  缺点：密钥容易泄漏。不同的会话需要不同的密钥，管理起来很费劲</li>
<li>常用算法：DES，3DES，IDEA，CR4，CR5，CR6，AES</li>
</ul>
</li>
<li>非对称加密：需要公钥和私钥，公钥用来加密，私钥用来解密
<ul>
<li>优点：安全，不怕泄漏  缺点：速度慢</li>
<li>常用算法：RSA，ECC，DSA</li>
</ul>
</li>
</ul>
<h4 id="30-数字证书的了解高频">（30） 数字证书的了解（高频）</h4>
<figure data-type="image" tabindex="1"><img src="fig/%E6%95%B0%E5%AD%97%E8%AF%81%E4%B9%A6.jpg" alt="fig/数字证书.jpg" loading="lazy"></figure>
<p>权威CA使用私钥将网站A的信息和消息摘要（签名S）进行加密打包形成数字证书。公钥给客户端。</p>
<p>网站A将自己的信息和数字证书发给客户端，客户端用CA的公钥对数字证书进行解密，得到签名S，与手动将网站的信息进行消息摘要得到的结果S*进行对比，如果签名一致就证明网站A可以信任。</p>
<h4 id="31-服务器出现大量close_wait的连接的原因以及解决方法">（31） 服务器出现大量close_wait的连接的原因以及解决方法</h4>
<p>close_wait状态是在TCP四次挥手的时候收到FIN但是没有发送自己的FIN时出现的，服务器出现大量close_wait状态的原因有两种：</p>
<ul>
<li>服务器内部业务处理占用了过多时间，都没能处理完业务；或者还有数据需要发送；或者服务器的业务逻辑有问题，没有执行close()方法</li>
<li>服务器的父进程派生出子进程，子进程继承了socket，收到FIN的时候子进程处理但父进程没有处理该信号，导致socket的引用不为0无法回收</li>
</ul>
<p>处理方法：</p>
<ul>
<li>停止应用程序</li>
<li>修改程序里的bug</li>
</ul>
<h4 id="32-消息摘要算法列举一下介绍md5算法为什么md5是不可逆的有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢百度安全一面">（32） 消息摘要算法列举一下，介绍MD5算法，为什么MD5是不可逆的，有什么办法可以加强消息摘要算法的安全性让它不那么容易被破解呢？（百度安全一面）</h4>
<ul>
<li>
<p>消息摘要算法有MD家族（MD2，MD4，MD5），SHA家族（SHA-1,SHA-256）和CRC家族（CRC8,CRC16,CRC32）等等</p>
</li>
<li>
<p>MD5算法介绍：<br>
MD5以512位分组来处理输入的信息，且每一分组又被划分为若干个小分组（16个32位子分组），经过一些列的处理后，算法输出由四个散列值（32位分组组成的128位散列值。）</p>
</li>
</ul>
<ol>
<li>MD5首先将输入的信息分成若干个512字节长度的分组，如果不够就填充1和若干个0。</li>
<li>对每个512字节的分组进行循环运算。使用四个幻数对第一个分组的数据进行四轮变换，得到四个变量。</li>
<li>接下来对其中三个使用线性函数进行计算，与剩下一个相加，并赋值给其中某个变量，得到新的四个变量，重复16次这个过程，得到的四个变量作为幻数，与下一个分组进行相似的计算。</li>
<li>遍历所有分组后得到的四个变量即为结果。</li>
</ol>
<p>详见：https://blog.csdn.net/weixin_39640298/article/details/84555814</p>
<ul>
<li>
<p>为什么不可逆：因为MD5在进行消息摘要的过程中，数据与原始数据相比发生了丢失，所以不能由结果进行恢复。</p>
</li>
<li>
<p>加强安全性：加盐（加随机数）</p>
</li>
</ul>
<h4 id="33-单条记录高并发访问的优化">（33） 单条记录高并发访问的优化</h4>
<p>服务器端：</p>
<ul>
<li>使用缓存，如redis等</li>
<li>使用分布式架构进行处理</li>
<li>将静态页面和静态资源存储在静态资源服务器，需要处理的数据使用服务器进行计算后返回</li>
<li>将静态资源尽可能在客户端进行缓存</li>
<li>采用ngnix进行负载均衡 （nginx读作恩静埃克斯 = Engine X）</li>
</ul>
<p>数据库端：</p>
<ul>
<li>数据库采用主从赋值，读写分离措施</li>
<li>建立适当的索引</li>
<li>分库分表</li>
</ul>
<h4 id="34-介绍一下ping的过程分别用到了哪些协议">（34） 介绍一下ping的过程，分别用到了哪些协议</h4>
<p>详见：<a href="https://www.cnblogs.com/Akagi201/archive/2012/03/26/2418475.html">Ping原理与ICMP协议</a></p>
<p>ping是使用ICMP协议来进行工作的。 ICMP:网络控制报文协议</p>
<ul>
<li>首先，ping命令会构建一个ICMP请求数据包，然后由ICMP协议将这个数据包连同目的IP地址源IP地址一起交给IP协议。</li>
<li>然后IP协议就会构建一个IP数据报，并且在映射表中查找目的IP对应的mac地址，将其交给数据链路层。</li>
<li>然后数据链路层就会构建一个数据帧，附上源mac地址和目的mac地址发送出去。</li>
</ul>
<p>目的主机接收到数据帧后，就会检查包上的mac地址与本机mac是否相符，如果相符，就接收并把其中的信息提取出来交给IP协议，IP协议就会将其中的信息提取出来交给ICMP协议。然后构建一个ICMP应答包，用相同的过程发送回去。</p>
<h4 id="35-tcpip的粘包与避免介绍一下">（35） TCP/IP的粘包与避免介绍一下</h4>
<p>因为TCP为了减少额外开销，采取的是流式传输，所以接收端在一次接收的时候有可能一次接收多个包。而TCP粘包就是发送方的若干个数据包到达接收方的时候粘成了一个包。多个包首尾相接，无法区分。</p>
<p>导致TCP粘包的原因有三方面：</p>
<ul>
<li>发送端等待缓冲区满才进行发送，造成粘包</li>
<li>接收方来不及接收缓冲区内的数据，造成粘包</li>
<li>由于TCP协议在发送较小的数据包的时候，会将几个包合成一个包后发送</li>
</ul>
<p>避免粘包的措施：</p>
<ul>
<li>通过编程，强制使TCP发生数据传送，不必等到缓冲区满</li>
<li>优化接收方接收数据的过程，使其来得及接收数据包，包括提高接收进程优先级等</li>
<li>设置固定长度的报文或者设置报文头部指示报文的长度。</li>
</ul>
<h4 id="36-说一下tcp的封包和拆包">（36） 说一下TCP的封包和拆包</h4>
<p>因为TCP是无边界的流传输，所以需要对TCP进行封包和拆包，确保发送和接收的数据不粘连。</p>
<ul>
<li>封包：封包就是在发送数据报的时候为每个TCP数据包加上一个包头，将数据报分为包头和包体两个部分。包头是一个固定长度的结构体，里面包含该数据包的总长度。</li>
<li>拆包：接收方在接收到报文后提取包头中的长度信息进行截取。</li>
</ul>
<h4 id="37-一个ip配置多个域名靠什么识别">（37） 一个ip配置多个域名，靠什么识别？</h4>
<ul>
<li>靠host主机名区分</li>
<li>靠端口号区分</li>
</ul>
<h4 id="38-服务器攻击ddos攻击">（38） 服务器攻击（DDos攻击）</h4>
<h4 id="39dns的工作过程和原理">（39）DNS的工作过程和原理</h4>
<p><img src="fig/DNS%E6%9F%A5%E8%AF%A2%E5%9B%BE%E8%A7%A3.png" alt="" loading="lazy"><br>
DNS解析有两种方式：递归查询和迭代查询</p>
<ul>
<li>递归查询 用户先向本地域名服务器查询，如果本地域名服务器的缓存没有IP地址映射记录，就向根域名服务器查询，根域名服务器就会向顶级域名服务器查询，顶级域名服务器向权限域名服务器查询，查到结果后依次返回。</li>
<li>迭代查询 用户向本地域名服务器查询，如果没有缓存，本地域名服务器会向根域名服务器查询，根域名服务器返回顶级域名服务器的地址，本地域名服务器再向顶级域名服务器查询，得到权限域名服务器的地址，本地域名服务器再向权限域名服务器查询得到结果</li>
</ul>
<h4 id="41osa七层协议和五层协议分别有哪些">（41）OSA七层协议和五层协议，分别有哪些</h4>
<p>OSI七层协议模型主要是：应用层（Application）、表示层（Presentation）、会话层（Session）、传输层（Transport）、网络层（Network）、数据链路层（Data Link）、物理层（Physical）。</p>
<p>五层体系结构包括：应用层、传输层、网络层、数据链路层和物理层。</p>
<figure data-type="image" tabindex="2"><img src="fig/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%E5%B1%82.png" alt="(fig/网络协议层.png" loading="lazy"></figure>
<h4 id="42ip寻址和mac寻址有什么不同怎么实现的">（42）IP寻址和MAC寻址有什么不同，怎么实现的</h4>
<p>通过MAC地址寻找主机是MAC地址寻址，通过IP地址寻找主机叫IP地址寻址。它们适用于不同的协议层，IP寻址是网络层，Mac寻址是数据链路层。</p>
<p>http://c.biancheng.net/view/6388.html</p>
<p>https://blog.csdn.net/wxy_nick/article/details/9190693</p>
<p>IP寻址的过程（ARP协议）：主机A想通过IP地址寻找到目标主机，首先分析IP地址确定目标主机与自己是否为同一网段。如果是则查看ARP缓存，或者使用ARP协议发送广播。如果不是，则寻找网关发送ARP数据包</p>
<h1 id="3-数据库">3. 数据库</h1>
<h4 id="1-关系型和非关系型数据库的区别低频">（1） 关系型和非关系型数据库的区别（低频）</h4>
<ul>
<li>关系型数据库的优点
<ol>
<li>容易理解。因为它采用了关系模型来组织数据。</li>
<li>可以保持数据的一致性。</li>
<li>数据更新的开销比较小。</li>
<li>支持复杂查询（带where子句的查询）</li>
</ol>
</li>
<li>非关系型数据库的优点
<ol>
<li>不需要经过sql层的解析，读写效率高。</li>
<li>基于键值对，数据的扩展性很好。</li>
<li>可以支持多种类型数据的存储，如图片，文档等等。</li>
</ol>
</li>
</ul>
<h4 id="2-什么是非关系型数据库低频">（2） 什么是非关系型数据库（低频）</h4>
<p>非关系型数据库也叫nosql，采用键值对的形式进行存储。它的读写性能很高，易于扩展。例如Redis,Mongodb,hbase等等。</p>
<p>适合使用非关系型数据库的场景：</p>
<ul>
<li>日志系统</li>
<li>地理位置存储</li>
<li>数据量巨大</li>
<li>高可用</li>
</ul>
<h4 id="3-说一下-mysql-执行一条查询语句的内部执行过程">（3） 说一下 MySQL 执行一条查询语句的内部执行过程？</h4>
<ul>
<li>连接器：客户端先通过连接器连接到 MySQL 服务器。</li>
<li>缓存：连接器权限验证通过之后，先查询是否有查询缓存，如果有缓存（之前执行过此语句）则直接返回缓存数据，如果没有缓存则进入分析器。</li>
<li>分析器：分析器会对查询语句进行语法分析和词法分析，判断 SQL 语法是否正确，如果查询语法错误会直接返回给客户端错误信息，如果语法正确则进入优化器。</li>
<li>优化器：优化器是对查询语句进行优化处理，例如一个表里面有多个索引，优化器会判别哪个索引性能更好。</li>
<li>执行器：优化器执行完就进入执行器，执行器就开始执行语句进行查询比对了，直到查询到满足条件的所有数据，然后进行返回。</li>
</ul>
<h4 id="4-数据库的索引类型">（4） 数据库的索引类型</h4>
<p>数据库的索引类型分为逻辑分类和物理分类<br><br>
逻辑分类：</p>
<ul>
<li>主键索引 当关系表中定义主键时会自动创建主键索引。每张表中的主键索引只能有一个，要求主键中的每个值都唯一，即不可重复，也不能有空值。</li>
<li>唯一索引 数据列不能有重复，可以有空值。一张表可以有多个唯一索引，但是每个唯一索引只能有一列。如身份证，卡号等。</li>
<li>普通索引 一张表可以有多个普通索引，可以重复可以为空值</li>
<li>全文索引 可以加快模糊查询，不常用</li>
</ul>
<p>物理分类：</p>
<ul>
<li>聚集索引（聚簇索引） 数据在物理存储中的顺序跟索引中数据的逻辑顺序相同，比如以ID建立聚集索引，数据库中id从小到大排列，那么物理存储中该数据的内存地址值也按照从小到大存储。一般是表中的主键索引，如果没有主键索引就会以第一个非空的唯一索引作为聚集索引。一张表只能有一个聚集索引。</li>
<li>非聚集索引 数据在物理存储中的顺序跟索引中数据的逻辑顺序不同。非聚集索引因为无法定位数据所在的行，所以需要扫描两遍索引树。第一遍扫描非聚集索引的索引树，确定该数据的主键ID，然后到主键索引（聚集索引）中寻找相应的数据。</li>
</ul>
<h4 id="5-说一下事务是怎么实现的">（5） 说一下事务是怎么实现的</h4>
<p>https://blog.csdn.net/u013256816/article/details/103966510</p>
<p>https://www.cnblogs.com/takumicx/p/9998844.html</p>
<p>事务就是一组逻辑操作的集合。实现事务就是要保证可靠性和并发隔离，或者说，能够满足ACID特性的机制。而这些主要是靠日志恢复和并发控制实现的。</p>
<ul>
<li>日志恢复：数据库里有两个日志，一个是redo log，一个是undo log。redo log记录的是已经成功提交的事务操作信息，用来恢复数据，保证事务的<strong>持久性</strong>。undo log记录的是事务修改之前的数据信息，用来回滚数据，保证事务的<strong>原子性</strong>。</li>
<li>并发控制：并发控制主要靠读写锁和MVCC（多版本并发控制）来实现。读写锁包括共享锁和排他锁，保证事务的<strong>隔离性</strong>。MVCC通过为数据添加时间戳来实现。</li>
</ul>
<h4 id="6-mysql怎么建立索引怎么建立主键索引怎么删除索引">（6） MySQL怎么建立索引，怎么建立主键索引，怎么删除索引？</h4>
<p>MySQL建立索引有两种方式：用alter table或者create index。</p>
<pre><code>alter table table_name add primary key(column_list) #添加一个主键索引
alter table table_name add index (column_list)      #添加一个普通索引
alter table table_name add unique (column_list)     #添加一个唯一索引
</code></pre>
<pre><code>create index index_name on table_name (column_list)   #创建一个普通索引
create unique index_name on table_name (column_list)  #创建一个唯一索引
</code></pre>
<p>Mysql删除索引同样也有两种方式：alter table 和 drop index</p>
<pre><code>alter table table_name drop index index_name    #删除一个普通索引
alter table table_name drop primary key         #删除一个主键索引
</code></pre>
<pre><code>drop index index_name on table table_name
</code></pre>
<h4 id="7-索引的优缺点什么时候使用索引什么时候不能使用索引重点">（7） 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）</h4>
<p>https://www.cnblogs.com/wezheng/p/8399305.html</p>
<ul>
<li>经常搜索的列上建索引</li>
<li>作为主键的列上要建索引</li>
<li>经常需要连接（where子句）的列上</li>
<li>经常需要排序的列</li>
<li>经常需要范围查找的列</li>
</ul>
<p>哪些列不适合建索引？</p>
<ul>
<li>很少查询的列</li>
<li>更新很频繁的列</li>
<li>数据值的取值比较少的列（比如性别）</li>
</ul>
<h4 id="8-索引的底层实现重点">（8） 索引的底层实现（重点）</h4>
<p>数据库的索引是使用B+树来实现的。</p>
<p>（为什么要用B+树，为什么不用红黑树和B树）<br><br>
B+树是一种特殊的平衡多路树，是B树的优化改进版本，它把所有的数据都存放在叶节点上，中间节点保存的是索引。这样一来相对于B树来说，减少了数据对中间节点的空间占用，使得中间节点可以存放更多的指针，使得树变得更矮，深度更小，从而减少查询的磁盘IO次数，提高查询效率。另一个是由于叶节点之间有指针连接，所以可以进行范围查询，方便区间访问。</p>
<p>而红黑树是二叉的，它的深度相对B+树来说更大，更大的深度意味着查找次数更多，更频繁的磁盘IO，所以红黑树更适合在内存中进行查找。</p>
<h4 id="9-b树和b树的区别重点">（9） B树和B+树的区别（重点）</h4>
<figure data-type="image" tabindex="3"><img src="./fig/Bptree.png" alt="./fig/Bptree.png" loading="lazy"></figure>
<p>这都是由于B+树和B具有不同的存储结构所造成的区别，以一个m阶树为例。</p>
<ol>
<li>关键字的数量不同；B+树中分支结点有m个关键字，其叶子结点也有m个，其关键字只是起到了一个索引的作用，但是B树虽然也有m个子结点，但是其只拥有m-1个关键字。</li>
<li>存储的位置不同；B+树中的数据都存储在叶子结点上，也就是其所有叶子结点的数据组合起来就是完整的数据，但是B树的数据存储在每一个结点中，并不仅仅存储在叶子结点上。</li>
<li>分支结点的构造不同；B+树的分支结点仅仅存储着关键字信息和儿子的指针（这里的指针指的是磁盘块的偏移量），也就是说内部结点仅仅包含着索引信息。</li>
<li>查询不同；B树在找到具体的数值以后，则结束，而B+树则需要通过索引找到叶子结点中的数据才结束，也就是说B+树的搜索过程中走了一条从根结点到叶子结点的路径。</li>
</ol>
<p>B+树优点：由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引，而B树则常用于文件索引。</p>
<h4 id="10-索引最左前缀最左匹配">（10） 索引最左前缀/最左匹配</h4>
<p>假如我们对a b c三个字段建立了联合索引，在联合索引中，从最左边的字段开始，任何连续的索引都能匹配上，当遇到范围查询的时候停止。比如对于联合索引index(a,b,c),能匹配a,ab,abc三组索引。并且对查询时字段的顺序没有限制，也就是a,b,c; b,a,c; c,a,b; c,b,a都可以匹配。</p>
<h4 id="11-mysql的优化高频索引优化性能优化">（11） Mysql的优化（高频，索引优化，性能优化）</h4>
<p>高频访问：</p>
<ul>
<li>分表分库：将数据库表进行水平拆分，减少表的长度</li>
<li>增加缓存： 在web和DB之间加上一层缓存层</li>
<li>增加数据库的索引：在合适的字段加上索引，解决高频访问的问题</li>
</ul>
<p>并发优化：</p>
<ul>
<li>主从读写分离：只在主服务器上写，从服务器上读</li>
<li>负载均衡集群：通过集群或者分布式的方式解决并发压力</li>
</ul>
<h4 id="12-mysql数据库引擎介绍innodb和myisam的特点与区别">（12） MYSQL数据库引擎介绍，innodb和myisam的特点与区别</h4>
<ul>
<li>InnoDB ： InnoDB是mysql的默认引擎，支持事务和外键，支持容灾恢复。适合更新频繁和多并发的表  行级锁</li>
<li>MyISAM ： 插入和查询速度比较高，支持大文件，但是不支持事务，适合在web和数据仓库场景下使用  表级锁</li>
<li>MEMORY ： memory将表中的数据保存在内存里，适合数据比较小而且频繁访问的场景</li>
<li>CSV</li>
<li>blackhole</li>
</ul>
<h4 id="13-数据库中事务的acid四大特性都要能够举例说明理解透彻比如原子性和一致性的关联隔离性不好会出现的问题">（13） 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）</h4>
<p>数据库事务是指逻辑上对数据的一种操作，这个事务要么全部成功，要么全部失败。</p>
<p><strong>A: atom 原子性</strong><br><br>
数据库事务的原子性是指：事务是一个不可分割的工作单位，这组操作要么全部发生，要么全部不发生。</p>
<p><strong>C: consistency 一致性</strong><br><br>
数据库事务的一致性是指：在事务开始以前，数据库中的数据有一个一致的状态。在事务完成后，数据库中的事务也应该保持这种一致性。事务应该将数据从一个一致性状态转移到另一个一致性状态。<br>
比如在银行转账操作后两个账户的总额应当不变。</p>
<p><strong>I: isolation 隔离性</strong><br><br>
数据库事务的隔离性要求数据库中的事务不会受另一个并发执行的事务的影响，对于数据库中同时执行的每个事务来说，其他事务要么还没开始执行，要么已经执行结束，它都感觉不到还有别的事务正在执行。</p>
<p><strong>D：durability 持久性</strong><br><br>
数据库事务的持久性要求事务对数据库的改变是永久的，哪怕数据库发生损坏都不会影响到已发生的事务。<br>
如果事务没有完成，数据库因故断电了，那么重启后也应该是没有执行事务的状态，如果事务已经完成后数据库断电了，那么重启后就应该是事务执行完成后的状态。</p>
<h4 id="14什么是脏读不可重复读和幻读">（14）什么是脏读，不可重复读和幻读？</h4>
<p>详见<a href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a></p>
<ul>
<li>
<p>脏读：脏读是指一个事务在处理过程中读取了另一个还没提交的事务的数据。</p>
<blockquote>
<p>比如A向B转账100，A的账户减少了100，而B的账户还没来得及修改，此时一个并发的事务访问到了B的账户，就是脏读</p>
</blockquote>
</li>
<li>
<p>不可重复读：不可重复读是对于数据库中的某一个字段，一个事务多次查询却返回了不同的值，这是由于在查询的间隔中，该字段被另一个事务修改并提交了。</p>
<blockquote>
<p>比如A第一次查询自己的账户有1000元，此时另一个事务给A的账户增加了1000元，所以A再次读取他的账户得到了2000的结果，跟第一次读取的不一样。<br>
不可重复读与脏读的不同之处在于，脏读是读取了另一个事务没有提交的脏数据，不可重复读是读取了已经提交的数据，实际上并不是一个异常现象。</p>
</blockquote>
</li>
<li>
<p>幻读：事务多次读取同一个范围的时候，查询结果的记录数不一样，这是由于在查询的间隔中，另一个事务新增或删除了数据。</p>
<blockquote>
<p>比如A公司一共有100个人，第一次查询总人数得到100条记录，此时另一个事务新增了一个人，所以下一次查询得到101条记录。<br>
不可重复度和幻读的不同之处在于，幻读是多次读取的结果行数不同，不可重复度是读取结果的值不同。</p>
</blockquote>
</li>
</ul>
<p>避免不可重复读需要锁行，避免幻读则需要锁表。</p>
<p>脏读，不可重复读和幻读都是数据库的读一致性问题，是在并行的过程中出现的问题，必须采用一定的隔离级别解决。<br>
详见<a href="https://www.cnblogs.com/Hakuna-Matata/p/7772794.html">脏读、不可重复读和幻读的区别</a></p>
<h4 id="15-数据库的隔离级别mysql和oracle的隔离级别分别是什么重点">（15） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么（重点）</h4>
<p>详见<a href="https://blog.csdn.net/fuzhongmin05/article/details/91126936">数据库的事务隔离级别总结</a>和<a href="https://blog.csdn.net/fg2006/article/details/6937413">数据库隔离级别</a></p>
<p>为了保证数据库事务一致性，解决脏读，不可重复读和幻读的问题，数据库的隔离级别一共有四种隔离级别：</p>
<ul>
<li>读未提交 Read Uncommitted: 最低级别的隔离，不能解决以上问题</li>
<li>读已提交 Read committed:   可以避免脏读的发生</li>
<li>可重复读 Reapeatable read:  确保事务可以多次从一个字段中读取相同的值，在该事务执行期间，禁止其他事务对此字段的更新，可以避免脏读和不可重复读。 通过锁行来实现</li>
<li>串行化 Serializaion  最严格的事务隔离机制，要求所有事务被串行执行，可以避免以上所有问题。 通过锁表来实现</li>
</ul>
<p>Oracle的默认隔离级别是<strong>读已提交</strong>，实现了四种隔离级别中的读已提交和串行化隔离级别</p>
<p>MySQL的默认隔离级别是<strong>可重复读</strong>，并且实现了所有四种隔离级别</p>
<h4 id="16-数据库连接池的作用">（16） 数据库连接池的作用</h4>
<h4 id="17-mysql的表空间方式各自特点">（17） Mysql的表空间方式，各自特点</h4>
<ul>
<li>共享表空间：指的是数据库的所有的表数据，索引文件全部放在一个文件中，默认这个共享表空间的文件路径在 data 目录下。</li>
<li>独立表空间：每一个表都将会生成以独立的文件方式来进行存储。 优点：当表被删除时这部分空间可以被回收；可以更快的恢复和备份单个表；将单个表复制到另一个实例会很方便； 缺点：mysqld会维持很多文件句柄，表太多会影响性能。如果很多表都增长会导致碎片问题</li>
</ul>
<h4 id="18-分布式事务">（18） 分布式事务</h4>
<h4 id="19-数据库的范式">（19） 数据库的范式</h4>
<p>https://www.cnblogs.com/linjiqin/archive/2012/04/01/2428695.html</p>
<ul>
<li><strong>第一范式(确保每列保持原子性)</strong><br><br>
第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。</li>
</ul>
<blockquote>
<p>比如 学生 选课（包括很多课程） 就不符合第一范式</p>
</blockquote>
<ul>
<li><strong>第二范式(确保表中的每列都和主键相关)</strong><br><br>
在满足第一范式的前提下，（主要针对联合主键而言）第二范式需要确保数据库表中的每一列都和主键的所有成员直接相关，由整个主键才能唯一确定，而不能只与主键的某一部分相关或者不相关。</li>
</ul>
<blockquote>
<p>比如一张学生信息表，由主键（学号）可以唯一确定一个学生的姓名，班级，年龄等信息。但是主键 （学号，班级） 与列 姓名，班主任，教室 就不符合第二范式，因为班主任跟部分主键（班级）是依赖关系</p>
</blockquote>
<ul>
<li><strong>第三范式(确保非主键的列没有传递依赖)</strong><br><br>
在满足第二范式的前提下，第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。非主键的列不能确定其他列，列与列之间不能出现传递依赖。</li>
</ul>
<blockquote>
<p>比如一张学生信息表，主键是（学号）列包括 姓名，班级，班主任 就不符合第三范式，因为非主键的列中 班主任 依赖于 班级</p>
</blockquote>
<ul>
<li><strong>BCNF范式（确保主键之间没有传递依赖）</strong><br><br>
主键有可能是由多个属性组合成的复合主键，那么多个主键之间不能有传递依赖。也就是复合主键之间谁也不能决定谁，相互之间没有关系。</li>
</ul>
<h4 id="20-数据的锁的种类加锁的方式">（20） 数据的锁的种类，加锁的方式</h4>
<p>以MYSQL为例，</p>
<ul>
<li>按照类型来分有乐观锁和悲观锁</li>
<li>根据粒度来分有行级锁，页级锁，表级锁（粒度一个比一个大） （仅BDB，Berkeley Database支持页级锁）</li>
<li>根据作用来分有共享锁（读锁）和排他锁（写锁）。</li>
</ul>
<h4 id="21-什么是共享锁和排他锁">（21） 什么是共享锁和排他锁</h4>
<ul>
<li>
<p>共享锁是读操作的时候创建的锁，一个事务对数据加上共享锁之后，其他事务只能对数据再加共享锁，不能进行写操作直到释放所有共享锁。</p>
</li>
<li>
<p>排他锁是写操作时创建的锁，事务对数据加上排他锁之后其他任何事务都不能对数据加任何的锁（即其他事务不能再访问该数据）</p>
<p>https://blog.csdn.net/qq_42743933/article/details/81236658</p>
</li>
</ul>
<h4 id="22-分库分表的理解和简介">（22） 分库分表的理解和简介</h4>
<h4 id="23">（23）</h4>
<h4 id="24数据库高并发的解决方案">（24）数据库高并发的解决方案</h4>
<ol>
<li>在web服务框架中加入缓存。在服务器与数据库层之间加入缓存层，将高频访问的数据存入缓存中，减少数据库的读取负担。</li>
<li>增加数据库索引。提高查询速度。（不过索引太多会导致速度变慢，并且数据库的写入会导致索引的更新，也会导致速度变慢）</li>
<li>主从读写分离，让主服务器负责写，从服务器负责读。</li>
<li>将数据库进行拆分，使得数据库的表尽可能小，提高查询的速度。</li>
<li>使用分布式架构，分散计算压力。</li>
</ol>
<h4 id="25乐观锁与悲观锁解释一下">（25）乐观锁与悲观锁解释一下</h4>
<p>一般的数据库都会支持并发操作，在并发操作中为了避免数据冲突，所以需要对数据上锁，乐观锁和悲观锁就是两种不同的上锁方式。</p>
<p>悲观锁假设数据在并发操作中一定会发生冲突，所以在数据开始读取的时候就把数据锁住。而乐观锁则假设数据一般情况下不会发生冲突，所以在数据提交更新的时候，才会检测数据是否有冲突。</p>
<h4 id="26乐观锁与悲观锁是怎么实现的">（26）乐观锁与悲观锁是怎么实现的</h4>
<p>悲观锁有行级锁和页级锁两种形式。行级锁对正在使用的单条数据进行锁定，事务完成后释放该行数据，而页级锁则对整张表进行锁定，事务正在对该表进行访问的时候不允许其他事务并行访问。</p>
<p>悲观锁要求在整个过程中一直与数据库有一条连接，因为上一个事务完成后才能让下一个事务执行，这个过程是串行的。</p>
<p>乐观锁有三种常用的实现形式：</p>
<ul>
<li>一种是在执行事务时把整个数据都拷贝到应用中，在数据更新提交的时候比较数据库中的数据与新数据，如果两个数据一摸一样则表示没有冲突可以直接提交，如果有冲突就要交给业务逻辑去解决。</li>
<li>一种是使用版本戳来对数据进行标记，数据每发生一次修改，版本号就增加1。某条数据在提交的时候，如果数据库中的版本号与自己的一致，就说明数据没有发生修改，否则就认为是过期数据需要处理。</li>
<li>最后一种采用时间戳对数据最后修改的时间进行标记。与上一种类似。</li>
</ul>
<h4 id="27对数据库目前最新技术有什么了解吗">（27）对数据库目前最新技术有什么了解吗</h4>
<h1 id="4-linux">4. Linux</h1>
<h4 id="1-linux的io模型介绍以及同步异步阻塞非阻塞的区别超级重要">（1） Linux的I/O模型介绍以及同步异步阻塞非阻塞的区别（超级重要）</h4>
<p>https://blog.csdn.net/sqsltr/article/details/92762279</p>
<p>https://www.cnblogs.com/euphie/p/6376508.html</p>
<p>（IO过程包括两个阶段：（1）内核从IO设备读写数据和（2）进程从内核复制数据）</p>
<ul>
<li>
<p>阻塞：调用IO操作的时候，如果缓冲区空或者满了，调用的进程或者线程就会处于阻塞状态直到IO可用并完成数据拷贝。</p>
</li>
<li>
<p>非阻塞：调用IO操作的时候，内核会马上返回结果，如果IO不可用，会返回错误，这种方式下进程需要不断轮询直到IO可用为止，但是当进程从内核拷贝数据时是阻塞的。</p>
</li>
<li>
<p>IO多路复用就是同时监听多个描述符，一旦某个描述符IO就绪（读就绪或者写就绪），就能够通知进程进行相应的IO操作，否则就将进程阻塞在select或者epoll语句上。</p>
</li>
<li>
<p>同步IO：同步IO模型包括阻塞IO，非阻塞IO和IO多路复用。特点就是当进程从内核复制数据的时候都是阻塞的。</p>
</li>
<li>
<p>异步IO：在检测IO是否可用和进程拷贝数据的两个阶段都是不阻塞的，进程可以做其他事情，当IO完成后内核会给进程发送一个信号。</p>
</li>
</ul>
<h4 id="2-文件系统的理解ext4xfsbtrfs">（2） 文件系统的理解（EXT4，XFS，BTRFS）</h4>
<h4 id="3-epoll的介绍和了解">（3） EPOLL的介绍和了解</h4>
<p>https://zhuanlan.zhihu.com/p/56486633</p>
<p>https://www.jianshu.com/p/397449cadc9a</p>
<p>https://blog.csdn.net/davidsguo008/article/details/73556811</p>
<p>Epoll是Linux进行IO多路复用的一种方式，用于在一个线程里监听多个IO源，在IO源可用的时候返回并进行操作。它的特点是基于事件驱动，性能很高。</p>
<p>epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间，由用户程序进行处理。</p>
<p>Epoll有三个系统调用：epoll_create(),epoll_ctl()和epoll_wait()。</p>
<ul>
<li>
<p>eoll_create()函数在内核中初始化一个eventpoll对象，同时初始化红黑树和就绪链表。</p>
</li>
<li>
<p>epoll_ctl()用来对监听的文件描述符进行管理。将文件描述符插入红黑树，或者从红黑树中删除，这个过程的时间复杂度是log(N)。同时向内核注册文件描述符的回调函数。</p>
</li>
<li>
<p>epoll_wait()会将进程放到eventpoll的等待队列中，将进程阻塞，当某个文件描述符IO可用时，内核通过回调函数将该文件描述符放到就绪链表里，epoll_wait()会将就绪链表里的文件描述符返回到用户空间。</p>
</li>
</ul>
<h4 id="4-io复用的三种方法selectpollepoll深入理解包括三者区别内部原理实现">（4） IO复用的三种方法（select,poll,epoll）深入理解，包括三者区别，内部原理实现？</h4>
<p>（1）select的方法介绍：select把所有监听的文件描述符拷贝到内核中，挂起进程。当某个文件描述符可读或可写的时候，中断程序唤起进程，select将监听的文件描述符再次拷贝到用户空间，然select后遍历这些文件描述符找到IO可用的文件。下次监控的时候需要再次拷贝这些文件描述符到内核空间。select支持监听的描述符最大数量是1024.<br>
<img src="fig/select.png" alt="select" loading="lazy"><br>
（2）poll使用链表保存文件描述符，其他的跟select没有什么不同。</p>
<p>（3）epoll将文件描述符拷贝到内核空间后使用红黑树进行维护，同时向内核注册每个文件描述符的回调函数，当某个文件描述符可读可写的时候，将这个文件描述符加入到就绪链表里，并唤起进程，返回就绪链表到用户空间。<br>
<img src="fig/epoll.png" alt="epoll" loading="lazy"><br>
详见 https://www.cnblogs.com/Anker/p/3265058.html</p>
<h4 id="5-epoll的et模式和lt模式et的非阻塞">（5） Epoll的ET模式和LT模式（ET的非阻塞）</h4>
<ul>
<li>ET是边缘触发模式，在这种模式下，只有当描述符从未就绪变成就绪时，内核才会通过epoll进行通知。然后直到下一次变成就绪之前，不会再次重复通知。也就是说，如果一次就绪通知之后不对这个描述符进行IO操作导致它变成未就绪，内核也不会再次发送就绪通知。优点就是只通知一次，减少内核资源浪费，效率高。缺点就是不能保证数据的完整，有些数据来不及读可能就会无法取出。</li>
<li>LT是水平触发模式，在这个模式下，如果文件描述符IO就绪，内核就会进行通知，如果不对它进行IO操作，只要还有未操作的数据，内核都会一直进行通知。优点就是可以确保数据可以完整输出。缺点就是由于内核会一直通知，会不停从内核空间切换到用户空间，资源浪费严重。</li>
</ul>
<h4 id="6-查询进程占用cpu的命令注意要了解到usedbuf代表意义">（6） 查询进程占用CPU的命令（注意要了解到used，buf，代表意义）</h4>
<p>详见：https://blog.csdn.net/qq_36357820/article/details/76606113</p>
<ol>
<li>top命令查看linux负载：</li>
<li>uptime查看linux负载</li>
<li>w查看linux负载：</li>
<li>vmstat查看linux负载</li>
</ol>
<h4 id="7-linux的其他常见命令killfindcp等等">（7） linux的其他常见命令（kill，find，cp等等）</h4>
<h4 id="8-shell脚本用法">（8） shell脚本用法</h4>
<h4 id="9-硬连接和软连接的区别">（9） 硬连接和软连接的区别</h4>
<h4 id="10-文件权限怎么看rwx">（10） 文件权限怎么看（rwx）</h4>
<h4 id="11-文件的三种时间mtime-atimectime分别在什么时候会改变">（11） 文件的三种时间（mtime, atime，ctime），分别在什么时候会改变</h4>
<h4 id="12-linux监控网络带宽的命令查看特定进程的占用网络资源情况命令">（12） Linux监控网络带宽的命令，查看特定进程的占用网络资源情况命令</h4>
<h4 id="13linux中线程的同步方式有哪些">（13）Linux中线程的同步方式有哪些？</h4>
<h4 id="14怎么修改一个文件的权限">（14）怎么修改一个文件的权限</h4>
<p>chmod 777  (177 277 477 等，权限组合是 1 2 4，分别代表r x w )</p>
<h4 id="15查看文件内容常用命令">（15）查看文件内容常用命令</h4>
<p>详见： http://blog.sina.com.cn/s/blog_7b4ce6b101018l8l.html</p>
<ol>
<li>cat 与 tac</li>
</ol>
<pre><code>cat的功能是将文件从第一行开始连续的将内容输出在屏幕上。当文件大，行数比较多时，屏幕无法全部容下时，只能看到一部分内容。所以通常使用重定向的方式，输出满足指定格式的内容

cat语法：cat [-n]  文件名 （-n ： 显示时，连行号一起输出）

tac的功能是将文件从最后一行开始倒过来将内容数据输出到屏幕上。我们可以发现，tac实际上是cat反过来写。这个命令不常用。

tac语法：tac 文件名。
</code></pre>
<ol start="2">
<li>more和less（常用）</li>
</ol>
<pre><code>more的功能是将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容。当一页无法全部输出时，可以用“回车键”向下翻行，用“空格键”向下翻页。退出查看页面，请按“q”键。另外，more还可以配合管道符“|”（pipe）使用，例如:ls -al | more

more的语法：more 文件名

Enter 向下n行，需要定义，默认为1行； 

Ctrl f 向下滚动一屏； 

空格键 向下滚动一屏； 

Ctrl b 返回上一屏； 

= 输出当前行的行号； 

:f 输出文件名和当前行的行号； 

v 调用vi编辑器； 

! 命令 调用Shell，并执行命令； 

q 退出more


less的功能和more相似，但是使用more无法向前翻页，只能向后翻。

less可以使用【pageup】和【pagedown】键进行前翻页和后翻页，这样看起来更方便。

less的语法：less 文件名
</code></pre>
<ol start="3">
<li>head和tail</li>
</ol>
<pre><code>head和tail通常使用在只需要读取文件的前几行或者后几行的情况下使用。head的功能是显示文件的前几行内容

head的语法：head [n number] 文件名 (number 显示行数)

tail的功能恰好和head相反，只显示最后几行内容

tail的语法:tail [-n number] 文件名
</code></pre>
<ol start="4">
<li>nl</li>
</ol>
<pre><code>nl的功能和cat -n一样，同样是从第一行输出全部内容，并且把行号显示出来

nl的语法：nl 文件名
</code></pre>
<ol start="5">
<li>vim</li>
</ol>
<p>这个用的太普遍了，主要是用于编辑。</p>
<h4 id="16怎么找出含有关键字的前后4行">（16）怎么找出含有关键字的前后4行</h4>
<h4 id="17linux的gdb调试">（17）Linux的GDB调试</h4>
<h4 id="18coredump是什么-怎么才能coredump">（18）coredump是什么 怎么才能coredump</h4>
<p>coredump是程序由于异常或者bug在运行时异常退出或者终止，在一定的条件下生成的一个叫做core的文件，这个core文件会记录程序在运行时的内存，寄存器状态，内存指针和函数堆栈信息等等。对这个文件进行分析可以定位到程序异常的时候对应的堆栈调用信息。</p>
<p>coredump产生的条件</p>
<ol>
<li>shell资源控制限制，使用 ulimit -c 命令查看shell执行程序时的资源 ，如果为0，则不会产生coredump。可以用ulimit -c unlimited设置为不限大小。</li>
<li>读写越界，包括：数组访问越界，指针指向错误的内存，字符串读写越界</li>
<li>使用了线程不安全的函数，读写未加锁保护</li>
<li>错误使用指针转换</li>
<li>堆栈溢出</li>
</ol>
<h4 id="19tcpdump常用命令">（19）tcpdump常用命令</h4>
<p>用简单的话来定义tcpdump，就是：dump the traffic on a network，根据使用者的定义对网络上的数据包进行截获的包分析工具。 tcpdump可以将网络中传送的数据包的“头”完全截获下来提供分析。它支持针对网络层、协议、主机、网络或端口的过滤，并提供and、or、not等逻辑语句来帮助你去掉无用的信息。</p>
<p>实用命令实例</p>
<p>将某端口收发的数据包保存到文件<br><br>
<code>sudo tcpdump -i any port 端口 -w 文件名.cap</code></p>
<p>打印请求到屏幕<br><br>
<code>sudo tcpdump -i any port 端口 -Xnlps0</code></p>
<p>默认启动<br><br>
<code>tcpdump</code><br>
普通情况下，直接启动tcpdump将监视第一个网络接口上所有流过的数据包。<br>
监视指定网络接口的数据包<br><br>
<code>tcpdump -i eth1</code><br>
如果不指定网卡，默认tcpdump只会监视第一个网络接口，一般是eth0，下面的例子都没有指定网络接口。</p>
<h4 id="20-crontab命令">（20） crontab命令</h4>
<p>详见：https://www.cnblogs.com/peida/archive/2013/01/08/2850483.html</p>
<p>corntab命令是用来指定用户计划任务的。用户将需要定时执行的任务写入crontab文件中，提交给crond进程定期执行。</p>
<ul>
<li>crontab命令用来对crontab文件进行管理</li>
</ul>
<pre><code>1．命令格式：
crontab [-u user] file
crontab [-u user] [ -e | -l | -r ]
2．命令功能：
通过crontab 命令，我们可以在固定的间隔时间执行指定的系统指令或 shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的日志分析或数据备份等工作。
3．命令参数：
-u user：用来设定某个用户的crontab服务，例如，“-u ixdba”表示设定ixdba用户的crontab服务，此参数一般有root用户来运行。
file：file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。
-e：编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。
-l：显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。
-r：从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。
-i：在删除用户的crontab文件时给确认提示。
</code></pre>
<ul>
<li>crontab文件内容</li>
</ul>
<p>crond是Linux下的周期性执行系统任务的守护进程，他会根据/etc下的crontab配置文件的内容执行。用户需要将计划任务写入crontab文件中才能执行。</p>
<p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p>
<pre><code>minute   hour   day   month   week   command

其中：
minute： 表示分钟，可以是从0到59之间的任何整数。
hour：表示小时，可以是从0到23之间的任何整数。
day：表示日期，可以是从1到31之间的任何整数。
month：表示月份，可以是从1到12之间的任何整数。
week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。
command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。
在以上各个字段中，还可以使用以下特殊字符：
星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。
逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”
中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”
正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。
</code></pre>
<h4 id="21-查看后台进程">（21） 查看后台进程</h4>
<ul>
<li>jobs</li>
</ul>
<p>查看当前控制台的后台进程</p>
<p>想要停止后台进程，使用jobs命令查看其进程号（比如为num），然后kill %num即可</p>
<ul>
<li>ps</li>
</ul>
<p>查看后台进程</p>
<ul>
<li>top</li>
</ul>
<p>查看所有进程和资源使用情况，类似Windows中的任务管理器</p>
<p>停止进程：界面是交互式的，在窗口输入k 之后输入PID，会提示输入停止进程模式 有SIGTERM和 SIGKILL 如果留空不输入，就是SIGTERM（优雅停止）</p>
<p>退出top：输入q即可</p>
<h1 id="5-操作系统">5. 操作系统</h1>
<h4 id="1-进程与线程的区别和联系重点">（1） 进程与线程的区别和联系（重点）</h4>
<ul>
<li>区别</li>
</ul>
<ol>
<li>进程是对运行时程序的封装，是系统进行资源分配和调度的基本单元，而线程是进程的子任务，是CPU分配和调度的基本单元。</li>
<li>一个进程可以有多个线程，但是一个线程只能属于一个进程。</li>
<li>进程的创建需要系统分配内存和CPU，文件句柄等资源，销毁时也要进行相应的回收，所以进程的管理开销很大；但是线程的管理开销则很小。</li>
<li>进程之间不会相互影响；而一个线程崩溃会导致进程崩溃，从而影响同个进程里面的其他线程。</li>
</ol>
<ul>
<li>联系 进程与线程之间的关系：线程是存在进程的内部，一个进程中可以有多个线程，一个线程只能存在一个进程中。</li>
</ul>
<h4 id="2-linux理论上最多可以创建多少个进程一个进程可以创建多少线程和什么有关">（2） Linux理论上最多可以创建多少个进程？一个进程可以创建多少线程，和什么有关</h4>
<p>答：32768. 因为进程的pid是用pid_t来表示的，pid_t的最大值是32768.所以理论上最多有32768个进程。</p>
<p>至于线程。进程最多可以创建的线程数是根据分配给调用栈的大小，以及操作系统（32位和64位不同）共同决定的。Linux32位下是300多个。</p>
<h4 id="3-冯诺依曼结构有哪几个模块分别对应现代计算机的哪几个部分百度安全一面">（3） 冯诺依曼结构有哪几个模块？分别对应现代计算机的哪几个部分？（百度安全一面）</h4>
<ul>
<li>存储器：内存</li>
<li>控制器：南桥北桥</li>
<li>运算器：CPU</li>
<li>输入设备：键盘</li>
<li>输出设备：显示器、网卡</li>
</ul>
<h4 id="4-进程之间的通信方法有哪几种-重点">（4） 进程之间的通信方法有哪几种 （重点）</h4>
<p>进程之间的通信方式主要有六种，包括<strong>管道，信号量，消息队列，信号，共享内存，套接字</strong>。</p>
<ul>
<li>
<p>管道：管道是半双工的，双方需要通信的时候，需要建立两个管道。管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据：管道一端的进程顺序地将进程数据写入缓冲区，另一端的进程则顺序地读取数据，该缓冲区可以看做一个循环队列，读和写的位置都是自动增加的，一个数据只能被读一次，读出以后再缓冲区都不复存在了。当缓冲区读空或者写满时，有一定的规则控制相应的读进程或写进程是否进入等待队列，当空的缓冲区有新数据写入或慢的缓冲区有数据读出时，就唤醒等待队列中的进程继续读写。管道是最容易实现的<br>
<img src="fig/%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1.png" alt="fig/管道通信.png" loading="lazy"></p>
<p>匿名管道pipe和命名管道除了建立，打开，删除的方式不同外，其余都是一样的。匿名管道只允许有亲缘关系的进程之间通信，也就是父子进程之间的通信，命名管道允许具有非亲缘关系的进程间通信。</p>
<p>管道的底层实现 https://segmentfault.com/a/1190000009528245</p>
</li>
<li>
<p>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。信号量只有等待和发送两种操作。等待(P(sv))就是将其值减一或者挂起进程，发送(V(sv))就是将其值加一或者将进程恢复运行。</p>
</li>
<li>
<p>信号：信号是Linux系统中用于进程之间通信或操作的一种机制，信号可以在任何时候发送给某一进程，而无须知道该进程的状态。如果该进程并未处于执行状态，则该信号就由内核保存起来，知道该进程恢复执行并传递给他为止。如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。 信号是开销最小的</p>
</li>
<li>
<p>共享内存：共享内存允许两个或多个进程共享一个给定的存储区，这一段存储区可以被两个或两个以上的进程映射至自身的地址空间中，就像由malloc()分配的内存一样使用。一个进程写入共享内存的信息，可以被其他使用这个共享内存的进程，通过一个简单的内存读取读出，从而实现了进程间的通信。共享内存的效率最高，缺点是没有提供同步机制，需要使用锁等其他机制进行同步。</p>
</li>
<li>
<p>消息队列：消息队列就是一个消息的链表，是一系列保存在内核中消息的列表。用户进程可以向消息队列添加消息，也可以向消息队列读取消息。<br>
消息队列与管道通信相比，其优势是对每个消息指定特定的消息类型，接收的时候不需要按照队列次序，而是可以根据自定义条件接收特定类型的消息。<br>
可以把消息看做一个记录，具有特定的格式以及特定的优先级。对消息队列有写权限的进程可以向消息队列中按照一定的规则添加新消息，对消息队列有读权限的进程可以从消息队列中读取消息。</p>
</li>
<li>
<p>套接字：套接口也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同设备及其间的进程通信。</p>
</li>
</ul>
<h4 id="5-进程调度方法详细介绍">（5） 进程调度方法详细介绍</h4>
<p>https://blog.csdn.net/u011080472/article/details/51217754</p>
<p>https://blog.csdn.net/leex_brave/article/details/51638300</p>
<ul>
<li>先来先服务 （FCFS first come first serve）：按照作业到达任务队列的顺序调度  FCFS是非抢占式的，易于实现，效率不高，性能不好，有利于长作业（CPU繁忙性）而不利于短作业（I/O繁忙性）。</li>
<li>短作业优先 （SHF short job first）：每次从队列里选择预计时间最短的作业运行。SJF是非抢占式的，优先照顾短作业，具有很好的性能，降低平均等待时间，提高吞吐量。但是不利于长作业，长作业可能一直处于等待状态，出现饥饿现象；完全未考虑作业的优先紧迫程度，不能用于实时系统。</li>
<li>最短剩余时间优先 该算法首先按照作业的服务时间挑选最短的作业运行，在该作业运行期间，一旦有新作业到达系统，并且该新作业的服务时间比当前运行作业的剩余服务时间短，则发生抢占；否则，当前作业继续运行。该算法确保一旦新的短作业或短进程进入系统，能够很快得到处理。</li>
<li>高响应比优先调度算法（Highest Reponse Ratio First, HRRF）是非抢占式的，主要用于作业调度。基本思想：每次进行作业调度时，先计算后备作业队列中每个作业的响应比，挑选最高的作业投入系统运行。响应比 = （等待时间 + 服务时间） / 服务时间 = 等待时间 / 服务时间 + 1。因为每次都需要计算响应比，所以比较耗费系统资源。</li>
<li>时间片轮转 用于分时系统的进程调度。基本思想：系统将CPU处理时间划分为若干个时间片（q），进程按照到达先后顺序排列。每次调度选择队首的进程，执行完1个时间片q后，计时器发出时钟中断请求，该进程移至队尾。以后每次调度都是如此。该算法能在给定的时间内响应所有用户的而请求，达到分时系统的目的。</li>
<li>多级反馈队列(Multilevel Feedback Queue)</li>
</ul>
<h4 id="6-进程的执行过程是什么样的执行一个进程需要做哪些工作">（6） 进程的执行过程是什么样的，执行一个进程需要做哪些工作？</h4>
<p>进程的执行需要经过三大步骤：编译，链接和装入。</p>
<ul>
<li>编译：将源代码编译成若干模块</li>
<li>链接：将编译后的模块和所需要的库函数进行链接。链接包括三种形式：静态链接，装入时动态链接（将编译后的模块在链接时一边链接一边装入），运行时动态链接（在执行时才把需要的模块进行链接）</li>
<li>装入：将模块装入内存运行</li>
</ul>
<p>https://blog.csdn.net/qq_38623623/article/details/78306498</p>
<p>将进程装入内存时，通常使用分页技术，将内存分成固定大小的页，进程分为固定大小的块，加载时将进程的块装入页中，并使用页表记录。减少外部碎片。</p>
<p>通常操作系统还会使用虚拟内存的技术将磁盘作为内存的扩充。</p>
<h4 id="6-操作系统的内存管理说一下">（6） 操作系统的内存管理说一下</h4>
<p>https://www.cnblogs.com/peterYong/p/6556619.html</p>
<p>https://zhuanlan.zhihu.com/p/141602175</p>
<p>操作系统的内存管理包括物理内存管理和虚拟内存管理</p>
<ul>
<li>物理内存管理包括交换与覆盖，分页管理，分段管理和段页式管理等；</li>
<li>虚拟内存管理包括虚拟内存的概念，页面置换算法，页面分配策略等；</li>
</ul>
<p>（面试官这样问的时候，其实是希望你能讲讲虚拟内存）</p>
<h4 id="7-实现一个lru算法">（7） 实现一个LRU算法</h4>
<p>用到两个数据结构：哈希+双向链表</p>
<pre><code>unordered_map&lt;int,list&lt;pair&lt;int,int&gt; &gt; &gt; cache ;// 存放键，迭代器
list&lt;pair&lt;int,int&gt;&gt; auxlist; // 存放 &lt;键，值&gt;
</code></pre>
<pre><code>class LRUCache {
    int cap;
    list&lt;pair&lt;int,int&gt;&gt; l;// front:new back:old 存放值 新的放前面，因为前面的可以取得有效的迭代器
    map&lt;int,list&lt;pair&lt;int,int&gt; &gt;::iterator &gt; cache;// 存放键，迭代器
public:
    LRUCache(int capacity) {
        cap=capacity;
    }
    
    int get(int key) {
        auto mapitera = cache.find(key);
        if(mapitera==cache.end()){
            return -1;
        }else{// found
            list&lt;pair&lt;int,int&gt;&gt;::iterator listItera = mapitera-&gt;second;
            int value = (*listItera).second;

            l.erase(listItera);
            l.push_front({key,value});
            cache[key]=l.begin();

            return value;
        }
    }
    
    void put(int key, int value) {
        auto itera = cache.find(key);
        if(itera!=cache.end()){// exist
            list&lt;pair&lt;int,int&gt;&gt;::iterator listItera = itera-&gt;second;

            l.erase(listItera);
            l.push_front({key,value});
            cache[key]=l.begin();

        }else{// not exist
            if(cache.size()&gt;=cap){
                pair&lt;int,int&gt; oldpair = l.back();
                l.pop_back();
                cache.erase(oldpair.first);
            }
            l.push_front({key,value});
            cache[key]=l.begin();
        }
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj-&gt;get(key);
 * obj-&gt;put(key,value);
 */
</code></pre>
<h4 id="8-死锁产生的必要条件怎么检测死锁解决死锁问题">（8） 死锁产生的必要条件（怎么检测死锁，解决死锁问题）</h4>
<p>（1） 互斥：一个资源每次只能被一个进程使用。<br><br>
（2） 占有并请求：一个进程因请求资源而阻塞时，对已获得的资源保持不放。<br><br>
（3） 不可剥夺:进程已获得的资源，在末使用完之前，不能强行剥夺。<br><br>
（4） 循环等待:若干进程之间形成一种头尾相接的循环等待资源关系。<br></p>
<p>产生死锁的原因主要是：<br><br>
（1） 因为系统资源不足。<br><br>
（2） 进程运行推进的顺序不合适。<br><br>
（3） 资源分配不当等。<br></p>
<h4 id="8-死锁的恢复">（8） 死锁的恢复</h4>
<ol>
<li>重新启动：是最简单、最常用的死锁消除方法，但代价很大，因为在此之前所有进程已经完成的计算工作都将付之东流，不仅包括死锁的全部进程，也包括未参与死锁的全部进程。</li>
<li>终止进程(process termination)：终止参与死锁的进程并回收它们所占资源。<br>
(1) 一次性全部终止；(2) 逐步终止(优先级，代价函数)</li>
<li>剥夺资源(resource preemption):剥夺死锁进程所占有的全部或者部分资源。<br>
(1) 逐步剥夺：一次剥夺死锁进程所占有的一个或一组资源，如果死锁尚未解除再继续剥夺，直至死锁解除为止。<br>
(2) 一次剥夺：一次性地剥夺死锁进程所占有的全部资源。</li>
<li>进程回退(rollback):让参与死锁的进程回退到以前没有发生死锁的某个点处，并由此点开始继续执行，希望进程交叉执行时不再发生死锁。但是系统开销很大：<br>
(1) 要实现“回退”，必须“记住”以前某一点处的现场，而现场随着进程推进而动态变化，需要花费大量时间和空间。<br>
(2) 一个回退的进程应当“挽回”它在回退点之间所造成的影响，如修改某一文件，给其它进程发送消息等，这些在实现时是难以做到的</li>
</ol>
<h4 id="8什么是饥饿">（8）什么是饥饿</h4>
<p>饥饿是由于资源分配策略不公引起的，当进程或线程无法访问它所需要的资源而不能继续执行时，就会发生饥饿现象。</p>
<h4 id="9-如果要你实现一个mutex互斥锁你要怎么实现">（9） 如果要你实现一个mutex互斥锁你要怎么实现？</h4>
<p>https://blog.csdn.net/kid551/article/details/84338619</p>
<p>实现mutex最重要的就是实现它的lock()方法和unlock()方法。我们保存一个全局变量flag，flag=1表明该锁已经锁住，flag=0表明锁没有锁住。<br>
实现lock()时，使用一个while循环不断检测flag是否等于1，如果等于1就一直循环。然后将flag设置为1；unlock()方法就将flag置为0；</p>
<pre><code class="language-C++">static int flag=0;

void lock(){
  while(TestAndSet(&amp;flag,1)==1);
  //flag=1;
}
void unlock(){
  flag=0;
}
</code></pre>
<p>因为while有可能被重入，所以可以用TestandSet()方法。</p>
<pre><code class="language-C++">int TestAndSet(int *ptr, int new) {
    int old = *ptr;
    *ptr = new;
    return old;
}
</code></pre>
<h4 id="10线程之间的通信方式有哪些-进程之间的同步方式又哪些">（10）线程之间的通信方式有哪些？ 进程之间的同步方式又哪些？</h4>
<p>线程之间通信：</p>
<ul>
<li>使用全局变量</li>
<li>使用信号机制</li>
<li>使用事件</li>
</ul>
<p>进程之间同步：<br>
https://www.cnblogs.com/sonic4x/archive/2011/07/05/2098036.html</p>
<ul>
<li>信号量</li>
<li>管程</li>
</ul>
<h4 id="13-什么时候用多进程什么时候用多线程">（13） 什么时候用多进程，什么时候用多线程</h4>
<p>https://blog.csdn.net/yu876876/article/details/82810178</p>
<ul>
<li>频繁修改：需要频繁创建和销毁的优先使用<strong>多线程</strong></li>
<li>计算量：需要大量计算的优先使用<strong>多线程</strong>  因为需要消耗大量CPU资源且切换频繁，所以多线程好一点</li>
<li>相关性：任务间相关性比较强的用<strong>多线程</strong>，相关性比较弱的用多进程。因为线程之间的数据共享和同步比较简单。</li>
<li>多分布：可能要扩展到多机分布的用<strong>多进程</strong>，多核分布的用<strong>多线程</strong>。</li>
</ul>
<p>但是实际中更常见的是进程加线程的结合方式，并不是非此即彼的。</p>
<h4 id="14-文件读写使用的系统调用">（14） 文件读写使用的系统调用</h4>
<h4 id="15-孤儿进程和僵尸进程分别是什么怎么形成的">（15） 孤儿进程和僵尸进程分别是什么，怎么形成的？</h4>
<p>https://www.cnblogs.com/Anker/p/3271773.html</p>
<ul>
<li>孤儿进程是父进程退出后它的子进程还在执行，这时候这些子进程就成为孤儿进程。孤儿进程会被init进程收养并完成状态收集。</li>
<li>僵尸进程是指子进程完成并退出后父进程没有使用wait()或者waitpid()对它们进行状态收集，这些子进程的进程描述符仍然会留在系统中。这些子进程就成为僵尸进程。</li>
</ul>
<h4 id="16-说一下pcb说一下进程地址空间">（16） 说一下PCB/说一下进程地址空间/</h4>
<p>https://blog.csdn.net/qq_38499859/article/details/80057427</p>
<p>PCB就是进程控制块，是操作系统中的一种数据结构，用于表示进程状态，操作系统通过PCB对进程进行管理。</p>
<p>PCB中包含有：进程标识符，处理器状态，进程调度信息，进程控制信息</p>
<figure data-type="image" tabindex="4"><img src="https://img-blog.csdn.net/20140904215636015?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvemhhbmd6aGVianV0/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="" loading="lazy"></figure>
<p>进程地址空间内有：</p>
<ul>
<li>代码段text：存放程序的二进制代码</li>
<li>初始化的数据Data：已经初始化的变量和数据</li>
<li>未初始化的数据BSS：还没有初始化的数据</li>
<li>栈</li>
<li>堆</li>
</ul>
<h4 id="17-内核空间和用户空间是怎样区分的">（17） 内核空间和用户空间是怎样区分的</h4>
<p>在Linux中虚拟地址空间范围为0到4G，最高的1G地址（0xC0000000到0xFFFFFFFF）供内核使用，称为内核空间，低的3G空间（0x00000000到0xBFFFFFFF）供各个进程使用，就是用户空间。</p>
<p>内核空间中存放的是内核代码和数据，而进程的用户空间中存放的是用户程序的代码和数据。</p>
<h4 id="18-多线程是如何同步的尤其是如果项目中用到了多线程很大可能会结合讨论">（18） 多线程是如何同步的（尤其是如果项目中用到了多线程，很大可能会结合讨论）</h4>
<p>https://blog.csdn.net/s_lisheng/article/details/74278765</p>
<ul>
<li>临界区</li>
<li>信号量</li>
<li>事件</li>
<li>互斥量</li>
</ul>
<h4 id="19-同一个进程内的线程会共享什么资源">（19） 同一个进程内的线程会共享什么资源？</h4>
<ul>
<li>该进程的地址空间</li>
<li>全局变量</li>
<li>堆空间</li>
</ul>
<p>线程的栈空间是自己独有的</p>
<h4 id="20-异常和中断的区别">（20） 异常和中断的区别</h4>
<h4 id="21-一般情况下在linuxwindows平台下栈空间的大小">（21） 一般情况下在Linux/windows平台下栈空间的大小</h4>
<p>在Linux下栈空间通常是8M，Windows下是1M</p>
<h4 id="22虚拟内存的了解">（22）虚拟内存的了解</h4>
<p>https://www.cnblogs.com/Przz/p/6876988.html</p>
<p>在运行一个进程的时候，它所需要的内存空间可能大于系统的物理内存容量。通常一个进程会有4G的空间，但是物理内存并没有这么大，所以这些空间都是虚拟内存，它的地址都是逻辑地址，每次在访问的时候都需要映射成物理地址。<br>
当进程访问某个逻辑地址的时候，会去查看页表，如果页表中没有相应的物理地址，说明内存中没有这页的数据，发生缺页异常，这时候进程需要把数据从磁盘拷贝到物理内存中。如果物理内存已经满了，就需要覆盖已有的页，如果这个页曾经被修改过，那么还要把它写回磁盘。</p>
<h4 id="23服务器高并发的解决方案">（23）服务器高并发的解决方案</h4>
<ol>
<li>
<p>应用数据与静态资源分离<br>
将静态资源（图片，视频，js，css等）单独保存到专门的静态资源服务器中，在客户端访问的时候从静态资源服务器中返回静态资源，从主服务器中返回应用数据。</p>
</li>
<li>
<p>客户端缓存<br>
因为效率最高，消耗资源最小的就是纯静态的html页面，所以可以把网站上的页面尽可能用静态的来实现，在页面过期或者有数据更新之后再将页面重新缓存。或者先生成静态页面，然后用ajax异步请求获取动态数据。</p>
</li>
<li>
<p>集群和分布式<br>
（集群是所有的服务器都有相同的功能，请求哪台都可以，主要起分流作用）<br><br>
（分布式是将不同的业务放到不同的服务器中，处理一个请求可能需要使用到多台服务器，起到加快请求处理的速度。）<br><br>
可以使用服务器集群和分布式架构，使得原本属于一个服务器的计算压力分散到多个服务器上。同时加快请求处理的速度。</p>
</li>
<li>
<p>反向代理<br>
在访问服务器的时候，服务器通过别的服务器获取资源或结果返回给客户端。</p>
</li>
</ol>
<h4 id="24协程了解吗高频">（24）协程了解吗（高频）</h4>
<p>协程和微线程是一个东西。</p>
<p>协程就是子程序在执行时中断并转去执行别的子程序，在适当的时候又返回来执行。<br>
这种子程序间的跳转不是函数调用，也不是多线程执行，所以省去了线程切换的开销，效率很高，并且不需要多线程间的锁机制，不会发生变量写冲突。</p>
<h4 id="25那协程的底层是怎么实现的怎么使用协程">（25）那协程的底层是怎么实现的，怎么使用协程？</h4>
<p>协程进行中断跳转时将函数的上下文存放在其他位置中，而不是存放在函数堆栈里，当处理完其他事情跳转回来的时候，取回上下文继续执行原来的函数。</p>
<h4 id="23进程的状态以及转换图">（23）进程的状态以及转换图</h4>
<ul>
<li>
<p>三态模型<br>
三态模型包括三种状态：</p>
<ol>
<li>执行：进程分到CPU时间片，可以执行</li>
<li>就绪：进程已经就绪，只要分配到CPU时间片，随时可以执行</li>
<li>阻塞：有IO事件或者等待其他资源<br>
<img src="fig/%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="" loading="lazy"></li>
</ol>
</li>
<li>
<p>五态模型</p>
<ol>
<li>新建态：进程刚刚创建。</li>
<li>就绪态：</li>
<li>运行态：</li>
<li>等待态：出现等待事件</li>
<li>终止态：进程结束<br>
<img src="fig/%E4%BA%94%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="" loading="lazy"></li>
</ol>
</li>
<li>
<p>七态模型</p>
<ol>
<li>新建态</li>
<li>就绪挂起态</li>
<li>就绪态</li>
<li>运行态</li>
<li>等待态</li>
<li>挂起等待态</li>
<li>终止态<br>
<img src="fig/%E4%B8%83%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="" loading="lazy"></li>
</ol>
</li>
</ul>
<h4 id="24在执行malloc申请内存的时候操作系统是怎么做的内存分配的原理说一下malloc函数底层是怎么实现的进程是怎么分配内存的">（24）在执行malloc申请内存的时候，操作系统是怎么做的？/内存分配的原理说一下/malloc函数底层是怎么实现的？/进程是怎么分配内存的？</h4>
<p>https://blog.csdn.net/yusiguyuan/article/details/39496057</p>
<p>从操作系统层面上看，malloc是通过两个系统调用来实现的： brk和mmap</p>
<ul>
<li>brk是将进程数据段(.data)的最高地址指针向高处移动，这一步可以扩大进程在运行时的堆大小</li>
<li>mmap是在进程的虚拟地址空间中寻找一块空闲的虚拟内存，这一步可以获得一块可以操作的堆内存。</li>
</ul>
<p>通常，分配的内存小于128k时，使用brk调用来获得虚拟内存，大于128k时就使用mmap来获得虚拟内存。</p>
<p>进程先通过这两个系统调用获取或者扩大进程的虚拟内存，获得相应的虚拟地址，在访问这些虚拟地址的时候，通过缺页中断，让内核分配相应的物理内存，这样内存分配才算完成。</p>
<h4 id="25什么是字节序怎么判断是大端还是小端有什么用">（25）什么是字节序？怎么判断是大端还是小端？有什么用？</h4>
<p>https://www.cnblogs.com/broglie/p/5645200.html</p>
<p>字节序是对象在内存中存储的方式，大端即为最高有效位在前面，小端即为最低有效位在前面。<br>
判断大小端的方法：使用一个union数据结构</p>
<pre><code class="language-C++">union{
  short s;
  char c[2]; // sizeof(short)=2;
}un;
un.s=0x0102;
if(un.c[0]==1 and un.c[1]==2) cout&lt;&lt;&quot;大端&quot;;
if(un.c[0]==2 and un.c[1]==1) cout&lt;&lt;&quot;小端&quot;;
</code></pre>
<p>在网络编程中不同字节序的机器发送和接收的顺序不同。</p>
<h1 id="6-场景题算法题">6. 场景题/算法题</h1>
<h4 id="0-leetcode-hot100至少刷两遍剑指offer至少刷两遍-重中之重">（0） leetcode hot100至少刷两遍，剑指offer至少刷两遍 重中之重！！</h4>
<p>面试中90%的算法题都从leetcode hot100和剑指offer中出 刷两遍非常有必要</p>
<h4 id="1-介绍熟悉的设计模式单例简单工厂模式">（1） 介绍熟悉的设计模式（单例，简单工厂模式）</h4>
<h4 id="2-写单例模式线程安全版本">（2） 写单例模式，线程安全版本</h4>
<pre><code class="language-C++">class Singleton{
  private:
    static Singleton* instance;
    Singleton(){
      // initialize
    }
  public:
    static Singleton* getInstance(){
      if(instance==nullptr) instance=new Singleton();
      return instance;
    }
};
</code></pre>
<h4 id="3-写三个线程交替打印abc">（3） 写三个线程交替打印ABC</h4>
<pre><code class="language-C++">#include&lt;iostream&gt;
#include&lt;thread&gt;
#include&lt;mutex&gt;
#include&lt;condition_variable&gt;
using namespace std;

mutex mymutex;
condition_variable cv;
int flag=0;

void printa(){
    unique_lock&lt;mutex&gt; lk(mymutex);
    int count=0;
    while(count&lt;10){
        while(flag!=0) cv.wait(lk);
        cout&lt;&lt;&quot;thread 1: a&quot;&lt;&lt;endl;
        flag=1;
        cv.notify_all();
        count++;
    }
    cout&lt;&lt;&quot;my thread 1 finish&quot;&lt;&lt;endl;
}
void printb(){
    unique_lock&lt;mutex&gt; lk(mymutex);
    for(int i=0;i&lt;10;i++){
        while(flag!=1) cv.wait(lk);
        cout&lt;&lt;&quot;thread 2: b&quot;&lt;&lt;endl;
        flag=2;
        cv.notify_all();
    }
    cout&lt;&lt;&quot;my thread 2 finish&quot;&lt;&lt;endl;
}
void printc(){
    unique_lock&lt;mutex&gt; lk(mymutex);
    for(int i=0;i&lt;10;i++){
        while(flag!=2) cv.wait(lk);
        cout&lt;&lt;&quot;thread 3: c&quot;&lt;&lt;endl;
        flag=0;
        cv.notify_all();
    }
    cout&lt;&lt;&quot;my thread 3 finish&quot;&lt;&lt;endl;
}
int main(){
    thread th2(printa);
    thread th1(printb);
    thread th3(printc);

    th1.join();
    th2.join();
    th3.join();
    cout&lt;&lt;&quot; main thread &quot;&lt;&lt;endl;


}
</code></pre>
<h4 id="4-二维码登录的实现过程-场景题">（4） 二维码登录的实现过程 场景题</h4>
<figure data-type="image" tabindex="5"><img src="fig/%E4%BA%8C%E7%BB%B4%E7%A0%81%E7%99%BB%E5%BD%95%E6%B5%81%E7%A8%8B.png" alt="" loading="lazy"></figure>
<h4 id="5-不使用临时变量实现swap函数">（5） 不使用临时变量实现swap函数</h4>
<ul>
<li>使用异或/加减等方式，下面给出使用异或的实现方法</li>
</ul>
<pre><code class="language-C++">void swap(int&amp; a,int&amp; b){
  a=a^b;
  b=a^b;
  a=a^b;
}
</code></pre>
<h4 id="6-实现一个strcpy函数或者memcpy如果内存可能重叠呢">（6） 实现一个strcpy函数（或者memcpy），如果内存可能重叠呢</h4>
<h4 id="7-实现快排">（7） 实现快排</h4>
<pre><code class="language-C++">void swap(vector&lt;int&gt;&amp; vec,int a,int b){
    vec[a]=vec[a]^vec[b];
    vec[b]=vec[a]^vec[b];
    vec[a]=vec[a]^vec[b];
}
int partition(vector&lt;int&gt;&amp; vec,int start,int end){
    int pivot=vec[start+(end-start)/2];
    while(start&lt;end){
        while(start&lt;end and vec[start]&lt;pivot) start++;
        while(start&lt;end and vec[end]&gt;pivot) end--;
        if(start&lt;end) swap(vec,start,end);
    }
    return start;
}
void quickSort(vector&lt;int&gt;&amp; vec,int start,int end){
    if(start&gt;end) return;
    int pivot=partition(vec,start,end);
    quickSort(vec,start,pivot-1);
    quickSort(vec,pivot+1,end);
}
</code></pre>
<h4 id="8-实现一个堆排序">（8） 实现一个堆排序</h4>
<p>堆排序的基本过程：</p>
<ul>
<li>将n个元素的序列构建一个大顶堆或小顶堆</li>
<li>将堆顶的元素放到序列末尾</li>
<li>将前n-1个元素重新构建大顶堆或小顶堆，重复这个过程，直到所有元素都已经排序</li>
</ul>
<p>整体时间复杂度为nlogn</p>
<pre><code class="language-C++">#include&lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
void swap(vector&lt;int&gt;&amp; arr, int a,int b){
    arr[a]=arr[a]^arr[b];
    arr[b]=arr[a]^arr[b];
    arr[a]=arr[a]^arr[b];
}
void adjust(vector&lt;int&gt;&amp; arr,int len,int index){
    int maxid=index;
    // 计算左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2
    int left=2*index+1,right=2*index+2;

    // 寻找当前以index为根的子树中最大/最小的元素的下标
    if(left&lt;len and arr[left]&lt;arr[maxid]) maxid=left;
    if(right&lt;len and arr[right]&lt;arr[maxid]) maxid=right;

    // 进行交换，记得要递归进行adjust,传入的index是maxid
    if(maxid!=index){
        swap(arr,maxid,index);
        adjust(arr,len,maxid);
    }
}
void heapsort(vector&lt;int&gt;&amp;arr,int len){
    // 初次构建堆，i要从最后一个非叶子节点开始，所以是(len-1-1)/2，0这个位置要加等号
    for(int i=(len-1-1)/2;i&gt;=0;i--){
        adjust(arr,len,i);
    }

    // 从最后一个元素的下标开始往前遍历，每次将堆顶元素交换至当前位置，并且缩小长度（i为长度），从0处开始adjust
    for(int i=len-1;i&gt;0;i--){
        swap(arr,0,i);
        adjust(arr,i,0);// 注意每次adjust是从根往下调整，所以这里index是0！
    }
}
int main(){
    vector&lt;int&gt; arr={3,4,2,1,5,8,7,6};

    cout&lt;&lt;&quot;before: &quot;&lt;&lt;endl;
    for(int item:arr) cout&lt;&lt;item&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;

    heapsort(arr,arr.size());

    cout&lt;&lt;&quot;after: &quot;&lt;&lt;endl;
    for(int item:arr)cout&lt;&lt;item&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;

    return 0;
}
</code></pre>
<h4 id="8-实现一个插入排序">（8） 实现一个插入排序</h4>
<p>https://blog.csdn.net/left_la/article/details/8656425</p>
<pre><code class="language-C++">void insertSort(vector&lt;int&gt;&amp; nums){
  int len=nums.size();
  for(int i=1;i&lt;len;i++){
    int key=nums[i];
    int j=i-1;
    while(j&gt;=0 and nums[j]&gt;key){
      nums[j+1]=nums[j];
      j--;
    }
    nums[j+1]=key;
  }
}
</code></pre>
<h4 id="9-快排存在的问题如何优化">（9） 快排存在的问题，如何优化</h4>
<ul>
<li>3 种快排基准选择方法：</li>
</ul>
<p>随机（rand函数）、固定（队首、队尾）、三数取中（队首、队中和队尾的中间数）</p>
<ul>
<li>4种优化方式：</li>
</ul>
<p>优化1：当待排序序列的长度分割到一定大小后，使用插入排序</p>
<p>优化2：在一次分割结束后，可以把与Key相等的元素聚在一起，继续下次分割时，不用再对与key相等元素分割</p>
<p>优化3：优化递归操作</p>
<p>优化4：使用并行或多线程处理子序列</p>
<h4 id="10-反转一个链表招银网络二面">（10） 反转一个链表（招银网络二面）</h4>
<pre><code class="language-C++">ListNode* reverse(ListNode* root){
  ListNode* pre=nullptr,cur=root,nxt;
  while(cur!=nullptr){
    nxt=cur-&gt;next;
    cur-&gt;next=pre;
    pre=cur;cur=nxt;
  }
  return pre;
}
</code></pre>
<h4 id="11-top-k问题可以采取的方法有哪些各自优点重点">（11） Top K问题（可以采取的方法有哪些，各自优点？）（重点）</h4>
<p><em>Top K 问题的常见形式：</em></p>
<blockquote>
<p>给定10000个整数，找第K大（第K小）的数<br><br>
给定10000个整数，找出最大（最小）的前K个数<br><br>
给定100000个单词，求前K词频的单词<br></p>
</blockquote>
<p><em>解决Top K问题若干种方法</em></p>
<ul>
<li>使用最大最小堆。求最大的数用最小堆，求最小的数用最大堆。</li>
<li>Quick Select算法。使用类似快排的思路，根据pivot划分数组。</li>
<li>使用排序方法，排序后再寻找top K元素。</li>
<li>使用选择排序的思想，对前K个元素部分排序。</li>
<li>将1000.....个数分成m组，每组寻找top K个数，得到m×K个数，在这m×k个数里面找top K个数。</li>
</ul>
<ol>
<li>使用最大最小堆的思路 （以top K 最大元素为例）<br><br>
按顺序扫描这10000个数，先取出K个元素构建一个大小为K的最小堆。每扫描到一个元素，如果这个元素大于堆顶的元素（这个堆最小的一个数），就放入堆中，并删除堆顶的元素，同时整理堆。如果这个元素小于堆顶的元素，就直接pass。最后堆中剩下的元素就是最大的前Top K个元素，最右的叶节点就是Top 第K大的元素。</li>
</ol>
<blockquote>
<p>note：最小堆的插入时间复杂度为log(n)，n为堆中元素个数，在这里是K。最小堆的初始化时间复杂度是nlog(n)</p>
</blockquote>
<p>C++中的最大最小堆要用标准库的priority_queue来实现。</p>
<pre><code class="language-C++">struct Node {
    int value;
    int idx;
    Node (int v, int i): value(v), idx(i) {}
    friend bool operator &lt; (const struct Node &amp;n1, const struct Node &amp;n2) ; 
};

inline bool operator &lt; (const struct Node &amp;n1, const struct Node &amp;n2) {
    return n1.value &lt; n2.value;
}

priority_queue&lt;Node&gt; pq; // 此时pq为最大堆
</code></pre>
<ol start="2">
<li>使用Quick Select的思路（以寻找第K大的元素为例）<br><br>
Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的：<br>
首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。<br>
此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组执行相同操作；<br>
如果左边的数组元素个数等于K-1，则第K大的数就是pivot；<br>
如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。</li>
</ol>
<p>这个算法与快排最大的区别是，每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。</p>
<pre><code>//此为Java实现
public int findKthLargest(int[] nums, int k) {
  return quickSelect(nums, k, 0, nums.length - 1);
}

// quick select to find the kth-largest element
public int quickSelect(int[] arr, int k, int left, int right) {
  if (left == right) return arr[right];
  int index = partition(arr, left, right);
  if (index - left + 1 &gt; k)
    return quickSelect(arr, k, left, index - 1);
  else if (index - left + 1 == k)
    return arr[index];
  else
    return quickSelect(arr, k - (index - left + 1), index + 1, right);

}
</code></pre>
<ol start="3">
<li>使用选择排序的思想对前K个元素排序 （ 以寻找前K大个元素为例）<br><br>
扫描一遍数组，选出最大的一个元素，然后再扫描一遍数组，找出第二大的元素，再扫描一遍数组，找出第三大的元素。。。。。以此类推，找K个元素，时间复杂度为O(N*K)</li>
</ol>
<h4 id="12-8g的int型数据计算机的内存只有2g怎么对它进行排序外部排序百度一面">（12） 8G的int型数据，计算机的内存只有2G，怎么对它进行排序？（外部排序）（百度一面）</h4>
<p>我们可以使用外部排序来对它进行处理。首先将整个文件分成许多份，比如说m份，划分的依据就是使得每一份的大小都能放到内存里。然后我们用快速排序或者堆排序等方法对每一份数据进行一个内部排序，变成有序子串。接着对这m份有序子串进行m路归并排序。取这m份数据的最小元素，进行排序，输出排序后最小的元素到结果中，同时从该元素所在子串中读入一个元素，直到所有数据都被输出到结果中为止。</p>
<p>https://blog.csdn.net/ailunlee/article/details/84548950</p>
<h4 id="13-自己构建一棵二叉树使用带有null标记的前序遍历序列">（13） 自己构建一棵二叉树，使用带有null标记的前序遍历序列</h4>
<p>在写二叉树相关算法的时候，如果需要自己构造测试用例（自己构造一棵二叉树），往往是一件很麻烦的事情，我们可以用一个带有null标记的前序遍历序列来进行构造。 <strong>需要注意的是vec2tree()参数中的start是引用传递，而不是简单的参数值传递</strong>。</p>
<pre><code class="language-C++">#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;queue&gt;
using namespace std;

struct treeNode{
    string val;
    treeNode* left,*right;
    treeNode(string val):val(val){
        left=nullptr;
        right=nullptr;
    }
};

treeNode* vec2tree(vector&lt;string&gt;&amp; vec,int&amp; start){
    treeNode* root;
    if(vec[start]==&quot;null&quot;){
        start+=1;
        root=nullptr;
    }else{
        root=new treeNode(vec[start]);
        start+=1;
        root-&gt;left=vec2tree(vec,start);
        root-&gt;right=vec2tree(vec,start);
    }
    return root;
}

void tree2vec(treeNode *root,vector&lt;string&gt;&amp; vec){
    if(root==nullptr){
        vec.push_back(&quot;null&quot;);
    }else{
        vec.push_back(root-&gt;val);
        tree2vec(root-&gt;left,vec);
        tree2vec(root-&gt;right,vec);
    }
}

int main(){
    vector&lt;string&gt; vec={&quot;2&quot;,&quot;4&quot;,&quot;5&quot;,&quot;7&quot;,&quot;null&quot;,&quot;null&quot;,&quot;null&quot;,&quot;null&quot;,&quot;3&quot;,&quot;6&quot;,&quot;null&quot;,&quot;null&quot;,&quot;2&quot;,&quot;null&quot;,&quot;null&quot;};
    int index=0,&amp;start=index;
    treeNode* root=vec2tree(vec,start);
    //displaytree(root);
    vector&lt;string&gt; mvec;
    tree2vec(root,mvec);
    for(string item:mvec) cout&lt;&lt;item&lt;&lt;&quot; &quot;;
    cout&lt;&lt;endl;
    return 0;
</code></pre>
<h4 id="14-介绍一下b树和它的应用场景有哪些">（14） 介绍一下b树和它的应用场景有哪些</h4>
<p>B树也叫做B-树，或者平衡多路树，它是每个节点最多有m个子树的<strong>平衡树</strong>。一个m阶的B树具有如下几个特征：</p>
<ol>
<li>根结点至少有两个子女。</li>
<li>每个中间节点都包含至多m个子树 ， 每个节点包含的元素个数是其子树个数-1（其中 m/2 &lt;= k &lt;= m）</li>
<li>所有的叶子结点都位于同一层。</li>
<li>每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个子树包含的元素的值域分划。</li>
</ol>
<p>b树主要应用于文件系统中，在数据库中（mongoDB）也有应用，与B+树相比好处应该是有时不需要访问到叶节点就可以获取数据。</p>
<p>查询时间复杂度是logN</p>
<h4 id="15-介绍一下b树和它的应用场景有哪些">（15） 介绍一下b+树和它的应用场景有哪些</h4>
<p>B+树是一种特殊的B树，它把数据都存储在叶子节点，并且叶节点间有指针连接。内部只存关键字（其中叶子节点的最小值作为索引）和孩子指针，简化了内部节点。</p>
<p>应用场景主要是数据库的索引</p>
<p>查询时间复杂度也是logN<br>
https://zhuanlan.zhihu.com/p/110202102</p>
<p>https://blog.csdn.net/hguisu/article/details/7786014</p>
<h4 id="16-介绍一下红黑树和它的应用场景有哪些">（16） 介绍一下红黑树和它的应用场景有哪些</h4>
<p>红黑树是一种特殊的二叉查找树，它在每一个节点上都使用红色或黑色进行标记，通过一些性质确保它是始终平衡的。<br>
它的性质是这样的：</p>
<ol>
<li>每个节点不是红色就是黑色。</li>
<li>根节点是黑色的。</li>
<li>叶节点的空节点是黑色的。</li>
<li>如果一个节点是红色的，那么它的两个子节点是黑色的。</li>
<li>对于任意节点，从它到叶节点的每条路径上都有相同数目的黑色节点。</li>
</ol>
<p>红黑树的插入，查询，删除在一般情况和最坏情况下的时间复杂度都是O(log(n))</p>
<p>应用场景主要是STL中map，set的实现，优点在于支持频繁的修改，因为查询删除插入时间复杂度都是logN</p>
<h4 id="17-怎么写sql取表的前1000行数据招银网络二面">（17） 怎么写sql取表的前1000行数据（招银网络二面）</h4>
<pre><code class="language-sql">select * limit 1000
from t1
</code></pre>
<h4 id="18-n个骰子出现和为m的概率">（18） N个骰子出现和为m的概率</h4>
<h4 id="19-海量数据问题可参考左神的书">（19） 海量数据问题（可参考左神的书）</h4>
<h4 id="20-一致性哈希">（20） 一致性哈希</h4>
<h4 id="21希尔排序说一下手撕">（21）希尔排序说一下/手撕</h4>
<p>https://www.cnblogs.com/chengxiao/p/6104371.html<br>
希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至1时，整个文件恰被分成一组，算法便终止。</p>
<h4 id="22dijkstra算法说一下">（22）Dijkstra算法说一下</h4>
<h4 id="23实现一个动态数组要怎么实现说思路腾讯teg一面">（23）实现一个动态数组要怎么实现，说思路（腾讯teg一面）</h4>
<p>模拟STL中vector的实现即可，去看一下vector的源码。</p>
<h4 id="24最小生成树算法说一下">（24）最小生成树算法说一下</h4>
<h4 id="25-海量数据的bitmap使用原理">（25） 海量数据的bitmap使用原理</h4>
<p>bitmap算法就是使用一个比特映射一个值，它可以用在整数排序和数据压缩上，因为使用一个比特位去存储一个数，所以它可以大大节省空间。</p>
<p>它的具体过程是：先根据数组中元素最大的数N计算需要分配多大的空间。<br>
如果使用int型数组的形式来保存的话，一个int = 4字节  =4*8比特 = 32比特。也就是一个int数可以映射32个数据（图1），然后需要找到最大的数Max，表示最多需要的位数，所以需要开辟的数组空间为int a[1+Max/32]。<br>
然后需要推导一个整数a内如何映射32个数据，方法是将待存储的数据模32，然后将a中相应位置的比特置为1。<br>
依此方法映射每一个元素，待读取的时候扫描每个比特位，遇到值为1的就还原该数字。<br>
<img src="fig/bitmap1.png" alt="" loading="lazy"></p>
<p><strong>移位计算公式：</strong><br>
N/32就是将N的二进制右移log32（也就是5）位 ： N&gt;&gt;5<br><br>
N%32就是求N的后5位：N&amp; 0x1F  (0x1F = 00011111)<br><br>
模32然后相应位置置为1： a[i] |= 1&lt;&lt; N &amp; 0x1F<br></p>
<p>所以总的公式为： a[ N&gt;&gt;5 ] |= 1&lt;&lt; N &amp; 0x1F<br></p>
<p><strong>BitMap算法评价</strong></p>
<ul>
<li>优点：
<ol>
<li>运算效率高，不进行比较和移位；</li>
<li>占用内存少，比如最大的数MAX=10000000；只需占用内存为MAX/8=1250000Byte=1.25M。</li>
</ol>
</li>
<li>缺点：
<ol>
<li>所有的数据不能重复，即不可对重复的数据进行排序。（少量重复数据查找还是可以的，用2-bitmap）。</li>
<li>所需要的空间随着最大元素的增大而增大，当数据类似（1，1000，10万）只有3个数据的时候，用bitmap时间复杂度和空间复杂度相当大，只有当数据比较密集时才有优势。</li>
</ol>
</li>
</ul>
<h4 id="26-布隆过滤器原理与优点">（26） 布隆过滤器原理与优点</h4>
<p>布隆过滤器是一个比特向量或者比特数组，它本质上是一种概率型数据结构，用来查找一个元素是否在集合中，支持高效插入和查询某条记录。常作为针对超大数据量下高效查找数据的一种方法。</p>
<p><strong>它的具体工作过程是这样子的：</strong><br>
假设布隆过滤器的大小为m（比特向量的长度为m），有k个哈希函数，它对每个数据用这k个哈希函数计算哈希，得到k个哈希值，然后将向量中相应的位设为1。在查询某个数据是否存在的时候，对这个数据用k个哈希函数得到k个哈希值，再在比特向量中相应的位查找是否为1，如果某一个相应的位不为1，那这个数据就肯定不存在。但是如果全找到了，则这个数据有可能存在。</p>
<p><strong>为什么说有可能存在呢？</strong><br>
因为不同的数据经过哈希后可能有相同的哈希值，在比特向量上某个位置查找到1也可能是由于某个另外的数据映射得到的。</p>
<p><strong>支持删除操作吗</strong><br>
目前布隆过滤器只支持插入和查找操作，不支持删除操作，如果要支持删除，就要另外使用一个计数变量，每次将相应的位置为1则计数加一，删除则减一。</p>
<p>布隆过滤器中哈希函数的个数需要选择。如果太多则很快所有位都置为1，如果太少会容易误报。</p>
<p><strong>布隆过滤器的大小以及哈希函数的个数怎么选择？</strong><br>
k 为哈希函数个数，m 为布隆过滤器长度，n 为插入的元素个数，p 为误报率<br>
<img src="fig/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.png" alt="" loading="lazy"></p>
<h4 id="27-布隆过滤器处理大规模问题时的持久化包括内存大小受限-磁盘换入换出问题">（27） 布隆过滤器处理大规模问题时的持久化，包括内存大小受限、磁盘换入换出问题</h4>
<h4 id="28实现一个队列并且使它支持多线程队列有什么应用场景阿里三面">（28）实现一个队列，并且使它支持多线程，队列有什么应用场景（阿里三面）</h4>
<pre><code class="language-C++">//评测题目: 
class FIFOQueue
{
vector&lt;int&gt; vec(initCap,0);
int start=0,end=0;
condition_variable cv;
mutex m;
bool flag=false;// isFull
  bool enqueue(int v) {
  	unique_lock&lt;mutex&gt;&lt;/mutex&gt; lk(m);
    while(flag==true) cv.wait(lk);
        end=(end+1)%initCap;
        vec[end]=v;
        cv.notifyall();
        return true;
    }
  }
  int dequeue() {
  unique_lock&lt;mutex&gt;&lt;/mutex&gt; lk(m);
  	if(start!=end){
    	int val = vec[start];
    	start=(start+1)%initCap;
        flag=false;
    	cv.notifyall();
        return val;
    }else{
    	flag=false;
    	cv.notifyall();
    	return -1;
  	}
  }
}
</code></pre>
<p>以上代码是面试时写的，并没有运行，也许有错误，请客观参考</p>
<h1 id="7-智力题">7. 智力题</h1>
<h4 id="1-100层楼只有2个鸡蛋想要判断出那一层刚好让鸡蛋碎掉给出策略滴滴笔试中两个铁球跟这个是一类题">（1） 100层楼，只有2个鸡蛋，想要判断出那一层刚好让鸡蛋碎掉，给出策略（滴滴笔试中两个铁球跟这个是一类题）</h4>
<ul>
<li>（给定了楼层数和鸡蛋数的情况）二分法+线性查找  从100/2=50楼扔起，如果破了就用另一个从0扔起直到破。如果没破就从50/2=25楼扔起，重复。</li>
<li>动态规划</li>
</ul>
<h4 id="2-毒药问题1000瓶水其中有一瓶可以无限稀释的毒药要快速找出哪一瓶有毒需要几只小白鼠">（2） 毒药问题，1000瓶水，其中有一瓶可以无限稀释的毒药，要快速找出哪一瓶有毒，需要几只小白鼠</h4>
<p>用二进制的思路解决问题。2的十次方是1024，使用十只小鼠喝一次即可。方法是先将每瓶水编号，同时10个小鼠分别表示二进制中的一个位。将每瓶水混合到水瓶编号中二进制为1的小鼠对应的水中。喝完后统计，将死亡小鼠对应的位置为1，没死的置为0，根据死亡小鼠的编号确定有毒的是哪瓶水，如0000001010表示10号水有毒。</p>
<h4 id="3">（3）</h4>
<h4 id="4-先手必胜策略问题100本书每次能够拿1-5本怎么拿能保证最后一次是你拿">（4） 先手必胜策略问题：100本书，每次能够拿1-5本，怎么拿能保证最后一次是你拿</h4>
<p>寻找每个回合固定的拿取模式。最后一次是我拿，那么上个回合最少剩下6本。那么只要保持每个回合结束后都剩下6的倍数，并且在这个回合中我拿的和对方拿的加起来为6（这样这个回合结束后剩下的还是6的倍数），就必胜。关键是第一次我必须先手拿（100%6=4）本（这不算在第一回合里面）。</p>
<h4 id="5-放n只蚂蚁在一条树枝上蚂蚁与蚂蚁之间碰到就各自往反方向走问总距离或者时间">（5） 放n只蚂蚁在一条树枝上，蚂蚁与蚂蚁之间碰到就各自往反方向走，问总距离或者时间。</h4>
<p>碰到就当没发生，继续走，相当于碰到的两个蚂蚁交换了一下身体。其实就是每个蚂蚁从当前位置一直走直到停止的总距离或者时间。</p>
<h4 id="6-瓶子换饮料问题1000瓶饮料3个空瓶子能够换1瓶饮料问最多能喝几瓶">（6） 瓶子换饮料问题：1000瓶饮料，3个空瓶子能够换1瓶饮料，问最多能喝几瓶</h4>
<p>拿走3瓶，换回1瓶，相当于减少2瓶。但是最后剩下4瓶的时候例外，这时只能换1瓶。所以我们计算1000减2能减多少次，直到剩下4.（1000-4=996，996/2=498）所以1000减2能减498次直到剩下4瓶，最后剩下的4瓶还可以换一瓶，所以总共是1000+498+1=1499瓶。</p>
<h4 id="7在24小时里面时针分针秒针可以重合几次">（7）在24小时里面时针分针秒针可以重合几次</h4>
<p>24小时中时针走2圈，而分针走24圈，时针和分针重合24-2=22次，而只要时针和分针重合，秒针一定有机会重合，所以总共重合22次</p>
<h4 id="8-有一个天平九个砝码一个轻一些用天平至少几次能找到轻的">（8） 有一个天平，九个砝码，一个轻一些，用天平至少几次能找到轻的？</h4>
<p>至少2次：第一次，一边3个，哪边轻就在哪边，一样重就是剩余的3个；<br>
第二次，一边1个，哪边轻就是哪个，一样重就是剩余的那个；</p>
<h4 id="9-有十组砝码每组十个每个砝码重10g其中一组每个只有9g有能显示克数的秤最少几次能找到轻的那一组砝码">（9） 有十组砝码每组十个，每个砝码重10g，其中一组每个只有9g，有能显示克数的秤最少几次能找到轻的那一组砝码？</h4>
<p>砝码分组1~10，第一组拿一个，第二组拿两个以此类推。。第十组拿十个放到秤上称出克数x，则y = 550 - x，第y组就是轻的那组</p>
<h4 id="10生成随机数问题给定生成1到5的随机数rand5如何得到生成1到7的随机数函数rand7">（10）生成随机数问题：给定生成1到5的随机数Rand5()，如何得到生成1到7的随机数函数Rand7()？</h4>
<p>思路：由大的生成小的容易，比如由Rand7()生成Rand5()，所以我们先构造一个大于7的随机数生成函数。<br>
记住下面这个式子：</p>
<pre><code>RandNN= N( RandN()-1 ) + RandN() ;// 生成1到N^2之间的随机数
可以看作是在数轴上撒豆子。N是跨度/步长，是RandN()生成的数的范围长度，RandN()-1的目的是生成0到N-1的数，是跳数。后面+RandN()的目的是填满中间的空隙
</code></pre>
<p>比如<code>Rand25= 5( Rand5()-1 ) + Rand5()</code>可以生成1到25之间的随机数。我们可以只要1到21（3*7）之间的数字，所以可以这么写</p>
<pre><code>int rand7(){
  int x=INT_MAX;
  while(x&gt;21){
    x=5*(rand5()-1)+rand5();
  }
  return x%7+1;
}
</code></pre>
<h4 id="赛马有25匹马每场比赛只能赛5匹至少要赛多少场才能找到最快的3匹马">赛马：有25匹马，每场比赛只能赛5匹，至少要赛多少场才能找到最快的3匹马？</h4>
<ul>
<li>第一次，分成5个赛道ABCDE，每个赛道5匹马，每个赛道比赛一场，每个赛道的第12345名记为 A1,A2,A3,A4,A5  B1,B2,B3,B4,B5等等，这一步要赛5场。</li>
<li>第二次，我们将每个赛道的前三名，共15匹。分成三组，然后每组进行比赛。这一步要赛3场。</li>
<li>第三次，我们取每组的前三名。共9匹，第一名赛道的马编号为1a,1b,1c，第二名赛道的马编号为2a,2b,2c，第三名赛道的马编号为3a,3b,3c。这时进行分析，1a表示第一名里面的第一名，绝对是所有马中的第一，所以不用再比了。2c表示第二名的三匹里头的最后一匹，3b和3c表示第三名里面的倒数两匹，不可能是所有马里面的前三名，所以也直接排除，剩下1b,1c,2a,2b,,3a，共5匹，再赛跑一次取第一第二名，加上刚筛选出来的1a就是所有马里面的最快3匹了。这一步要赛1场。</li>
<li>所以一共是5+3+1=9场。</li>
</ul>
<h4 id="烧-香绳子其他-确定时间问题有两根不均匀的香燃烧完都需要一个小时问怎么确定15分钟的时长">烧 香/绳子/其他 确定时间问题：有两根不均匀的香，燃烧完都需要一个小时，问怎么确定15分钟的时长？</h4>
<p>（说了求15分钟，没说开始的15分钟还是结束的15分钟，这里是可以求最后的15分钟）点燃一根A，同时点燃另一根B的两端，当另一根B烧完的时候就是半小时，这是再将A的另一端也点燃，从这时到A燃烧完就正好15分钟。</p>
<h4 id="掰巧克力问题-nm块巧克力每次掰一块的一行或一列掰成11的巧克力需要多少次1000个人参加辩论赛1v1输了就退出需要安排多少场比赛">掰巧克力问题 N<em>M块巧克力，每次掰一块的一行或一列，掰成1</em>1的巧克力需要多少次？（1000个人参加辩论赛，1V1，输了就退出，需要安排多少场比赛）</h4>
<p>每次拿起一块巧克力，掰一下（无论横着还是竖着）都会变成两块，因为所有的巧克力共有N*M块，所以要掰N*M-1次，-1是因为最开始的一块是不用算进去的。</p>
<p>每一场辩论赛参加两个人，消失一个人，所以可以看作是每一场辩论赛减少一个人，直到最后剩下1个人，所以是1000-1=999场。</p>
<h1 id="8-大数据">8. 大数据</h1>
<h4 id="1-介绍一下hadoop">1. 介绍一下Hadoop</h4>
<p>Hadoop是一套大数据解决方案，提供了一套分布式的系统基础架构，包括HDFS，MapReduce和YARN。</p>
<ul>
<li>HDFS提供分布式的数据存储</li>
<li>MapReduce负责进行数据运算</li>
<li>YARN负责任务调度</li>
</ul>
<p>HDFS是主从架构的，包括namenode，secondarynamenode和datanode。datanode负责存储数据，namenode负责管理HDFS的目录树和文件元信息。<br><br>
MapReduce包括jobtracker,tasktracker和client。Jobtracker负责进行资源调度和作业监控。tasktracker会周期性的通过心跳向jobtracker汇报资源使用情况。</p>
<h4 id="2-说一下mapreduce的运行机制">2. 说一下MapReduce的运行机制</h4>
<p>MapReduce包括输入分片、map阶段、combine阶段、shuffle阶段和reduce阶段。分布式计算框架包括client，jobtracker和tasktracker和调度器。</p>
<ul>
<li>输入分片阶段，mapreduce会根据输入文件计算分片，每个分片对应一个map任务</li>
<li>map阶段会根据mapper方法的业务逻辑进行计算，映射成键值对</li>
<li>combine阶段是在节点本机进行一个reduce，减少传输结果对带宽的占用</li>
<li>shuffle阶段是对map阶段的结果进行分区，排序，溢出然后写入磁盘。将map端输出的无规则的数据整理成为有一定规则的数据，方便reduce端进行处理，有点像洗牌的逆过程。  https://blog.csdn.net/ASN_forever/article/details/81233547</li>
<li>reduce阶段是根据reducer方法的业务逻辑进行计算，最终结果会存在hdfs上。</li>
</ul>
<h4 id="3-介绍一下kafka">3. 介绍一下kafka</h4>
<p>https://blog.csdn.net/qq_29186199/article/details/80827085</p>
<p>https://blog.csdn.net/student__software/article/details/81486431</p>
<p>kafka是一个分布式消息队列，包括producer、broker和consumer。kafka会对每个消息根据topic进行归类，每个topic又会分成多个partition，消息会根据先进先出的方式存储。消费者通过offset进行消费。</p>
<p>kafka的特点是吞吐量高，可以进行持久化，高可用。</p>
<h4 id="4-为什么kafka吞吐量高介绍一下零拷贝">4. 为什么kafka吞吐量高？/介绍一下零拷贝</h4>
<p>kafka吞吐量高是因为一个利用了磁盘顺序读写的特性，速度比随机读写要快很多，另一个是使用了零拷贝，数据直接在内核进行输入和输出，减少了用户空间和内核空间的切换。</p>
<p>零拷贝：传统文件读取并发送至网络的步骤是：先将文件从磁盘拷贝到内核空间，然后内核空间拷贝到用户空间的缓冲区，再从用户空间拷贝到内核空间的socket缓冲区，最后拷贝到网卡并发送。而零拷贝技术是先将文件从磁盘空间拷贝到内核缓冲区，然后直接拷贝至网卡进行发送，减少了重复拷贝操作。</p>
<h4 id="5-介绍一下spark">5. 介绍一下spark</h4>
<p>https://blog.csdn.net/u011204847/article/details/51010205</p>
<p>spark是一个通用内存并行计算框架。它可以在内存中对数据进行计算，效率很高，spark的数据被抽象成RDD（弹性分布式数据集）并且拥有DAG执行引擎，兼容性和通用性很好。可以和Hadoop协同工作。</p>
<h4 id="6-介绍一下spark-streaming">6. 介绍一下spark-streaming</h4>
<p>https://blog.csdn.net/yu0_zhang0/article/details/80569946</p>
<p>spark-streaming是spark的核心组件之一。主要提供高效的流计算能力。spark-streaming的原理是将输入数据流以时间片进行拆分，然后经过spark引擎以类似批处理的方式处理每个时间片数据。</p>
<p>spark-streaming将输入根据时间片划分成一段一段的Dstream（也就是离散数据流），然后将每一段数据转换成RDD进行操作。</p>
<h4 id="7-spark的transformation和action有什么区别">7. spark的transformation和action有什么区别</h4>
<p>spark的算子分成transformation和action两类</p>
<ul>
<li>transformation是变换算子，这类算子不会触发提交，是延迟执行的。也就是说执行到transformation算子的时候数据并没有马上进行计算，只是记住了对RDD的逻辑操作</li>
<li>action算子是执行算子，会出发spark提交作业，并将数据输出到spark</li>
</ul>
<h4 id="8-spark常用的算子说几个">8. spark常用的算子说几个</h4>
<p>spark的算子分为两类：transformation和action</p>
<p>常用的transformation算子：</p>
<pre><code class="language-scala">// union 求并集
val rdd8 = rdd6.union(rdd7)

// intersection 求交集 
val rdd9 = rdd6.intersection(rdd7)

// join 将rdd进行聚合连接，类似数据库的join 
val rdd3 = rdd1.join(rdd2)

// map flatMap mapPartition 传入一个函数对数据集中的每一个数据进行操作 
val arr1 = Array(1,2,3,4,5)
val arr2 = rdd1.map(_+1)

// countByKey reduceByKey partitionByKey 统计每个key有多少个键值对 
</code></pre>
<p>常用的action算子</p>
<pre><code class="language-scala">// reduce 按照一定的方法将元素进行合并 
val rdd2 = rdd1.reduce(_+_)

// collect 将RDD转换为数组
rdd1.collect

// top 返回最大的k个元素
rdd1.top(2)
</code></pre>
<h4 id="9-如何保证kafka的消息不丢失">9. 如何保证kafka的消息不丢失</h4>
<p>https://blog.csdn.net/liudashuang2017/article/details/88576274</p>
<p>我们可以从三个方面保证kafka不丢失消息</p>
<ul>
<li>首先从producer生产者方面，为send()方法注册一个回调函数，可以得知消息发送有没有成功；将重试次数retrie设置为3；设置acks参数为all，当消息被写入所有同步副本之后才算发送成功。</li>
<li>在consumer消费者方面，关闭自动提交；</li>
<li>在broker集群方面，设置复制系数replica.factor为大于等于3</li>
</ul>
<h4 id="10-kafka如何选举leader">10. kafka如何选举leader</h4>
<p>首先启动的broker在zookeeper中创建一个临时节点并让自己称为leader，其他的节点会创建watch对象进行监听并成为follower，当broker宕机的时候，其他follower会尝试创建这个临时节点，但是只有一个能够创建成功，创建成功的broker就会成为leader。</p>
<h4 id="11-说下spark中的宽依赖和窄依赖">11. 说下spark中的宽依赖和窄依赖</h4>
<p>https://blog.csdn.net/a1043498776/article/details/54889922</p>
<ul>
<li>宽依赖：指子RDD的分区依赖于父RDD的所有分区，举例：groupbykey,join</li>
<li>窄依赖：指父RDD的每个分区被最多一个子RDD的分区所依赖,举例：map，filter<br>
<img src="https://img-blog.csdn.net/20170206221148299?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYTEwNDM0OTg3NzY=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="" loading="lazy"></li>
</ul>
<h4 id="12-说下spark中stage是依照什么划分的">12. 说下spark中stage是依照什么划分的</h4>
<p>https://zhuanlan.zhihu.com/p/57124273</p>
<p>spark中的stage其实是一组并行的任务，spark会将多个RDD根据依赖关系划分成有向无环图DAG，DAG会被划分成多个stage，划分的依据是RDD之间的宽窄依赖。遇到宽依赖就划分stage。因为宽依赖与窄依赖的区别之一就是宽依赖会发生shuffle操作，所以也可以说stage的划分依据是是否发生shuffle操作。</p>
<h4 id="13-spark的内存管理是怎样的">13. spark的内存管理是怎样的</h4>
<p>https://www.jianshu.com/p/4f1e551553ae</p>
<p>https://www.cnblogs.com/wzj4858/p/8204282.html</p>
<p>spark的内存包括静态内存管理和统一内存管理两种机制。静态内存管理中存储和执行两块内存区域是分开的，统一内存管理中两块内存之间可以相互借用<br></p>
<ul>
<li>静态内存管理：静态内存管理机制下堆内内存包括安全内存，存储内存，shuffle内存和unroll内存</li>
</ul>
<figure data-type="image" tabindex="6"><img src="fig/spark%E5%86%85%E5%AD%98%E4%B8%80.png" alt="" loading="lazy"></figure>
<ul>
<li>统一内存管理：统一内存管理机制下内存分为spark内存，用户内存和保留内存三部分。用户内存存放用户代码逻辑和自定义数据结构等，保留内存存放的是spark的内部对象和逻辑。<br>
<img src="https://upload-images.jianshu.io/upload_images/195230-f119edabb5683f38.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1200/format/webp" alt="" loading="lazy"></li>
</ul>
<h4 id="14-spark的容错机制是什么样的">14. spark的容错机制是什么样的</h4>
<p>https://blog.csdn.net/dengxing1234/article/details/73613484</p>
<p>spark的容错机制是通过血统（lineage）和checkpoint来实现的 。</p>
<ul>
<li>RDD的lineage可以看作是一个重做日志（redo log）记录的是它粗粒度上的transformation操作。当rdd的分区数据丢失时，它可以根据lineage重新计算来恢复数据。 在窄依赖上可以直接计算父RDD的节点数据进行恢复，在宽依赖上则要等到父RDD所有数据计算完后并将结果shuffle到子RDD上才能完成恢复。</li>
<li>如果DAG中的lineage过长，或者在宽依赖上进行checkpoint的收益更大，就会使用checkpoint进行容错，将RDD写入磁盘进行持久化存储，如果节点数据丢失，就从磁盘读取数据进行恢复。</li>
</ul>
<h1 id="9-hr面">9. HR面</h1>
<h4 id="1-自我介绍">1. 自我介绍</h4>
<p>（HR面试的自我介绍可以侧重软实力部分，项目技术方面介绍可以适当少一些）</p>
<h4 id="2-项目中遇到的最大难点">2. 项目中遇到的最大难点</h4>
<ul>
<li>
<p>在项目中曾经遇到了新的框架不知道该如何上手的问题，以及面对新的概念，新的技术不知道从何学起。解决的办法是在官网寻找说明文档和demo，按照说明文档上的内容一步步了解，以及咨询身边有用过这个框架的同学，或者在CSDN上寻找相关博客。</p>
</li>
<li>
<p>项目的时间比较紧迫，没有那么多的时间可以用。解决方法是把还没有完成的项目分一个轻重缓急，在有限的时间里，先做重要而且紧急的，然后完成紧急的，再做重要的。利用轻重缓急做一个取舍。</p>
</li>
</ul>
<h4 id="3-项目中的收获">3. 项目中的收获</h4>
<p>一个是了解了相关框架的使用方法（比如Dataframe的使用，xgboost的使用等等），这些框架或者技术可以在以后的开发中使用到。和对自己开发能力的锻炼。</p>
<p>一个是锻炼了与他人的交流能力，因为在团队项目里经常会跟别人汇报自己的想法和进度，同时也会跟其他成员沟通模块之间的交互，所以在这个过程中对自己的表达能力和理解能力都是一个很大的提升。</p>
<h4 id="4-可以实习的时间实习时长">4. 可以实习的时间，实习时长</h4>
<p>一定要往长了说！半年起步，最好七八个月，因为实习生是可以随时跑路的。而且实习时间越长HR越青睐。</p>
<h4 id="5-哪里人">5. 哪里人</h4>
<h4 id="6-说一下自己的性格">6. 说一下自己的性格</h4>
<p>我是比较内向谨慎的人，平时做的多说的少。比较善于总结，在与人交流的时候更倾向于倾听别人的意见后才发言。并且别人都说我办事认真靠谱。</p>
<h4 id="7-你的优缺点是什么">7. 你的优缺点是什么</h4>
<p>我的缺点是容易在一些细节的地方花费太多的时间，有时候过分追求细节。并且我的实习经验比较缺乏，对于实际项目的业务流程和工作流程不是很了解。（所以我打算通过实习来熟悉实际的软件开发的流程和技术。）</p>
<p>我的优点是责任心比较强，做事比较负责，在校期间我负责的大创项目进展很顺利，我经常组织组员们进行讨论和推进项目的开发，最后这个项目得到了92的评分，在同级别里面是比较高的。</p>
<h4 id="8-有什么兴趣爱好画的怎么样球打的如何游戏打的怎么样">8. 有什么兴趣爱好，画的怎么样/球打的如何/游戏打的怎么样</h4>
<p>平时的爱好是画画打游戏，在CSDN写写博客，还有就是看书，我很喜欢学到新知识掌握新技能的感觉。</p>
<h4 id="9-看过最好的一本书是什么">9. 看过最好的一本书是什么</h4>
<p>技术类：编程之美 机器学习西瓜书 STL源码剖析 剑指offer C++primer plus</p>
<p>非技术类：明朝那些事儿 香水（聚斯金德） 解忧杂货店 人类简史 沉默的大多数 与时间做朋友（李笑来） 千年历史千年诗</p>
<h4 id="10-学习技术中有什么难点">10. 学习技术中有什么难点</h4>
<h4 id="11-怎么看待加班">11. 怎么看待加班</h4>
<p>我觉得 任何一家单位都有可能要加班。如果自己的工作没有按时完成，那自觉加班是理所当然的，当然，自己要不断提高工作效率，避免这种原因导致的加班。如果遇到紧急任务或者突发状况时，为了顺利配合团队完成任务，我会尽自己所能加班共同完成。</p>
<h4 id="12-觉得深圳怎么样或者其他地点">12. 觉得深圳怎么样（或者其他地点）</h4>
<h4 id="13-遇见过最大的挫折是什么怎么解决的">13. 遇见过最大的挫折是什么，怎么解决的</h4>
<h4 id="14-职业规划">14. 职业规划</h4>
<p>在工作的第一个阶段，先尽快适应工作的环境，包括开发环境开发工具和工作流程等，把自己负责的部分快速的完成，不能出差错。第二个阶段要熟悉整个项目的业务流程，所有模块的结构和依赖关系，知道每个模块为什么要这么设计，以及它们的实现细节。第三个阶段要培养独立设计一个项目的能力，可以独立或者在别人的协作下设计项目的模块分工和架构。</p>
<p>在工作和项目中多写博客或者笔记，积累技术影响力，将经验总结成文档。同时与同事搞好关系，尝试培养领导能力和组织能力。</p>
<h4 id="15-目前的offer情况">15. 目前的offer情况</h4>
<p>可以如实说</p>
<h4 id="16-你最大的优势和劣势是什么">16. 你最大的优势和劣势是什么</h4>
<ul>
<li>优势：做事情有主动性，不拖沓，有责任心。举个例子：在做论文课题的时候，几乎都是我自己找老师汇报进度和找老师讨论问题，很少有被老师催的时候。每一次跟老师讨论之后都会将讨论的内容和老师提出的意见进行详细记录。在中软杯的比赛中，主动承担答辩ppt的制作，并且每次排练之后都迅速对ppt的修改意见进行落实修改，前前后后改了十几版。</li>
<li>劣势：有时候做事情比较急躁，容易导致粗心。</li>
</ul>
<h4 id="17-介绍在项目里面充当的角色">17. 介绍在项目里面充当的角色</h4>
<h4 id="18-介绍一下本科获得的全国赛奖项的情况">18. 介绍一下本科获得的全国赛奖项的情况</h4>
<h4 id="19-最有成就感的事情最骄傲的一件事情">19. 最有成就感的事情/最骄傲的一件事情</h4>
<ul>
<li>本科的时候跟优秀的队友们一起参加中国软件杯比赛努力了四个月，最后获得了该赛题的第一名和全国一等奖的好成绩</li>
<li>保研夏令营拿到了四个学校的offer</li>
</ul>
<h4 id="20-在实验室中担任什么角色参加的xxx能聊聊吗">20. 在实验室中担任什么角色，参加的XXX能聊聊吗</h4>
<h4 id="22-用两个词来形容自己">22. 用两个词来形容自己</h4>
<p>踏实 认真</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11新特性（五）]]></title>
        <id>https://tangyin1.github.io/post/c11-xin-te-xing-wu/</id>
        <link href="https://tangyin1.github.io/post/c11-xin-te-xing-wu/">
        </link>
        <updated>2023-11-30T08:53:59.000Z</updated>
        <content type="html"><![CDATA[<h3 id="1-可调用对象包装器和绑定器">1、可调用对象包装器和绑定器</h3>
<h4 id="什么是可调用对象">什么是可调用对象</h4>
<p>c++11中有一个重要的概念叫做<font color='red'>可调用对象(Callable Objects)。</font></p>
<p><strong>可调用对象用处广泛，比如在使用一些基于范围的模板函数时（如 sort()、all_of()、find_if() 等），常常需要我们传入一个可调用对象，以指明我们需要对范围中的每个元素进行怎样的处理。</strong><br>
又比如，在处理一些回调函数、触发函数时，也常常会使用可调用对象。</p>
<p>总的来说，可调用对象可以是以下几种情况：</p>
<ul>
<li>普通函数</li>
<li>函数指针</li>
<li>仿函数，即重载了operator()运算符的类对象</li>
<li>匿名函数，即Lambda表达式</li>
<li>std::function</li>
</ul>
<h4 id="可调用对象包装器-function">可调用对象包装器 function</h4>
<p>首先需要在头文件里面包含#include<functional></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;functional&gt;
using namespace std;
int add(int a, int b)
{
    cout &lt;&lt; a &lt;&lt; &quot; + &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a + b &lt;&lt; endl;
    return a + b;
}

class T1
{
public:
    static int sub(int a, int b)
    {
        cout &lt;&lt; a &lt;&lt; &quot; - &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a - b &lt;&lt; endl;
        return a - b;
    }
};

class T2
{
public:
    int operator()(int a, int b)
    {
        cout &lt;&lt; a &lt;&lt; &quot; * &quot; &lt;&lt; b &lt;&lt; &quot; = &quot; &lt;&lt; a * b &lt;&lt; endl;
        return a * b;
    }
};

int main()
{
    //包装普通函数
    function&lt;int(int, int)&gt;f1 = add;
    //包装类的静态函数
    function&lt;int(int, int)&gt;f2 = T1::sub;
    //包装仿函数
    T2 t;
    function&lt;int(int, int)&gt;f3 = t;
    //调用
    f1(1, 2);
    f2(3, 4);
    f3(5, 6);
	system(&quot;pause&quot;);
	return 0;

}
</code></pre>
<h4 id="可调用对象绑定器-bind">可调用对象绑定器 bind</h4>
<p>bind()函数同样在头文件<font color='red'>functional</font>里面</p>
<p>std::bind用来将可调用对象与其参数一起进行绑定。绑定后的结果可以使用std::function进行保存，并延迟调用到任何我们需要的时候。通俗来讲，它主要有两大作用：</p>
<ol>
<li>
<p>将可调用对象与其参数一起绑定成一个仿函数。</p>
</li>
<li>
<p>将多元（参数个数为n，n&gt;1）可调用对象转换为一元或者（n-1）元可调用对象，即只绑定部分参数。</p>
</li>
</ol>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;functional&gt;
using namespace std;
void output(int x, int y)
{
	cout &lt;&lt; x &lt;&lt; &quot; &quot; &lt;&lt; y &lt;&lt; endl;
}

int main()
{
    // 使用绑定器绑定可调用对象和参数, 并调用得到的仿函数
    bind(output, 1, 2)();
    bind(output, placeholders::_1, 2)(10);
    bind(output, 2, placeholders::_1)(10);

    // error, 调用时没有第二个参数
    // bind(output, 2, placeholders::_2)(10);
    // 调用时第一个参数10被吞掉了，没有被使用
    bind(output, 2, placeholders::_2)(10, 20);
    
    bind(output, placeholders::_1, placeholders::_2)(10, 20);
    bind(output, placeholders::_2, placeholders::_1)(10, 20);
    
    system(&quot;pause&quot;);
    return 0;
}
</code></pre>
<p>绑定类内元素</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;functional&gt;
using namespace std;
class A
{
public:
	void print(int a, int b)
	{
		cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; endl;
	}
	int c;

};
int main()
{
	A aa;
	//绑定类内函数
	auto f1 = bind(&amp;A::print,&amp;aa, placeholders::_1,placeholders::_2);//自动推导得出的仿函数类型
	function&lt;void(int,int)&gt; f11 = 
	bind(&amp;A::print, &amp;aa, placeholders::_1, placeholders::_2);//进行了function包装，二者参数类型不同
	f1(1,2);
	f11(8,9);
	//绑定类内成员变量
	auto f22 = bind(&amp;A::c, &amp;aa);
	function&lt;int&amp;(void)&gt; f2=bind(&amp;A::c, &amp;aa);
	f2() = 3;
	cout &lt;&lt; f2() &lt;&lt; endl;
	f22() = 4;
	cout &lt;&lt; f22() &lt;&lt; endl;
	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
<p>在用绑定器绑定类成员函数或者成员变量的时候需要将它们所属的实例对象一并传递到绑定器函数内部。<font color='red'>f1的类型是function&lt;void(int, int)&gt;，通过使用std::bind将Test的成员函数output的地址和对象t绑定，并转化为一个仿函数并存储到对象f1中。</font></p>
<p><font color='red'>使用绑定器绑定的类成员变量m_number得到的仿函数被存储到了类型为function&lt;int&amp;(void)&gt;的包装器对象f2中，并且可以在需要的时候修改这个成员。其中int是绑定的类成员的类型，并且允许修改绑定的变量，因此需要指定为变量的引用，由于没有参数因此参数列表指定为void。</font></p>
<p>示例程序中是使用function包装器保存了bind返回的仿函数，如果不知道包装器的模板类型如何指定，可以直接使用auto进行类型的自动推导，这样使用起来会更容易一些。</p>
<h3 id="2-右值引用">2、右值引用</h3>
<p>C++11 增加了一个新的类型，称为右值引用（ R-value reference），标记为<code>&amp;&amp;</code>。在介绍右值引用类型之前先要了解什么是左值和右值：</p>
<ul>
<li>lvalue 是<code>loactor value</code>的缩写，rvalue 是 <code>read value</code>的缩写</li>
<li>左值是指存储在内存中、有明确存储地址（可取地址）的数据；</li>
<li>右值是指可以提供数据值的数据（不可取地址）；</li>
</ul>
<p>通过描述可以看出，区分左值与右值的便捷方法是：可以对表达式取地址（&amp;）就是左值，否则为右值 。所有有名字的变量或对象都是左值，而右值是匿名的。</p>
<pre><code class="language-c++">#include &lt;iostream&gt;
using namespace std;

int&amp;&amp; value = 520;
class Test
{
public:
    Test()
    {
        cout &lt;&lt; &quot;construct: my name is jerry&quot; &lt;&lt; endl;
    }
    Test(const Test&amp; a)
    {
        cout &lt;&lt; &quot;copy construct: my name is tom&quot; &lt;&lt; endl;
    }
};

Test getObj()
{
    return Test();
}

int main()
{
    int a1;
    int &amp;&amp;a2 = a1;        // error
    Test&amp; t = getObj();   // error
    Test &amp;&amp; t = getObj();
    const Test&amp; t = getObj();
    return 0;
}
</code></pre>
<ul>
<li>在上面的例子中<code>int&amp;&amp; value = 520;</code>里面<code>520</code>是纯右值，<code>value</code>是对字面量<code>520</code>这个右值的引用。</li>
<li>在<code>int &amp;&amp;a2 = a1;</code>中<code>a1</code>虽然写在了<code>=</code>右边，但是它仍然是一个左值，<code>使用左值初始化一个右值引用类型是不合法的。</code></li>
<li>在<code>Test&amp; t = getObj()</code>这句代码中语法是错误的，<code>右值不能给普通的左值引用赋值。</code></li>
<li>在<code>Test &amp;&amp; t = getObj();</code>中<code>getObj()</code>返回的<code>临时对象</code>被称之为<code>将亡值</code>，<code>t</code>是这个将亡值的右值引用。</li>
<li><code>const Test&amp; t = getObj()</code>这句代码的语法是正确的，<code>常量左值引用是一个万能引用类型，它可以接受左值、右值、常量左值和常量右值。</code></li>
</ul>
<p><font color='red'>在C++中在进行对象赋值操作的时候，很多情况下会发生对象之间的深拷贝，如果堆内存很大，这个拷贝的代价也就非常大，在某些情况下，如果想要避免对象的深拷贝，就可以使用右值引用进行性能的优化。</font></p>
<h4 id="特性">&amp;&amp;特性</h4>
<p>在C++中，<font color='cornflowerblue'>并不是所有情况下 &amp;&amp; 都代表是一个右值引用</font>，具体的场景体现在模板和自动类型推导中，如果是模板参数需要指定为T&amp;&amp;，如果是自动类型推导需要指定为auto &amp;&amp;，在这两种场景下 &amp;&amp;被称作未定的引用类型。另外还有一点需要额外注意<font color='red'>const T&amp;&amp;表示一个右值引用，不是未定引用类型。</font></p>
<ol>
<li><font color='red'> 左值和右值是独立于他们的类型的，右值引用类型可能是左值也可能是右值。</font></li>
<li><font color='red'>编译器会将已命名的右值引用视为左值，将未命名的右值引用视为右值。</font></li>
<li><font color='red'>auto&amp;&amp;或者函数参数类型自动推导的T&amp;&amp;是一个未定的引用类型，它可能是左值引用也可能是右值引用类型，这取决于初始化的值类型（上面有例子）。</font></li>
<li><font color='red'>通过右值推导 T&amp;&amp; 或者 auto&amp;&amp; 得到的是一个右值引用类型，其余都是左值引用类型。</font></li>
</ol>
<pre><code class="language-cpp">int&amp;&amp; a1 = 5;
auto&amp;&amp; bb = a1;
auto&amp;&amp; bb1 = 5;

int a2 = 5;
int &amp;a3 = a2;
auto&amp;&amp; cc = a3;
auto&amp;&amp; cc1 = a2;

const int&amp; s1 = 100;
const int&amp;&amp; s2 = 100;
auto&amp;&amp; dd = s1;
auto&amp;&amp; ee = s2;

const auto&amp;&amp; x = 5;
</code></pre>
<ul>
<li>
<p>第2行：a1为右值引用，推导出的bb为左值引用类型</p>
</li>
<li>
<p>第3行：5为右值，推导出的bb1为右值引用类型</p>
</li>
<li>
<p>第7行：a3为左值引用，推导出的cc为左值引用类型</p>
</li>
<li>
<p>第8行：a2为左值，推导出的cc1为左值引用类型</p>
</li>
<li>
<p>第12行：s1为常量左值引用，推导出的dd为常量左值引用类型</p>
</li>
<li>
<p>第13行：s2为常量右值引用，推导出的ee为常量左值引用类型</p>
</li>
<li>
<p>第15行：x为右值引用，不需要推导，只能通过右值初始化</p>
</li>
</ul>
<h3 id="3-转移和完美转发">3、转移和完美转发</h3>
<h4 id="1-move">1、move</h4>
<p>在C++11添加了右值引用，并且不能使用左值初始化右值引用，如果想要使用左值初始化一个右值引用需要借助std::move()函数，使用<font color='red'>std::move方法可以将左值转换为右值。使用这个函数并不能移动任何东西，而是和移动构造函数一样都具有移动语义，将对象的状态或者所有权从一个对象转移到另一个对象，只是转移，没有内存拷贝。</font></p>
<p>（舔狗净身出户，车房还在，只是所有权转移）</p>
<pre><code class="language-cpp">class Test
{
public：
    Test(){}
    ......
}
int main()
{
    Test t;
    Test &amp;&amp; v1 = t;          // error
    Test &amp;&amp; v2 = move(t);    // ok
    return 0;
}
</code></pre>
<ul>
<li>在第4行中，使用左值初始化右值引用，因此语法是错误的</li>
<li>在第5行中，使用move()函数将左值转换为了右值，这样就可以初始化右值引用了。</li>
</ul>
<p>假设一个临时容器很大，并且需要将这个容器赋值给另一个容器，就可以执行如下操作：</p>
<pre><code class="language-cpp">list&lt;string&gt; ls;
ls.push_back(&quot;hello&quot;);
ls.push_back(&quot;world&quot;);
......
list&lt;string&gt; ls1 = ls;        // 需要拷贝, 效率低
list&lt;string&gt; ls2 = move(ls);
</code></pre>
<p>如果不使用std::move，拷贝的代价很大，性能较低。使用move几乎没有任何代价，只是转换了资源的所有权。如果一个对象内部有较大的堆内存或者动态数组时，使用move()就可以非常方便的进行数据所有权的转移。另外，我们也可以给类编写相应的移动构造函数（<font color='red'>T::T(T&amp;&amp; another</font>)）和和具有移动语义的赋值函数（<font color='red'>T&amp;&amp; T::operator=(T&amp;&amp; rhs)</font>），在构造对象和赋值的时候尽可能的进行资源的重复利用，<font color='red'>因为它们都是接收一个右值引用参数。</font></p>
<h4 id="2-forward">2、forward</h4>
<p>// 函数原型</p>
<pre><code class="language-cpp">template &lt;class T&gt; T&amp;&amp; forward (typename remove_reference&lt;T&gt;::type&amp; t) noexcept;
template &lt;class T&gt; T&amp;&amp; forward (typename remove_reference&lt;T&gt;::type&amp;&amp; t) noexcept;

// 精简之后的样子
std::forward&lt;T&gt;(t);
</code></pre>
<ul>
<li><font color='red'>当T为左值引用类型时，t将被转换为T类型的左值</font></li>
<li><font color='red'>当T不是左值引用类型时，t将被转换为T类型的右值</font></li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

template&lt;typename T&gt;
void printValue(T&amp; t)
{
    cout &lt;&lt; &quot;l-value: &quot; &lt;&lt; t &lt;&lt; endl;
}

template&lt;typename T&gt;
void printValue(T&amp;&amp; t)
{
    cout &lt;&lt; &quot;r-value: &quot; &lt;&lt; t &lt;&lt; endl;
}

template&lt;typename T&gt;
void testForward(T &amp;&amp; v)
{
    printValue(v);
    printValue(move(v));
    printValue(forward&lt;T&gt;(v));
    cout &lt;&lt; endl;
}

int main()
{
    testForward(520);
    int num = 1314;
    testForward(num);
    testForward(forward&lt;int&gt;(num));
    testForward(forward&lt;int&amp;&gt;(num));
    testForward(forward&lt;int&amp;&amp;&gt;(num));

    return 0;

}
</code></pre>
<p>测试结果如下</p>
<pre><code class="language-cpp">l-value: 520
r-value: 520
r-value: 520

l-value: 1314
r-value: 1314
l-value: 1314

l-value: 1314
r-value: 1314
r-value: 1314

l-value: 1314
r-value: 1314
l-value: 1314

l-value: 1314
r-value: 1314
r-value: 1314
</code></pre>
<h3 id="4-共享智能指针">4、共享智能指针</h3>
<p>在C++中没有垃圾回收机制，必须自己释放分配的内存，否则就会造成内存泄露。<font color='red'>解决这个问题最有效的方法是使用智能指针</font>（smart pointer）。</p>
<p>智能指针：</p>
<p><font color='red'>是存储指向动态分配（堆）对象指针的类，用于生存期的控制，能够确保在离开指针所在作用域时，自动地销毁动态分配的对象，防止内存泄露。智能指针的核心实现技术是引用计数，每使用它一次，内部引用计数加1，每析构一次内部的引用计数减1，减为0时，删除所指向的堆内存。</font></p>
<p>C++11中提供了三种智能指针，使用这些智能指针时需要引用头文件<memory>：</p>
<ul>
<li>
<pre><code class="language-cpp">- std::shared_ptr：共享的智能指针
- std::unique_ptr：独占的智能指针
- std::weak_ptr：弱引用的智能指针，它不共享指针，不能操作资源，是用来监视shared_ptr的。
</code></pre>
</li>
</ul>
<h4 id="shared_ptr-四种初始化方法">shared_ptr 四种初始化方法</h4>
<ol>
<li>
<p>通过构造函数初始化</p>
</li>
<li>
<p>通过拷贝和移动构造函数初始化</p>
</li>
<li>
<p>通过std::make_shared初始化</p>
</li>
<li>
<p>通过 reset方法初始化</p>
<pre><code class="language-cpp">//共享智能指针
#include &lt;iostream&gt;
#include&lt;memory&gt;
using namespace std;
class Test
{
public:
    Test()
    {
        cout &lt;&lt; &quot;construct Test...&quot; &lt;&lt; endl;
    }
    Test(int x)
    {
        cout &lt;&lt; &quot;construct Test, x = &quot; &lt;&lt; x &lt;&lt; endl;
    }
    Test(string str)
    {
        cout &lt;&lt; &quot;construct Test, str = &quot; &lt;&lt; str &lt;&lt; endl;
    }
    void setValue(int v)
    {
        m_num = v;
    }
    void print()
    {
        cout &lt;&lt; m_num &lt;&lt; endl;
    }
    ~Test()
    {
        cout &lt;&lt; &quot;destruct Test ...&quot; &lt;&lt; endl;
    }
private:
    int m_num;
};

int main()
{
    //通过构造函数初始化
    shared_ptr&lt;int&gt;ptr1(new int(3));
    cout &lt;&lt; &quot;ptr1 use count: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;
    //通过移动构造和拷贝构造函数初始话
    shared_ptr&lt;int&gt;ptr2 = move(ptr1);
    cout &lt;&lt; &quot;ptr1 use count: &quot; &lt;&lt; ptr1.use_count() &lt;&lt; endl;
    cout &lt;&lt; &quot;ptr2 use count: &quot; &lt;&lt; ptr2.use_count() &lt;&lt; endl;
    //通过make_shared初始化
    shared_ptr&lt;int&gt; ptr3 = make_shared&lt;int&gt;(8);
    shared_ptr&lt;Test&gt;ptr4 = make_shared&lt;Test&gt;(0);
    shared_ptr&lt;Test&gt;ptr5 = make_shared&lt;Test&gt;(&quot;hello&quot;);
    cout &lt;&lt; &quot;ptr3 use count: &quot; &lt;&lt; ptr3.use_count() &lt;&lt; endl;
    //通过reset初始化
    ptr5.reset();
    cout &lt;&lt; &quot;ptr5 use count: &quot; &lt;&lt; ptr5.use_count() &lt;&lt; endl;
    ptr5.reset(new Test(&quot;kkk&quot;));
    cout &lt;&lt; &quot;ptr5 use count: &quot; &lt;&lt; ptr5.use_count() &lt;&lt; endl;
    //通过原始指针
    Test* t = ptr5.get();
    t-&gt;setValue(1000);
    t-&gt;print();
    ptr5-&gt;setValue(999);
    ptr5-&gt;print();
	system(&quot;pause&quot;);
	return 0;

}
</code></pre>
</li>
</ol>
<p>获取原始指针</p>
<pre><code class="language-cpp">T* get() const noexcept;
</code></pre>
<h3 id="unique_ptr独占的共享指针">unique_ptr,独占的共享指针</h3>
<pre><code class="language-cpp">#include&lt;iostream&gt;

#include&lt;memory&gt;
using namespace std;
class Test
{
public:
    Test()
    {
        cout &lt;&lt; &quot;construct Test...&quot; &lt;&lt; endl;
    }
    Test(int x)
    {
        cout &lt;&lt; &quot;construct Test, x = &quot; &lt;&lt; x &lt;&lt; endl;
    }
    Test(string str)
    {
        cout &lt;&lt; &quot;construct Test, str = &quot; &lt;&lt; str &lt;&lt; endl;
    }
    void setValue(int v)
    {
        m_num = v;
    }
    void print()
    {
        cout &lt;&lt; m_num &lt;&lt; endl;
    }
    ~Test()
    {
        cout &lt;&lt; &quot;destruct Test ...&quot; &lt;&lt; endl;
    }
private:
    int m_num;
};

unique_ptr&lt;int&gt; func()
{
	return unique_ptr&lt;int&gt;(new int(99));
}
int main()
{
	//初始化
	unique_ptr&lt;int&gt;ptr_1(new int(1));//普通初始化
	unique_ptr&lt;int&gt;ptr2 = move(ptr_1);//使用move
	unique_ptr&lt;int&gt;ptr_3 = func();//将亡值
    shared_ptr&lt;int&gt;pw(new int(777));
	//reset	
	ptr_1.reset();
	ptr2.reset(new int(2)); 
	cout &lt;&lt; *ptr2 &lt;&lt; endl;
    //获取原始指针
    unique_ptr&lt;Test&gt; ppp(new Test (999));
    Test* p = ppp.get();
    p-&gt;setValue(888);
    p-&gt;print();
    //独占智能指针没有use_count()函数
    cout &lt;&lt; pw.use_count() &lt;&lt; endl;;
    //删除器
    using ptrFunc = void(*)(Test*);
    unique_ptr&lt;Test,ptrFunc&gt;prr_9(new Test(&quot;kkkk&quot;), [](Test* t) {
        cout &lt;&lt; &quot;----------&quot; &lt;&lt; endl;
        delete t;

​    });

   ////独占的智能指针可以管理数组类型的地址，能够自动释放
   // unique_ptr &lt;Test[]&gt;ptr_11(new Test[3]);
   // ptr_11 = nullptr;

​	system(&quot;pause&quot;);
​	return 0;

}


</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11新特性（四）]]></title>
        <id>https://tangyin1.github.io/post/c11-xin-te-xing-si/</id>
        <link href="https://tangyin1.github.io/post/c11-xin-te-xing-si/">
        </link>
        <updated>2023-11-22T09:19:06.000Z</updated>
        <summary type="html"><![CDATA[<p>本章节包含<br>
constexpr修饰常量表达式<br>
常量表达式函数<br>
using定义基础类型和函数指针别名<br>
委托构造函数和继承构造函数<br>
列表初始化</p>
]]></summary>
        <content type="html"><![CDATA[<p>本章节包含<br>
constexpr修饰常量表达式<br>
常量表达式函数<br>
using定义基础类型和函数指针别名<br>
委托构造函数和继承构造函数<br>
列表初始化</p>
<!-- more -->
<h3 id="1-constexpr修饰常量表达式">1、constexpr修饰常量表达式</h3>
<p><font color='red'>在c++11以后，表达只读的话使用const 或者constexpr都是可以的，在只读方面二者是等价的，在表示常量的时候建议使用constexptr。</font></p>
<p>在介绍gcc/g++工作流程的时候说过，C++ 程序从编写完毕到执行分为四个阶段：<font color='red'>预处理、 编译、汇编和链接4个阶段</font>，得到可执行程序之后就可以运行了。需要额外强调的是，常量表达式和非常量表达式的计算时机不同，非常量表达式只能在程序运行阶段计算出结果，但是常量表达式的计算往往发生在程序的编译阶段，这可以极大提高程序的执行效率，因为表达式只需要在编译阶段计算一次，节省了每次程序运行时都需要计算一次的时间。</p>
<p>那么问题来了，编译器如何识别表达式是不是常量表达式呢？在C++11中添加了constexpr关键字之后就可以在程序中使用它来修饰常量表达式，用来提高程序的执行效率。在使用中建议将 const 和 constexpr 的功能区分开，<font color='red'>即凡是表达“只读”语义的场景都使用 const</font>，<font color='red'>表</font><font color='red'>达“常量”语义的场景都使用 constexpr。</font></p>
<p>在定义常量时，const 和 constexpr 是等价的，都可以在程序的编译阶段计算出结果，例如：</p>
<pre><code class="language-cpp">const int m = f();  // 不是常量表达式，m的值只有在运行时才会获取。
const int i=520;    // 是一个常量表达式
const int j=i+1;    // 是一个常量表达式

constexpr int i=520;    // 是一个常量表达式
constexpr int j=i+1;    // 是一个常量表达式
</code></pre>
<p>对于 C++ 内置类型的数据，可以直接用 constexpr 修饰，但如果是自定义的数据类型（用 struct 或者 class 实现），直接用 constexpr 修饰是不行的。</p>
<pre><code class="language-cpp">// 此处的constexpr修饰是无效的
constexpr struct Test
{
    int id;
    int num;
};
</code></pre>
<p>如果要定义一个结构体/类常量对象，可以这样写：</p>
<pre><code class="language-cpp">struct Test
{
    int id;
    int num;
};
int main()
{
    constexpr Test t{ 1, 2 };
    constexpr int id = t.id;
    constexpr int num = t.num;
    // error，不能修改常量
    t.num += 100;
    cout &lt;&lt; &quot;id: &quot; &lt;&lt; id &lt;&lt; &quot;, num: &quot; &lt;&lt; num &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>在第13行的代码中t.num += 100;的操作是错误的，对象t是一个常量，因此它的成员也是常量，常量是不能被修改的。</p>
<h3 id="2-常量表达式函数">2、常量表达式函数</h3>
<p>为了提高C++程序的执行效率，我们可以将程序中值不需要发生变化的变量定义为常量，也可以使用constexpr修饰函数的返回值，这种函数被称作常量表达式函数，这些函数主要包括以下几种：<font color='red'>普通函数/类成员函数、类的构造函数、模板函数</font>。</p>
<h4 id="1-constexpr并不能修改任意函数的返回值使这些函数成为常量表达式函数必须要满足以下几个条件">1、constexpr并不能修改任意函数的返回值，使这些函数成为常量表达式函数，必须要满足以下几个条件：</h4>
<ol>
<li>函数必须要有返回值，并且return 返回的表达式必须是常量表达式。</li>
<li>函数在使用之前，必须有对应的定义语句。</li>
<li>整个函数的函数体中，不能出现非常量表达式之外的语句（<font color='red'>using 指令、typedef 语句以及 static_assert 断言、return语句除外</font>）。</li>
</ol>
<pre><code class="language-cpp">// error
constexpr int func1()
{
    constexpr int a = 100;
    constexpr int b = 10;
    for (int i = 0; i &lt; b; ++i)
    {
        cout &lt;&lt; &quot;i: &quot; &lt;&lt; i &lt;&lt; endl;
    }
    return a + b;
}

// ok
constexpr int func2()
{
    using mytype = int;
    constexpr mytype a = 100;
    constexpr mytype b = 10;
    constexpr mytype c = a * b;
    return c - (a + b);
}
</code></pre>
<p>因为func1()是一个常量表达式函数，在函数体内部是不允许出现非常量表达式以外的操作，因此函数体内部的for循环是一个非法操作。</p>
<h4 id="2-修饰模板函数">2、修饰模板函数</h4>
<p>C++11 语法中，constexpr 可以修饰函数模板，但由于模板中类型的不确定性，因此函数模板实例化后的模板函数是否符合常量表达式函数的要求也是不确定的。<font color='red'>如果 constexpr 修饰的模板函数实例化结果不满足常量表达式函数的要求，则 constexpr 会被自动忽略，即该</font><font color='red'>函数就等同于一个普通函数。</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Person {
    const char* name;
    int age;
};

// 定义函数模板
template&lt;typename T&gt;
constexpr T dispaly(T t) {
    return t;
}

int main()
{
    struct Person p { &quot;luffy&quot;, 19 };
    //普通函数
    struct Person ret = dispaly(p);
    cout &lt;&lt; &quot;luffy's name: &quot; &lt;&lt; ret.name &lt;&lt; &quot;, age: &quot; &lt;&lt; ret.age &lt;&lt; endl;

    //常量表达式函数
    constexpr int ret1 = dispaly(250);
    cout &lt;&lt; ret1 &lt;&lt; endl;
    
    constexpr struct Person p1 { &quot;luffy&quot;, 19 };
    constexpr struct Person p2 = dispaly(p1);
    cout &lt;&lt; &quot;luffy's name: &quot; &lt;&lt; p2.name &lt;&lt; &quot;, age: &quot; &lt;&lt; p2.age &lt;&lt; endl;
    return 0;

}
</code></pre>
<p>在上面示例程序中定义了一个函数模板 display()，但由于其返回值类型未定，因此在实例化之前无法判断其是否符合常量表达式函数的要求：</p>
<ul>
<li><font color='red'>struct Person ret = dispaly(p);</font>由于参数p是变量，所以实例化后的函数不是常量表达式函数，此时 constexpr 是无效的</li>
<li><font color='red'>constexpr int ret1 = dispaly(250)</font>;参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的</li>
<li><font color='red'>constexpr struct Person p2 = dispaly(p1)</font>;参数是常量，符合常量表达式函数的要求，此时 constexpr 是有效的</li>
</ul>
<h4 id="3-修饰构造函数">3、修饰构造函数</h4>
<p>如果想用直接得到一个常量对象，也可以使用constexpr修饰一个构造函数，这样就可以得到一个常量构造函数了。常量构造函数有一个要求：构造函数的函数体必须为空，并且必须采用初始化列表的方式为各个成员赋值。</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

struct Person {
    constexpr Person(const char* p, int age) :name(p), age(age)
    {
    }
    const char* name;
    int age;
};

int main()
{
    constexpr struct Person p1(&quot;luffy&quot;, 19);
    cout &lt;&lt; &quot;luffy's name: &quot; &lt;&lt; p1.name &lt;&lt; &quot;, age: &quot; &lt;&lt; p1.age &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="3-通过using定义基础类型和函数指针别名">3、通过using定义基础类型和函数指针别名</h3>
<h4 id="1-定义别名">1、定义别名</h4>
<p>在 C++中可以通过 typedef 重定义一个类型，语法格式如下：</p>
<p>被重定义的类型并不是一个新的类型，仅仅只是原有的类型取了一个新的名字。和以前的声明语句一样，这里的声明符也可以包含类型修饰，从而也能由基本数据类型构造出复合类型来。C++11中规定了一种新的方法，使用别名声明(alias declaration)来定义类型的别名，即使用using。</p>
<p>在使用的时候，关键字using作为别名声明的开始，其后紧跟别名和等号，其作用是把等号左侧的名字规定成等号右侧类型的别名。<font color='red'>类型</font><font color='red'>别名和类型的名字等价，只要是类型的名字能出现的地方，就能使用类型别名。使用typedef定义的别名和使用using定义的别名在语义上</font><font color='red'>是等效的。</font></p>
<p>使用using定义别名的语法格式是这样的：</p>
<pre><code class="language-cpp">using 新的类型 = 旧的类型;
// 使用举例
using uint_t = int;
</code></pre>
<p>通过using和typedef的语法格式可以看到二者的使用没有太大的区别，假设我们定义一个函数指针，using的优势就能凸显出来了，看一下下面的例子：</p>
<pre><code class="language-cpp">// 使用typedef定义函数指针
typedef int(*func_ptr)(int, double);

// 使用using定义函数指针
using func_ptr1 = int(*)(int, double);
</code></pre>
<p>使用using定义函数指针别名的写法看起来就非常直观了，把别名的名字强制分离到了左边，<font color='red'>而把别名对应的实际类型放在了右边，比较清晰，可读性比较好。</font></p>
<h4 id="2-模板的别名">2、模板的别名</h4>
<p>使用typedef重定义类似很方便，但是它有一点限制，比如无法重定义一个模板，比如我们需要一个固定以int类型为key的map，它可以和很多类型的value值进行映射，如果使用typedef这样直接定义就非常麻烦:</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;map&gt;
using namespace std;

template &lt;typename T&gt;
// 定义外敷类
struct MyMap
{
    typedef map&lt;int, T&gt; type;
};

int main(void)
{
    MyMap&lt;string&gt;::type m;
    m.insert(make_pair(1, &quot;luffy&quot;));
    m.insert(make_pair(2, &quot;ace&quot;));

    MyMap&lt;int&gt;::type m1;
    m1.insert(1, 100);
    m1.insert(2, 200);
    
    return 0;

}
</code></pre>
<p>使用using就会很简洁</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;functional&gt;
#include &lt;map&gt;
using namespace std;

template &lt;typename T&gt;
using mymap = map&lt;int, T&gt;;

int main(void)
{
    // map的value指定为string类型
    mymap&lt;string&gt; m;
    m.insert(make_pair(1, &quot;luffy&quot;));
    m.insert(make_pair(2, &quot;ace&quot;));

    // map的value指定为int类型
    mymap&lt;int&gt; m1;
    m1.insert(1, 100);
    m1.insert(2, 200);
    
    return 0;

}
</code></pre>
<p><font color='red'>最后在强调一点：using语法和typedef一样，并不会创建出新的类型，它们只是给某些类型定义了新的别名。using相较于typedef的优势在于定义函数指针别名时看起来更加直观，并且可以给模板定义别名。</font></p>
<h3 id="4-委托构造函数和继承构造函数">4、委托构造函数和继承构造函数</h3>
<h4 id="1-委托构造函数">1、委托构造函数</h4>
<p>在C++11以后，构造函数中构造函数2中有构造函数1，可以在构造函数2里调用构造函数1</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Test
{
public:
    Test() {};
    Test(int max)
    {
        this-&gt;m_max = max &gt; 0 ? max : 100;
    }

    Test(int max, int min):Test(max)
    {
        this-&gt;m_min = min &gt; 0 &amp;&amp; min &lt; max ? min : 1;
    }
    
    Test(int max, int min, int mid):Test(max, min)
    {
        this-&gt;m_middle = mid &lt; max &amp;&amp; mid &gt; min ? mid : 50;
    }
    
    int m_min;
    int m_max;
    int m_middle;

};

int main()
{
    Test t(90, 30, 60);
    cout &lt;&lt; &quot;min: &quot; &lt;&lt; t.m_min &lt;&lt; &quot;, middle: &quot; 
         &lt;&lt; t.m_middle &lt;&lt; &quot;, max: &quot; &lt;&lt; t.m_max &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>在一个构造函数中调用了其他的构造函数用于相关数据的初始化，相当于是一个链式调用。在使用委托构造函数的时候还需要注意一些几个问题：</p>
<p><font color='red'>这种链式的构造函数调用不能形成一个闭环（死循环），否则会在运行期抛异常。</font></p>
<p><font color='red'>如果要进行多层构造函数的链式调用，建议将构造函数的调用的写在初始列表中而不是函数体内部，否则编译器会提示形参的重复定义</font>。</p>
<pre><code class="language-cpp">Test(int max)
{
    this-&gt;m_max = max &gt; 0 ? max : 100;
}

Test(int max, int min)
{
    Test(max);	// error, 此处编译器会报错, 提示形参max被重复定义
    this-&gt;m_min = min &gt; 0 &amp;&amp; min &lt; max ? min : 1;
}
</code></pre>
<p><font color='red'>在初始化列表中调用了代理构造函数初始化某个类成员变量之后，就不能在初始化列表中再次初始化这个变量了。</font></p>
<pre><code class="language-cpp">// 错误, 使用了委托构造函数就不能再次m_max初始化了
Test(int max, int min) : Test(max), m_max(max)
{
    this-&gt;m_min = min &gt; 0 &amp;&amp; min &lt; max ? min : 1;
}
</code></pre>
<h4 id="2-继承构造函数">2、继承构造函数</h4>
<p>C++11中提供的继承构造函数可以让派生类直接使用基类的构造函数，而无需自己再写构造函数，尤其是在基类有很多构造函数的情况下，可以极大地简化派生类构造函数的编写。</p>
<p>继承构造函数的使用方法是这样的：通过使用<font color='red'>using 类名::构造函数名（其实类名和构造函数名是一样的）</font>来声明使用基类的构造函数，这样子类中就可以不定义相同的构造函数了，直接使用基类的构造函数来构造派生类对象</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Base
{
public:
    Base(int i) :m_i(i) {}
    Base(int i, double j) :m_i(i), m_j(j) {}
    Base(int i, double j, string k) :m_i(i), m_j(j), m_k(k) {}

    int m_i;
    double m_j;
    string m_k;

};

class Child : public Base
{
public:
    using Base::Base;
};

int main()
{
    Child c1(520, 13.14);
    cout &lt;&lt; &quot;int: &quot; &lt;&lt; c1.m_i &lt;&lt; &quot;, double: &quot; &lt;&lt; c1.m_j &lt;&lt; endl;
    Child c2(520, 13.14, &quot;i love you&quot;);
    cout &lt;&lt; &quot;int: &quot; &lt;&lt; c2.m_i &lt;&lt; &quot;, double: &quot; 
         &lt;&lt; c2.m_j &lt;&lt; &quot;, string: &quot; &lt;&lt; c2.m_k &lt;&lt; endl;
    return 0;
}
</code></pre>
<h3 id="5-列表初始化">5、列表初始化</h3>
<h4 id="1-统一初始化">1、统一初始化</h4>
<p>C++98：</p>
<pre><code class="language-cpp">// 数组的初始化
int array[] = { 1,3,5,7,9 };
double array1[3] = { 1.2, 1.3, 1.4 };

// 对象的初始化
struct Person
{
    int id;
    double salary;
}zhang3{ 1, 3000 };
</code></pre>
<p>C++11：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

class Test
{
public:
    Test(int) {}
private:
    Test(const Test &amp;);
};

int main(void)
{
    Test t1(520);
    Test t2 = 520; 
    Test t3 = { 520 };
    Test t4{ 520 };
    int a1 = { 1314 };
    int a2{ 1314 };
    int arr1[] = { 1, 2, 3 };
    int arr2[]{ 1, 2, 3 };
    return 0;
}
</code></pre>
<ul>
<li>
<p>t1：最中规中矩的初始化方式，通过提供的带参构造进行对象的初始化</p>
</li>
<li>
<p>t2：语法错误，因为提供的拷贝构造函数是私有的。如果拷贝构造函数是公共的，520会通过隐式类型转换被Test(int)构造成一个匿名对象，然后再通过对这个匿名对象进行拷贝构造得到t2（<font color='red'>这个错误在VS中不会出现</font>，在Linux中使用g++编译会提示描述的这个错误，截图如下。）</p>
</li>
<li>
<p>t3和t4：使用了C++11的初始化方式来初始化对象，效果和t1的方式是相同的。</p>
</li>
<li>
<p>在初始时，{}前面的等号是否书写对初始化行为没有任何影响。</p>
</li>
<li>
<ul>
<li>t3虽然使用了等号，但是它仍然是列表初始化，因此私有的拷贝构造对它没有任何影响。</li>
<li>t1、arr1和t2、arr2：这两个是基础数据类型的列表初始化方式，可以看到，和对象的初始化方式是统一的。</li>
</ul>
</li>
<li>
<p>t4、a2、arr2的写法，<font color='red'>是C++11中新添加的语法格式，使用这种方式可以直接在变量名后边跟上初始化列表，来进行变量或者对象的初始化</font></p>
</li>
</ul>
<h4 id="2-列表初始化细节">2、列表初始化细节</h4>
<h5 id="1-聚合体">1、聚合体</h5>
<ul>
<li>普通数组本身可以看做是一个聚合类型</li>
<li>满足以下条件的类（class、struct、union）可以被看做是一个聚合类型：</li>
</ul>
<p>​		<font color='cornflowerblue'>（1）无用户自定义的构造函数。</font></p>
<p>​		<font color='cornflowerblue'>（2）无私有或保护的非静态数据成员。</font></p>
<p>​		<font color='cornflowerblue'>（3）无基类。</font></p>
<p>​		<font color='cornflowerblue'>（4）无虚函数。</font></p>
<p>​		<font color='cornflowerblue'>（5）类中不能有使用{}和=直接初始化的非静态数据成员（从c++14开始就支持了</font></p>
<h5 id="2-非聚合体">2、非聚合体</h5>
<p>对于聚合类型的类可以直接使用列表初始化进行对象的初始化，如果不满足聚合条件还想使用列表初始化其实也是可以的，<font color='red'>需要在类的内部自定义一个构造函数, 在构造函数中使用初始化列表对类成员变量进行初始化:</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

struct T1
{
    int x;
    double y;
    // 在构造函数中使用初始化列表初始化类成员
    T1(int a, double b, int c) : x(a), y(b), z(c){}
    virtual void print()
    {
        cout &lt;&lt; &quot;x: &quot; &lt;&lt; x &lt;&lt; &quot;, y: &quot; &lt;&lt; y &lt;&lt; &quot;, z: &quot; &lt;&lt; z &lt;&lt; endl;
    }
private:
    int z;
};

int main(void)
{
    T1 t{ 520, 13.14, 1314 };	// ok, 基于构造函数使用初始化列表初始化类成员
    t.print();
    return 0;
}
</code></pre>
<p>另外，需要额外注意的是<font color='red'>聚合类型的定义并非递归的&lt;，也就是说<font color='red'>当一个类的非静态成员是非聚合类型时，这个类也可能是聚合类型，比如下面的这个例子</font>：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

struct T1
{
    int x;
    double y;
private:
    int z;
};

struct T2
{
    T1 t1;
    long x1;
    double y1;
};

int main(void)
{
    T2 t2{ {}, 520, 13.14 };
    return 0;
}
</code></pre>
<p>可以看到，T1并非一个聚合类型，因为它有一个Private的非静态成员。但是尽管T2有一个非聚合类型的非静态成员t1，T2依然是一个聚合类型，可以直接使用列表初始化的方式进行初始化。</p>
<p>最后强调一下t2对象的初始化过程，对于非聚合类型的成员t1做初始化的时候，可以直接写一对空的大括号{}，这相当于调用是T1的无参构造函数。</p>
<p><font color='red'>对于一个聚合类型，使用列表初始化相当于对其中的每个元素分别赋值，而对于非聚合类型，则需要先自定义一个合适的构造函数，此时使用列表初始化将会调用它对应的构造函数。</font></p>
<h4 id="3-sstdinitializer_list模板类的使用">3、sstd::initializer_list模板类的使用</h4>
<p>在C++的STL容器中，可以进行任意长度的数据的初始化，使用初始化列表也只能进行固定参数的初始化，如果想要做到和STL一样有任意长度初始化的能力，可以使用<font color='red'>std::initializer_list</font>这个轻量级的类模板来实现。</p>
<p>先来介绍一下这个类模板的一些特点：</p>
<ul>
<li>它是一个轻量级的容器类型，内部定义了迭代器iterator等容器必须的概念，遍历时得到的迭代器是只读的。</li>
<li>对于std::initializer_list<T>而言，它可以接收任意长度的初始化列表，但是要求元素<font color='red'>必须是同种类型T</font></li>
<li>在std::initializer_list内部有三个成员接口：<font color='red'>size(), begin(), end()。</font></li>
<li>std::initializer_list对象<font color='red'>只能被整体初始化或者赋值</font>。</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;vector&gt;
using namespace std;
//构造函数
class Person
{
public:
	Person(initializer_list&lt;string&gt;ls)
	{
		auto it = ls.begin();
		for (; it != ls.end(); it++)
		{
			cout &lt;&lt; *it &lt;&lt; endl;
			m_name.push_back(*it);
		}
	}
private:
	vector&lt;string&gt;m_name;
};
//普通函数
void func(initializer_list&lt;int&gt;ls)
{
	auto it = ls.begin();
	for (; it != ls.end(); ++it)
	{
		cout &lt;&lt; *it &lt;&lt;&quot; &quot;;
	}
	cout &lt;&lt; endl;
}
int main()
{
	func({ 1,2,3,4,5,6,7 });
	Person p1({ &quot;a&quot;,&quot;b&quot;,&quot;c&quot; });
	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11新特性（三）]]></title>
        <id>https://tangyin1.github.io/post/c11-xin-te-xing-san/</id>
        <link href="https://tangyin1.github.io/post/c11-xin-te-xing-san/">
        </link>
        <updated>2023-11-21T09:20:53.000Z</updated>
        <summary type="html"><![CDATA[<p>文章内容来自https://subingwen.cn/cplusplus/的整理，感谢丙哥</p>
]]></summary>
        <content type="html"><![CDATA[<p>文章内容来自https://subingwen.cn/cplusplus/的整理，感谢丙哥</p>
<!-- more -->
<h3 id="1for循环新特性">1for循环新特性</h3>
<p>C++98/03中普通的for循环，语法格式：</p>
<pre><code class="language-cpp">for(表达式 1; 表达式 2; 表达式 3)
{
    // 循环体
}
</code></pre>
<p>C++11基于范围的for循环，语法格式：</p>
<pre><code class="language-cpp">for (declaration : expression)
{
    // 循环体
}
</code></pre>
<p>在上面的语法格式中declaration表示遍历声明，在遍历过程中，当前被遍历到的元素会被存储到声明的变量中。expression是要遍历的对象，它可以是<font color='red'>表达式、容器、数组、初始化列表等。</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
int main(void)
{
    vector&lt;int&gt; t{ 1,2,3,4,5,6 };
    cout &lt;&lt; &quot;遍历修改之前的容器: &quot;;
    for (auto &amp;value : t)
    {
        cout &lt;&lt; value++ &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl &lt;&lt; &quot;遍历修改之后的容器: &quot;;
    for (auto &amp;value : t)
    {
        cout &lt;&lt; value &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<p><strong>auto &amp;value : t</strong></p>
<p>由于直接不采用引用的方式是使用拷贝的方法来输出，这种拷贝的不仅影响内存还影响速度，采用引用的方式会解决了资源占用，还能进行对其数值进行修改</p>
<h3 id="2基于范围的for循环需要注意的3个细节">2基于范围的for循环需要注意的3个细节</h3>
<h4 id="21-关系型容器">2.1 关系型容器</h4>
<p>使用基于范围的for循环有一些需要注意的细节，先来看一下对关系型容器map的遍历：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;map&gt;
using namespace std;

int main(void)
{
    map&lt;int, string&gt; m{
        {1, &quot;lucy&quot;},{2, &quot;lily&quot;},{3, &quot;tom&quot;}
    };

    // 基于范围的for循环方式
    for (auto&amp; it : m)
    {
        cout &lt;&lt; &quot;id: &quot; &lt;&lt; it.first &lt;&lt; &quot;, name: &quot; &lt;&lt; it.second &lt;&lt; endl;
    }
    
    // 普通的for循环方式
    for (auto it = m.begin(); it != m.end(); ++it)
    {
        cout &lt;&lt; &quot;id: &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;, name: &quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
    }
    
    return 0;

}
</code></pre>
<p>在上面的例子中使用两种方式对map进行了遍历，通过对比有两点需要注意的事项：</p>
<p>使用普通的for循环方式（基于迭代器）遍历关联性容器，<font color='red'> auto自动推导出的是一个迭代器类型</font>，需要使用迭代器的方式取出元素中的键值对（<font color='red'>和指针的操作方法相同</font>）：</p>
<ul>
<li>it-&gt;first</li>
<li>it-&gt;second</li>
</ul>
<p>使用基于范围的for循环遍历关联性容器，<font color='red'>auto自动推导出的类型是容器中的value_type</font>，相当于一个对组（std::pair）对象，提取键值对的方式如下：</p>
<ul>
<li>it.first<br>
it.second</li>
</ul>
<h4 id="22元素只读">2.2元素只读</h4>
<p><font color='red'>对应set容器来说，内部元素都是只读的，这是由容器的特性决定的，因此在for循环中auto&amp;会被视为const auto &amp; 。</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;set&gt;
using namespace std;

int main(void)
{
    set&lt;int&gt; st{ 1,2,3,4,5,6 };
    for (auto &amp;item : st) 
    {
        cout &lt;&lt; item++ &lt;&lt; endl;		// error, 不能给常量赋值
    }
    return 0;
}
</code></pre>
<h4 id="23访问次数">2.3访问次数</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;
vector&lt;int&gt; v{ 1,2,3,4,5,6 };
vector&lt;int&gt;&amp; getRange()
{
    cout &lt;&lt; &quot;get vector range...&quot; &lt;&lt; endl;
    return v;
}
int main(void)
{
    for (auto val : getRange())
    {
        cout &lt;&lt; val &lt;&lt; &quot; &quot;;
    }
    cout &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>输出的结果如下：<br>
<code>get vector range...</code><br>
<code>1 2 3 4 5 6</code></p>
<p><font color='red'>对应基于范围的for循环来说，冒号后边的表达式只会被执行一次。在得到遍历对象之后会先确定好迭代的范围，基于这个范围直接进行遍历。如果是普通的for循环，在每次迭代的时候都需要判断是否已经到了结束边界。</font></p>
<h3 id="3-nullptr">3 nullptr</h3>
<p>在C++程序开发中，为了提高程序的健壮性，一般会在定义指针的同时完成初始化操作，或者在指针的指向尚未明确的情况下，都会给指针初始化为NULL，避免产生野指针（没有明确指向的指针，操作也这种指针极可能导致程序发生异常）。C++98/03 标准中，将一个指针初始化为空指针的方式有 2 种：</p>
<pre><code class="language-cpp">char *ptr = 0;
char *ptr = NULL;
</code></pre>
<p>C++ 中将 NULL 定义为字面常量 0，并不能保证在所有场景下都能很好的工作，比如，函数重载时，NULL 和 0 无法区分</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;

void func(char *p)
{
    cout &lt;&lt; &quot;void func(char *p)&quot; &lt;&lt; endl;
}

void func(int p)
{
    cout &lt;&lt; &quot;void func(int p)&quot; &lt;&lt; endl;
}

int main()
{
    func(nullptr);
    func(250);
    return 0;
}
</code></pre>
<p><font color='red'>nullptr 无法隐式转换为整形，但是可以隐式匹配指针类型</font>。在 C++11 标准下，相比 NULL 和 0，使用 nullptr 初始化空指针可以令我们编写的程序更加健壮。</p>
<p><font color='red'>总的来说在支持c++11的编译器之中，建议使用nullptr来代替NULL 和0，来避免报错。</font></p>
<h3 id="4-lambda表达式">4、lambda表达式</h3>
<h4 id="1-基本用法">1、基本用法</h4>
<p>lambda表达式的语法形式简单归纳如下：</p>
<pre><code class="language-cpp">[capture](params) opt -&gt; ret {body;};
</code></pre>
<p>其中<font color='red'>capture</font>是捕获列表，<font color='red'>params</font>是参数列表，<font color='red'>opt</font>是函数选项，<font color='red'>ret</font>是返回值类型，<font color='red'>body</font>是函数体。</p>
<ol>
<li>捕获列表[]: 捕获一定范围内的变量</li>
<li>参数列表(): 和普通函数的参数列表一样，如果没有参数参数列表可以省略不写。</li>
</ol>
<pre><code class="language-cpp">auto f = [](){return 1;}	// 没有参数, 参数列表为空
auto f = []{return 1;}		// 没有参数, 参数列表省略不写
</code></pre>
<p>​	3.opt 选项， <font color='red'>不需要可以省略</font></p>
<ul>
<li>​	mutable: 可以修改按值传递进来的拷贝（注意是能修改拷贝，而不是值本身）</li>
<li>​	exception: 指定函数抛出的异常，如抛出整数类型的异常，可以使用throw();</li>
</ul>
<p>​	4.返回值类型：在C++11中，lambda表达式的返回值是通过返回值后置语法来定义的。</p>
<p>​	5.函数体：函数的实现，这部分不能省略，但函数体可以为空。</p>
<h4 id="2捕获列表">2.捕获列表</h4>
<p>lambda表达式的捕获列表可以捕获一定范围内的变量，具体使用方式如下：</p>
<ul>
<li>[] - 不捕捉任何变量</li>
<li>[&amp;] - 捕获外部作用域中所有变量, 并作为引用在函数体内使用 (按引用捕获)</li>
<li>[=] - 捕获外部作用域中所有变量, 并作为副本在函数体内使用 (按值捕获)</li>
<li>拷贝的副本在匿名函数体内部是只读的</li>
<li>[=, &amp;foo] - 按值捕获外部作用域中所有变量, 并按照引用捕获外部变量 foo</li>
<li>[bar] - 按值捕获 bar 变量, 同时不捕获其他变量</li>
<li>[&amp;bar] - 按引用捕获 bar 变量, 同时不捕获其他变量</li>
<li>[this] - 捕获当前类中的this指针</li>
</ul>
<p>​		让lambda表达式拥有和当前类成员函数同样的访问权限<br>
​		如果已经使用了 &amp; 或者 =, 默认添加此选项</p>
<pre><code class="language-cpp">//lambda表达式
#include &lt;iostream&gt;
using namespace std;
void func(int x, int y)
{
	int a = 1;
	int b = 2;
	[=,&amp;x]() mutable//除了x为引用的方式被取值，其他的元素都是以拷贝的方式取值
	{
		int c = a;
		b++;//使用mutable可以使得拷贝进来的元素可以进行修改
		cout &lt;&lt; b &lt;&lt; endl;
	}();//要调用这个函数需要在{}后面接上(),如果{}前面的小括号有参数，{}后面的也要有相应类型的参数
	cout &lt;&lt; b &lt;&lt; endl;
	[=](int z)mutable
	{
		int d = a;
		a++;
		cout &lt;&lt; &quot;d= &quot; &lt;&lt; d&lt;&lt;endl;
	}(1);
}
int main()
{
	func(1, 2);
	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
<h4 id="3-返回值">3、返回值</h4>
<p>很多时候，lambda表达式的返回值是非常明显的，因此在C++11中允许省略lambda表达式的返回值。</p>
<pre><code class="language-cpp">// 完整的lambda表达式定义
auto f = [](int a) -&gt; int
{
    return a+10;  
};

// 忽略返回值的lambda表达式定义
auto f = [](int a)
{
    return a+10;  
};
</code></pre>
<p>一般情况下，不指定lambda表达式的返回值，编译器会根据return语句自动推导返回值的类型，但需要注意的是labmda表达式<font color='red'>不能通过</font><font color='red'>列表初始化自动推导出返回值类型</font>。</p>
<pre><code class="language-cpp">/ ok，可以自动推导出返回值类型
auto f = [](int i)
{
    return i;
}

// error，不能推导出返回值类型
auto f1 = []()
{
    return {1, 2};	// 基于列表初始化推导返回值，错误
}
</code></pre>
<h4 id="4-函数本质">4、函数本质</h4>
<p>使用lambda表达式捕获列表捕获外部变量，如果希望去修改按值捕获的外部变量，那么应该如何处理呢？这就需要使用mutable选项，<font color='red'>被mutable修改是lambda表达式就算没有参数也要写明参数列表，并且可以去掉按值捕获的外部变量的只读（const）属性。</font></p>
<pre><code class="language-cpp">int a = 0;
auto f1 = [=] {return a++; };              // error, 按值捕获外部变量, a是只读的
auto f2 = [=]()mutable {return a++; };     // ok
</code></pre>
<p>最后再剖析一下为什么通过值拷贝的方式捕获的外部变量是只读的:</p>
<ol>
<li>lambda表达式的类型在C++11中会被看做是一个带operator()的类，即仿函数。</li>
<li>按照C++标准，lambda表达式的operator()默认是const的，一个const成员函数是无法修改成员变量值的。</li>
</ol>
<p>​	<font color='red'>mutable选项的作用就在于取消operator()的const属性。</font></p>
<p>因为lambda表达式在C++中会被看做是一个仿函数，因此可以使用<font color='red'>std::function和std::bind来存储和操作lambda表达式</font>：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;functional&gt;
using namespace std;

int main(void)
{
    // 包装可调用函数
    std::function&lt;int(int)&gt; f1 = [](int a) {return a; };
    // 绑定可调用函数
    std::function&lt;int(int)&gt; f2 = bind([](int a) {return a; }, placeholders::_1);

    // 函数调用
    cout &lt;&lt; f1(100) &lt;&lt; endl;
    cout &lt;&lt; f2(200) &lt;&lt; endl;
    return 0;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11新特性2（自动类型推导）]]></title>
        <id>https://tangyin1.github.io/post/c11-xin-te-xing-2zi-dong-lei-xing-tui-dao/</id>
        <link href="https://tangyin1.github.io/post/c11-xin-te-xing-2zi-dong-lei-xing-tui-dao/">
        </link>
        <updated>2023-11-21T01:59:28.000Z</updated>
        <summary type="html"><![CDATA[<p>C++11新特性2（自动类型推导） auto、decltype、返回值类型后置</p>
]]></summary>
        <content type="html"><![CDATA[<p>C++11新特性2（自动类型推导） auto、decltype、返回值类型后置</p>
<!-- more -->
<h3 id="1使用auto进行类型自动推导">1使用auto进行类型自动推导</h3>
<h4 id="auto">auto</h4>
<p>C++11中auto并不代表一种实际的数据类型，只是一个类型声明的 “占位符”，auto并不是万能的在任意场景下都能够推导出变量的实际类型，使用auto声明的变量必须要进行初始化，以让编译器推导出它的实际类型，在编译时将auto占位符替换为真正的类型。使用语法如下：</p>
<pre><code class="language-cpp">auto 变量名 = 变量值;
</code></pre>
<pre><code class="language-cpp">auto x = 3.14;      // x 是浮点型 double
auto y = 520;       // y 是整形 int
auto z = 'a';       // z 是字符型 char
auto nb;            // error，变量必须要初始化
auto double nbl;    // 语法错误, 不能修改数据类型
</code></pre>
<ul>
<li>当变量<font color='red'>不是</font>指针或者引用类型时，推导的结果中<font color='red'>不会保留</font>const、volatile关键字</li>
<li>当变量<font color='red'>是指针或者引用</font>类型时，推导的结果中<font color='red'>会保留</font>const、volatile关键字</li>
</ul>
<p>（1） “编译器一般不为const变量分配内存，而是将它保存在符号表中，这使得它成为一个编译期间的值，没有了存储与读内存的操作。”</p>
<p>（2） volatile的作用是“告诉编译器，i是随时可能发生变化的，每次使用它的时候必须从内存中取出i的值”。</p>
<p>— —《c语言深度解剖》</p>
<h5 id="1-const-volatile含义">1、 const, volatile含义</h5>
<p>（1）const含义是“请做为常量使用”，而并非“放心吧，那肯定是个常量”。 （2）volatile的含义是“请不要做自以为是的优化，这个值可能变掉的”，而并非“你可以修改这个值”。</p>
<h5 id="2-const-volatile的作用以及起作用的阶段">2、const, volatile的作用以及起作用的阶段</h5>
<p>（1）const只在编译期有用，在运行期无用</p>
<p>const在编译期保证在C的“源代码”里面，没有对其修饰的变量进行修改的地方（如有则报错，编译不通过），而运行期该变量的值是否被改变则不受const的限制。</p>
<p>（2） volatile在编译期和运行期都有用</p>
<p>在编译期告诉编译器：请不要做自以为是的优化，这个变量的值可能会变掉；</p>
<p>在运行期：每次用到该变量的值，都从内存中取该变量的值。</p>
<pre><code class="language-cpp">int temp = 110;
auto *a = &amp;temp;	
auto b = &amp;temp;		
auto &amp;c = temp;		
auto d = temp;		
</code></pre>
<ul>
<li>变量a的数据类型为 int*，因此auto关键字被推导为 int类型</li>
<li>变量b的数据类型为 int*，因此auto关键字被推导为 int*类型</li>
<li>变量c的数据类型为 int&amp;，因此auto关键字被推导为 int类型</li>
<li>变量d的数据类型为 int，因此auto关键字被推导为 int类型</li>
</ul>
<h4 id="auto的限制">auto的限制</h4>
<p>1不能作为函数参数使用。因为只有在函数调用的时候才会给函数参数传递实参，auto要求必须要给修饰的变量赋值，因此二者矛盾。</p>
<pre><code class="language-cpp">int func(auto a, auto b)	// error
{	
    cout &lt;&lt; &quot;a: &quot; &lt;&lt; a &lt;&lt;&quot;, b: &quot; &lt;&lt; b &lt;&lt; endl;
}
</code></pre>
<p>2不能用于类的非静态成员变量的初始化</p>
<pre><code class="language-cpp">class Test
{
    auto v1 = 0;                    // error
    static auto v2 = 0;             // error,类的静态非常量成员不允许在类内部直接初始化
    static const auto v3 = 10;      // ok
}
</code></pre>
<p>3不能使用auto关键字定义数组</p>
<pre><code class="language-cpp">int func()
{
    int array[] = {1,2,3,4,5};  // 定义数组
    auto t1 = array;            // ok, t1被推导为 int* 类型
    auto t2[] = array;          // error, auto无法定义数组
    auto t3[] = {1,2,3,4,5};;   // error, auto无法定义数组
}
</code></pre>
<p>4无法使用auto推导出模板参数</p>
<pre><code class="language-cpp">template &lt;typename T&gt;
struct Test{}

int func()
{
    Test&lt;double&gt; t;
    Test&lt;auto&gt; t1 = t;           // error, 无法推导出模板类型
    return 0;
}
</code></pre>
<h4 id="auto的应用">auto的应用</h4>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;string&gt;
#include&lt;map&gt;
using namespace std;
//用于泛型编程
class T1 {
public:
	static int get()
	{
		return 10;
	}
};
class T2 {
public:
	static string get()
	{
		return &quot;hello world!&quot;;
	}
};
template &lt;class A&gt;
void func()
{
	auto val = A::get();
	cout &lt;&lt; val &lt;&lt; endl;
}
//用于STL的容器遍历
void test()
{
	map&lt;int, string&gt;mp;
	mp.insert(make_pair(1, &quot;ace&quot;));
	mp.insert(make_pair(2, &quot;katun&quot;));
	mp.insert(make_pair(3, &quot;luky&quot;));
	//map&lt;int, string&gt;::iterator it = mp.begin();//迭代器
	auto it = mp.begin();
	for (; it != mp.end(); it++)
	{
		cout &lt;&lt; &quot;key:&quot; &lt;&lt; it-&gt;first &lt;&lt; &quot;,value:&quot; &lt;&lt; it-&gt;second &lt;&lt; endl;
	}
}
int main()
{
	func&lt;T1&gt;();
	func&lt;T2&gt;();
	test();
	system(&quot;pause&quot;);
	return 0;
}
</code></pre>
<h3 id="2decltype">2decltype</h3>
<p>decltype 是“declare type”的缩写，意思是“声明类型”。某些情况下，不需要或者不能定义变量，但是希望得到某种类型,使用decltype</p>
<pre><code class="language-cpp">decltype (表达式)
</code></pre>
<pre><code class="language-cpp">int a = 10;
decltype(a) b = 99;                 // b -&gt; int
decltype(a+3.14) c = 52.13;         // c -&gt; double
decltype(a+b*c) d = 520.1314;       // d -&gt; double
</code></pre>
<h4 id="推导规则">推导规则</h4>
<p><font color='red'>1表达式为普通变量或者普通表达式或者类表达式，在这种情况下，使用decltype推导出的类型和表达式的类型是一致的。</font></p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include &lt;string&gt;
using namespace std;

class Test
{
public:
    string text;
    static const int value = 110;
};

int main()
{
    int x = 99;
    const int &amp;y = x;
    decltype(x) a = x;
    decltype(y) b = x;
    decltype(Test::value) c = 0;// c是const int类型

    Test t;
    decltype(t.text) d = &quot;hello, world&quot;;
    
    return 0;

}
</code></pre>
<p><font color='red'>2表达式是函数调用，使用decltype推导出的类型和函数返回值一致</font></p>
<pre><code class="language-cpp">class Test{...};
//函数声明
int func_int();                 // 返回值为 int
int&amp; func_int_r();              // 返回值为 int&amp;
int&amp;&amp; func_int_rr();            // 返回值为 int&amp;&amp;

const int func_cint();          // 返回值为 const int
const int&amp; func_cint_r();       // 返回值为 const int&amp;
const int&amp;&amp; func_cint_rr();     // 返回值为 const int&amp;&amp;

const Test func_ctest();        // 返回值为 const Test

//decltype类型推导
int n = 100;
decltype(func_int()) a = 0;		
decltype(func_int_r()) b = n;	
decltype(func_int_rr()) c = 0;	
decltype(func_cint())  d = 0;	
decltype(func_cint_r())  e = n;	
decltype(func_cint_rr()) f = 0;	
decltype(func_ctest()) g = Test();	
</code></pre>
<p>函数 func_cint() 返回的是一个纯右值（在表达式执行结束后不再存在的数据，也就是临时性的数据），对于纯右值而言，只有类类型可以携带const、volatile限定符，除此之外需要忽略掉这两个限定符，因此推导出的变量d的类型为 int 而不是 const int。</p>
<p><font color='red'>3表达式是一个左值(可以取地址的变量)，或者被括号( )包围，使用 decltype推导出的是表达式类型的引用（如果有const、volatile限定符不能忽略）。</font></p>
<pre><code class="language-cpp">class Test{...};
//函数声明
int func_int();                 // 返回值为 int
int&amp; func_int_r();              // 返回值为 int&amp;
int&amp;&amp; func_int_rr();            // 返回值为 int&amp;&amp;

const int func_cint();          // 返回值为 const int
const int&amp; func_cint_r();       // 返回值为 const int&amp;
const int&amp;&amp; func_cint_rr();     // 返回值为 const int&amp;&amp;

const Test func_ctest();        // 返回值为 const Test

//decltype类型推导
int n = 100;
decltype(func_int()) a = 0;		
decltype(func_int_r()) b = n;	
decltype(func_int_rr()) c = 0;	
decltype(func_cint())  d = 0;	
decltype(func_cint_r())  e = n;	
decltype(func_cint_rr()) f = 0;	
decltype(func_ctest()) g = Test(
</code></pre>
<p>);</p>
<ul>
<li>obj.num 为类的成员访问表达式，符合场景1，因此 a 的类型为int</li>
<li>obj.num 带有括号，符合场景3，因此b 的类型为 const int&amp;。</li>
<li>n+m 得到一个右值，符合场景1，因此c的类型为 int</li>
<li>n=n+m 得到一个左值 n，符合场景3，因此d的类型为 int&amp;</li>
</ul>
<h4 id="decltype的应用">decltype的应用</h4>
<pre><code class="language-cpp">//decltype的应用
#include &lt;iostream&gt;
#include&lt;list&gt;
using namespace std;
template &lt;typename T&gt;
class A
{
public:
	void print(T &amp;t)
	{
		for (m_it = t.begin(); m_it !=t.end(); m_it++)
		{
			cout &lt;&lt; &quot;value:&quot; &lt;&lt; *m_it &lt;&lt; endl;
		}
	}
private:
	decltype(T().begin()) m_it;
};
int main()
{
	list&lt;int&gt; lst{ 1,2,3,4,5 };
	const list&lt;int&gt; lst1{ 1,2,3,4,5,6,7 };
	list&lt;int&gt;::iterator it = lst.begin();
	A&lt;list&lt;int&gt;&gt; b;
	A&lt;const list&lt;int&gt;&gt; b1;
	b.print(lst);
	cout &lt;&lt; endl;
	b1.print(lst1);
	system(&quot;pause&quot;);
	return 0;	
}

### 3
</code></pre>
<h3 id="3-左值和右值的概念">3、左值和右值的概念</h3>
<p>C++中左值（lvalue）和右值（rvalue）是比较基础的概念，虽然平常几乎用不到，但C++11之后变得十分重要，它是理解 move/forward 等新语义的基础。</p>
<p>左值与右值这两个概念是从 C 中传承而来的，左值指既能够出现在等号左边，也能出现在等号右边的变量；右值则是只能出现在等号右边的变量。</p>
<pre><code class="language-cpp">int a; // a 为左值
a = 3; // 3 为右值
</code></pre>
<ul>
<li>左值是可寻址的变量，有持久性；</li>
<li>右值<font color='red'>一般是不可寻址的常量</font>，或在表达式求值过程中创建的无名临时对象，短暂性的。</li>
</ul>
<p><font color='cornflowerblue'>左值和右值主要的区别之一是左值可以被修改，而右值不能。</font></p>
<h3 id="4-左值引用和右值引用">4、左值引用和右值引用</h3>
<ul>
<li>左值引用：引用一个对象；</li>
<li>右值引用：就是必须绑定到右值的引用，C++11中右值引用可以实现“移动语义”，通过 &amp;&amp; 获得右值引用。</li>
</ul>
<pre><code class="language-cpp">int x = 6; // x是左值，6是右值
int &amp;y = x; // 左值引用，y引用x

int &amp;z1 = x * 6; // 错误，x*6是一个右值
const int &amp;z2 =  x * 6; // 正确，可以将一个const引用绑定到一个右值

int &amp;&amp;z3 = x * 6; // 正确，右值引用
int &amp;&amp;z4 = x; // 错误，x是一个左值
</code></pre>
<p>右值引用和相关的移动语义是C++11标准中引入的最强大的特性之一，通过std::move()可以避免无谓的复制，提高程序性能。</p>
<h3 id="5-返回值类型后置-追踪返回类型">5、 返回值类型后置 (追踪返回类型)</h3>
<p>在泛型编程中，可能需要通过参数的运算来得到返回值的类型，比如下面这个场景：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
// R-&gt;返回值类型, T-&gt;参数1类型, U-&gt;参数2类型
template &lt;typename R, typename T, typename U&gt;
R add(T t, U u)
{
    return t + u;
}
int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = add&lt;decltype(x + y), int, double&gt;(x, y);
    auto z = add&lt;decltype(x + y)&gt;(x, y);	// 简化之后的写法
    cout &lt;&lt; &quot;z: &quot; &lt;&lt; z &lt;&lt; endl;
    return 0;
}
</code></pre>
<p>关于返回值，从上面的代码可以推断出和表达式 t+u的结果类型是一样的，因此可以通过通过decltype进行推导，关于模板函数的参数t和u可以通过实参自动推导出来，因此在程序中就也可以不写。虽然通过上述方式问题被解决了，<font color='red'>但是解决方案有点过于理想化</font>，因为对于调用者来说，<font color='red'>是不知道函数内部执行了什么样的处理动作的。</font></p>
<pre><code class="language-cpp">// 返回类型后置语法
auto 函数(T t, U u) -&gt; decltype(合适的表达式) 
</code></pre>
<p>上面代码使用返回类型后置优化之后</p>
<pre><code class="language-cpp">// 返回值类型后置 (追踪返回类型)
#include &lt;iostream&gt;
using namespace std;
// R-&gt;返回值类型, T-&gt;参数1类型, U-&gt;参数2类型

//R add(T t, U u)
//{
//    return t + u;
//}
template &lt;typename T, typename U&gt;
auto add(T t, U u)-&gt;decltype(t + u)
{
    return t+u;
}
int main()
{
    int x = 520;
    double y = 13.14;
    // auto z = add&lt;decltype(x + y), int, double&gt;(x, y);
    //auto z = add&lt;decltype(x + y)&gt;(x, y);	// 简化之后的写法
    auto ret = add(x, y);
    cout &lt;&lt; &quot;ret: &quot; &lt;&lt; ret &lt;&lt; endl;
    return 0;
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[C++11新特性（1）]]></title>
        <id>https://tangyin1.github.io/post/c11-xin-te-xing-1/</id>
        <link href="https://tangyin1.github.io/post/c11-xin-te-xing-1/">
        </link>
        <updated>2023-11-20T05:52:29.000Z</updated>
        <summary type="html"><![CDATA[<p>C++11的一些常用新特性，本节包含<br>
字符串原始字面量<br>
long long<br>
类成员的快速初始化</p>
<p>苏丙榅老师的博客https://subingwen.cn/</p>
]]></summary>
        <content type="html"><![CDATA[<p>C++11的一些常用新特性，本节包含<br>
字符串原始字面量<br>
long long<br>
类成员的快速初始化</p>
<p>苏丙榅老师的博客https://subingwen.cn/</p>
<!-- more -->
<h3 id="1字符串原始字面量">1字符串原始字面量</h3>
<p>在C++11中添加了定义原始字符串的字面量，定义方式为：<font color='red'>R “xxx(原始字符串)xxx”</font>其中（）两边的字符串可以省略。原始字面量R可以直接表示字符串的实际含义，而不需要额外对字符串做转义或连接等操作。</p>
<p>在R “xxx(raw string)xxx” 中，原始字符串必须用括号（）括起来，括号的前后可以加其他字符串，所加的字符串会被忽略，<font color='red'>并且加的字符串必须在括号两边同时出现</font>。</p>
<p><code>string str2 = R&quot;luffy(D:\hello\world\test.text)luffy&quot;;</code>-----------正确</p>
<p><code>string str3 = R&quot;luffy(D:\hello\world\test.text)robin&quot;;</code>	----------<font color='cornflowerblue'>错误（原因在字符串两边的字符串不一样）</font></p>
<p>运行结果：</p>
<p><code>D:\hello\world\test.text</code></p>
<h3 id="2long-long-整型">2long long 整型</h3>
<p>C++11 标准要求 long long 整型可以在不同平台上有不同的长度，但至少有64位。long long 整型有两种∶</p>
<p>long long - 对应类型的数值可以使用 LL (大写) 或者 ll (小写) 后缀</p>
<p><code>long long num1 = 123456789LL;</code><br>
<code>long long num2 = 123456789ll;</code></p>
<p><font color='red'>在通常情况下我们使用LL</font>，因为ll容易与数字1混淆</p>
<p>同其他的整型一样，要了解平台上 long long大小的方法就是查看<climits>（或&lt;limits. h&gt; ）中的宏与long long整 型相关的一共有3个：</p>
<ul>
<li>LLONG_MIN - 最小的long long值（负数）</li>
<li>LLONG_MAX - 最大的long long 值（正数包括0）</li>
<li>ULLONG MAX - 最大的 unsigned long long 值LLONG_MIN+LLONG_MAX的数）</li>
</ul>
<p><strong>在C++11中一共只定义了以下5种标准的有符号整型</strong>：</p>
<ul>
<li>signed char</li>
<li>short int</li>
<li>int</li>
<li>long int</li>
<li>long long int</li>
</ul>
<p>关于整形提升的隐式转换遵循如下原则:</p>
<ul>
<li>长度越大的整型等级越高，比如 long long int 的等级会高于int。</li>
<li>长度相同的情况下，标准整型的等级高于扩展类型，比如 long long int 和 int64 如果 都是64 位长度，则long long int类型的等级更高。</li>
<li>相同大小的有符号类型和无符号类型的等级相同，long long int 和unsigned longlong  int的等级就相同。</li>
<li><font color='red'>转换过程中，低等级整型需要转换为高等级整型，有符号的需要转换为无符号整形。</font></li>
</ul>
<h3 id="3类成员的快速初始化">3类成员的快速初始化</h3>
<p>//类成员的快速初始化</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
using namespace std;
struct Base
{
    Base() : a(250) {}
    Base(int num) : a(num) {}

int a;
int b = 1;
static int c;//直接在类中声明会报错 类的静态成员，必须在类的外部进行初始化
static const double d;//类的静态常量成员，但不是整形或者枚举，无法通过编译
static const char* const e ;//类的静态常量成员，但不是整形或者枚举，无法通过编译
const static int f = 0;

};
//可以在类外声明
int::Base::c = 1;
const double::Base::d = 3.14;
const char* const e = &quot;i am luffy&quot;;
int main()
{
	system(&quot;pause&quot;);
	return 0;

}
</code></pre>
<h3 id="c11-标准两种类成员初始化方法">C++11 标准两种类成员初始化方法</h3>
<h4 id="21-初始化类的非静态成员">2.1 初始化类的非静态成员</h4>
<p>进行类成员变量初始化的时候，C++11标准对于C++98做了补充，允许在定义类的时候在类内部直接对非静态成员变量进行初始化，在初始化的时候可以<font color='red'>使用等号 = 也可以使用花括号 {}</font> 。</p>
<pre><code class="language-cpp">class Test
{
private:
    int a = 9;
    int b = {5};
    int c{12};
    double array[4] = { 3.14, 3.15, 3.16, 3.17};
    double array1[4] { 3.14, 3.15, 3.16, 3.17 };
    string s1(&quot;hello&quot;);     // error
    string s2{ &quot;hello, world&quot; };
};
</code></pre>
<p><font color='cornflowerblue'>可以看到如果使用花括号 {}的方式对类的非静态成员进行初始化，等号是可以省略不写的</font>。</p>
<p>第9行：错误，不能使用小括号() 初始化对象，应该使用花括号{}</p>
<h4 id="22-类内部赋值和初始化列表">2.2 类内部赋值和初始化列表</h4>
<p>在C++11之前对于非静态的类成员变量我们除了在构造函数内部进行赋值，也可以在类的初始化列表中进行初始化（这种方式比在构造函数内部赋值效率高）</p>
<pre><code class="language-cpp">class Init
{
public:
    Init(int x, int y, int z) :a(x), b(y), c(z) {}

int a = 1;
int b = 2;
int c = 3;

};

int main()
{
    Init tmp(10, 20, 30);
    cout &lt;&lt; &quot;a: &quot; &lt;&lt; tmp.a &lt;&lt; &quot;, b: &quot; &lt;&lt; tmp.b &lt;&lt; &quot;, c: &quot; &lt;&lt; tmp.c &lt;&lt; endl;
    return 0;
}
</code></pre>
<ul>
<li>第4行：使用初始化列表对类的非静态成员进行初始化</li>
<li>第6、7、8行：在类内部对非静态成员变量就地初始化（C++11新特性）</li>
</ul>
<p>执行程序，输出的结果如下：<br>
<code>a: 10, b: 20, c: 30</code></p>
<p><font color='red'>通过初始化列表指定的值会覆盖就地初始化时指定的值</font></p>
<h3 id="4final和override">4.final和override</h3>
<h4 id="final">final</h4>
<p>C++中增加了<font color='red'>final关键字来限制某个类不能被继承，或者某个虚函数不能被重写</font>，和Java的final关键字的功能是类似的。如果使用final修饰函数，只能修饰虚函数，并且要把final关键字<font color='red'>放到类或者函数的后面</font></p>
<p>如果使用final修饰函数，只能修饰虚函数，这样就能<font color='red'>阻止子类重写父类的这个函数了</font>：</p>
<pre><code class="language-cpp">class Base
{
public:
    virtual void test()
    {
        cout &lt;&lt; &quot;Base class...&quot;;
    }
};

class Child : public Base
{
public:
    void test() final
    {
        cout &lt;&lt; &quot;Child class...&quot;;
    }
};

class GrandChild : public Child
{
public:
    // 语法错误, 不允许重写
    void test()
    {
        cout &lt;&lt; &quot;GrandChild class...&quot;;
    }
};
</code></pre>
<p>但注意的是，在父类的虚函数以后不允许加上final</p>
<h4 id="override重写">override(重写)</h4>
<p>override关键字确保在派生类中声明的重写函数与基类的虚函数有相同的签名，同时也明确表明将会重写基类的虚函数，这样就可以保证重写的虚函数的正确性，也提高了代码的可读性，和final一样这个关键字要写到方法的后面。</p>
<pre><code class="language-cpp">class Base
{
public:
    virtual void test()
    {
        cout &lt;&lt; &quot;Base class...&quot;;
    }
};

class Child : public Base
{
public:
    void test() override
    {
        cout &lt;&lt; &quot;Child class...&quot;;
    }
};

class GrandChild : public Child
{
public:
    void test() override
    {
        cout &lt;&lt; &quot;Child class...&quot;;
    }
};
</code></pre>
<p>上述代码中第13行和第22行就是显示指定了要重写父类的test()方法，使用了override关键字之后，假设在重写过程中因为误操作，写错了函数名或者函数参数或者返回值编译器都会提示语法错误，提高了程序的正确性，降低了出错的概率</p>
<h3 id="5断言">5.断言</h3>
<h4 id="断言">断言</h4>
<p>断言（assertion）是一种编程中常用的手段。在通常情况下，断言就是将一个返回值总是需要为真的判断表达式放在语句中，用于排除在设计的逻辑上不应该产生的情况。</p>
<p>比如：一个函数总需要输入在一定的范围内的参数，那么程序员就可以对该参数使用断言，以迫使在该参数发生异常的时候程序退出，从而避免程序陷入逻辑的混乱。</p>
<p>从一些意义上讲，断言并不是正常程序所必需的，不过对于程序调试来说，通常断言能够帮助程序开发者快速定位那些违反了某些前提条件的程序错误。</p>
<p>如果我们要在C++程序中使用断言，需要在程序中包含头文件<cassert>或&lt;assert.h&gt;，头文件中为我们提供了 assert 宏，用于在运行时进行断言。举例说明：</p>
<pre><code class="language-cpp">#include &lt;iostream&gt;
#include&lt;cassert&gt;
using namespace std;
char* creatArray(int size)
{
	assert(size &gt; 0);
	char* Array = new char[size];
	return Array;
}
int main()
{
	char* buf = creatArray(0);
	system(&quot;pause&quot;);
	return 0;

}
</code></pre>
<h4 id="静态断言">静态断言</h4>
<p>在上面的例子中我们使用了断言 assert。<font color='cornflowerblue'>但 assert是一个运行时断言，也就是说它只有在程序运行时才能起作用 </font>。这意味着不运行程序我们将无法得知某些条件是否是成立的。 比如：我们想知道当前是32位还是64位平台，对于这个需求我们应该是在程序运行之前就应该得到结果，如果使用断言显然是无法做到的，对于这种情况我们就需要使用C++11提供的静态断言了。</p>
<p>静态断言static_assert，所谓静态就是在编译时就能够进行检查的断言，使用时不需要引用头文件。静态断言的另一个好处是，可以自定义违反断言时的错误提示信息。静态断言使用起来非常简单，它接收两个参数：</p>
<ul>
<li>参数1：断言表达式，这个表达式通常需要返回一个 bool值</li>
<li>参数2：警告信息，它通常就是一段字符串，在违反断言（表达式为false）时提示该信息</li>
</ul>
<pre><code class="language-cpp">#include &lt;iostream&gt;                                         
using namespace std;

int main()
{
    // 字体原因看起来是一个=, 其实这是两个=
    static_assert(sizeof(long) == 4, &quot;错误, 不是32位平台...&quot;);
    cout &lt;&lt; &quot;64bit Linux 指针大小: &quot; &lt;&lt; sizeof(char*) &lt;&lt; endl;
    cout &lt;&lt; &quot;64bit Linux long 大小: &quot; &lt;&lt; sizeof(long) &lt;&lt;endl;

    return 0;

}
</code></pre>
<h3 id="异常和noexcept">异常和noexcept</h3>
<h4 id="异常">异常</h4>
<p>异常通常用于处理逻辑上可能发生的错误，在C++98中为我们提供了一套完善的异常处理机制，我们可以直接在程序中将各种类型的异常抛出，从而强制终止程序的运行。</p>
<pre><code class="language-cpp">int main()
{ 
    try
    {
        throw -1; 
    } 
    catch (int e)
    { 
        cout &lt;&lt; &quot;int exception, value: &quot; &lt;&lt; e &lt;&lt; endl; 
    } 
    cout &lt;&lt; &quot;That's ok!&quot; &lt;&lt; endl; 
    return 0; 
}
</code></pre>
<h4 id="noexcept">noexcept</h4>
<p>表示其修饰的函数不会抛出异常 。不过与 <code>throw()</code>动态异常声明不同的是，<font color='red'>在 C++11 中如果 noexcept 修饰的函数抛出了异常，编译器可以选择直接调用 std::terminate() 函数来终止程序的运行，这比基于异常机制的 throw() 在效率上会高一些</font>。这是因为异常机制会带来一些额外开销，比如函数抛出异常，会导致函数栈被依次地展开（栈解旋），并自动调用析构函数释放栈上的所有对象。</p>
<p>从语法上讲，noexcept 修饰符有两种形式：</p>
<p>简单地在函数声明后加上 noexcept 关键字</p>
<p>可以接受一个常量表达式作为参数，如下所示∶</p>
<pre><code class="language-cpp">double divisionMethod(int a, int b) noexcept(常量表达式);
</code></pre>
<p>常量表达式的结果会被转换成一个bool类型的值：</p>
<ul>
<li>值为 true，表示函数不会抛出异常</li>
<li>值为 false，表示有可能抛出异常这里</li>
<li>不带常量表达式的noexcept相当于声明了noexcept（true），即不会抛出异常。</li>
</ul>
<h3 id="字符串和数值类型之间的转换">字符串和数值类型之间的转换</h3>
<h4 id="to_string">to_string()</h4>
<p>数字转成字符串</p>
<h4 id="stoi">stoi()</h4>
<p>字符串转换成数字，默认是十进制，第二个参数通常写0 或者nullptr</p>
<pre><code class="language-cpp">inline int stoi(const string&amp; _Str, size_t* _Idx = nullptr, int _Base = 10)
</code></pre>
<pre><code class="language-cpp">//字符串和数值类型之间的转换
#include &lt;iostream&gt;
#include&lt;string&gt;
using namespace std;
void numbertostring()
{
	double a = 3.1415926;
	string b = to_string(a);
	cout &lt;&lt; b &lt;&lt; endl;
}
void stringtonumber()
{
	string a = &quot;2020.04.01 is a goodday!&quot;;
	string b = &quot;10001&quot;;
	string c = &quot;0x13&quot;;
	size_t sz;
	int i_a = stoi(a, &amp;sz);
	int i_b = stoi(b, 0,2);//int i_b=stoi(b,nullptr,2)
	int i_c = stoi(c, nullptr, 0);//0为编译器自动推导
	cout &lt;&lt; i_a &lt;&lt; endl;
	cout &lt;&lt; i_b &lt;&lt; endl;
	cout &lt;&lt; i_c &lt;&lt; endl;
}
int main()
{
	numbertostring();
	stringtonumber();
	system(&quot;pause&quot;);
	return 0;

}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vim命令]]></title>
        <id>https://tangyin1.github.io/post/vim-ming-ling/</id>
        <link href="https://tangyin1.github.io/post/vim-ming-ling/">
        </link>
        <updated>2023-11-09T02:17:53.000Z</updated>
        <summary type="html"><![CDATA[<p>vim命令大全，需要自己多看多用。也可在终端输入 vimtutor来帮助自己学习！</p>
]]></summary>
        <content type="html"><![CDATA[<p>vim命令大全，需要自己多看多用。也可在终端输入 vimtutor来帮助自己学习！</p>
<!-- more -->
<h2 id="基础命令"><strong>基础命令</strong></h2>
<ul>
<li><code>$ vim code.c</code>: 在终端中打开 code.c 文件</li>
<li><code>$ vim ~/.vimrc</code>: 打开根目录下的 <code>.vimrc</code> 文件</li>
<li><code>$ vim -u NONE -N</code>: 以不加载任何插件的方式启动 vim</li>
<li><code>:h [option]</code>: 显示对命令的帮助</li>
<li><code>:source ~/.vimrc</code>: 重载配置文件(可以在不重启 vim 的情况下重载配置文件)</li>
<li><code>:syntax on</code>: 开启语法</li>
<li><code>:set number</code>: 设置行号</li>
<li><code>:set ft=json</code>: 设置的文件格式为<code>json 格式</code></li>
<li><code>:set ft?</code>: 查看当前文件的 ft 值</li>
<li><code>.</code>: 修改完之后移动至下一个单词出按<code>.</code> 可重复相同操作(厉害!)</li>
<li><code>5.</code>: 重复 5 次相同动作</li>
<li><code>*</code>: 向下查找光标下的单词</li>
<li><code>#</code>: 向上查找光标下的单词</li>
<li><code>ga</code>: 查看当前光标下字符的 unicode 码及其他详细信息</li>
<li><code>:e.</code>: <code>.</code> 代表 <code>pwd</code> 的结果, 即当前工作路径, 这个命令会进入 <code>netrw</code> 的文件管理界面</li>
</ul>
<h2 id="保存退出"><strong>保存退出</strong></h2>
<ul>
<li><code>:q</code>: 退出文件</li>
<li><code>q:</code>: 进入命令历史记录, 与<code>:history</code> 等价</li>
<li><code>q/</code>: 进入搜索历史记录</li>
<li><code>:wq</code>: 保存退出</li>
<li><code>:wa</code>: 保存所有缓冲区</li>
<li><code>:wn</code>: 保存当前缓冲区并进入下一个参数列表</li>
<li><code>:qa</code>: 退出所有缓冲区</li>
<li><code>ZZ</code>: 保存退出</li>
<li><code>:sav path/to.txt</code>: 将本缓冲区保存为文件(相当于另存为, 命令全名是 <code>saveas</code>)</li>
<li><code>:w path/to.txt</code>: 保存到某路径</li>
<li><code>:e!</code>: 重载本文件, 即使有未保存的内容也会被丢弃(edit 缩写)</li>
<li><code>:e path/to.txt</code>: 打开指定文件</li>
<li><code>:e .</code>: 进入 <code>netrw</code> 浏览目录</li>
</ul>
<h2 id="移动"><strong>移动</strong></h2>
<ul>
<li><code>hjkl</code>: 左下上右键</li>
<li><code>10 + hjkl</code>: 向左下上右跳 10 个格</li>
<li><code>gj</code>: 在一段被折为多行时, 将光标向下移动一行(向下移动一个屏幕行)</li>
<li><code>gk</code>: 在一段被折为多行时, 将光标向上移动一行(向上移动一个屏幕行)</li>
<li><code>&gt;&gt;</code>: 整行向右缩进</li>
<li><code>&lt;&lt;</code>: 整行向左缩进</li>
<li><code>:le</code>: 当前行居左对齐</li>
<li><code>:ce</code>: 当前行居中对齐</li>
<li><code>:ri</code>: 当前行居右对齐</li>
<li><code>0</code>: 移动到行首(非字符)</li>
<li><code>^</code>: 光标移至行首(字符)</li>
<li><code>g^</code>: 移动到屏幕行的行首</li>
<li><code>$</code>: 光标移至行尾(换行符)</li>
<li><code>g$</code>: 移动到屏幕行的行尾</li>
<li><code>g_</code>: 光标移至最后一个可见字符上</li>
<li><code>0</code>: 光标移动至行首</li>
<li><code>g;</code>: 跳转到上次修改的位置</li>
<li><code>g,</code>: 跳转到下次修改的位置</li>
<li><code>gi</code>: 跳转到上次退出插入模式的位置并直接进入 <code>Insert Mode</code></li>
<li><code>%</code>: 在 <code>()</code>, <code>[]</code>, <code>{}</code> 之内跳转到包围符号上</li>
<li><code>''</code>, 双反撇号, 跳转到当前文件中最近一次跳转动作发生时的位置</li>
<li><code>'.</code>: 反撇号, 跳转到上次修改的地方</li>
<li><code>w</code>: 跳至下一个词首</li>
<li><code>b</code>: 跳至上一个词首</li>
<li><code>e</code>: 跳至下一个词末端</li>
<li><code>ge</code>: 跳转到上一个词的结尾</li>
<li><code>f</code>: 移动到行内下一个字符, 如 <code>fx</code> 将查找行内出现的下一个 <code>x</code> 字符</li>
<li><code>F</code>: 移动到行内上一个字符, 用法同 <code>f</code></li>
<li><code>t</code>: 移动到行内下一个字符的前一字符上</li>
<li><code>T</code>: 移动到行内上一个字符的下一字符上</li>
<li><code>;</code>: 重复查找, 即重复 <code>f</code> 或 <code>t</code>, 非常有用, 可以与 <code>.</code> 想媲美</li>
<li><code>,</code>: <code>;</code> 的反面, 当按 <code>;</code> 过头了可以用 <code>,</code> 退回来</li>
<li><code>&lt;C-b&gt;</code>: 向前滚一页</li>
<li><code>&lt;C-f&gt;</code>: 向后滚一页</li>
<li><code>&lt;C-e&gt;</code>: 向上滚一行</li>
<li><code>&lt;C-y&gt;</code>: 向下滚一行</li>
<li><code>&lt;C-u&gt;</code>: 向上滚半页</li>
<li><code>&lt;C-d&gt;</code>: 向下滚半页</li>
<li><code>gg</code>: 跳至文件顶部</li>
<li><code>G</code>: 跳至文件底部</li>
<li><code>M</code>: 光标移至页中部</li>
<li><code>L</code>: 光标移至页底部</li>
<li><code>H</code>: 光标移至页顶部</li>
<li><code>88gg</code>: 跳至第 88 行</li>
<li><code>88G</code>: 跳至第 88 行</li>
<li><code>zz</code>: 将当前行置于视图中央</li>
<li><code>zt</code>: 将当前行置于视图顶部</li>
<li><code>zb</code>: 将当前行置于视图底部</li>
<li><code>gd</code>: 跳转到局部变量定义处</li>
<li><code>gD</code>: 跳转到文件内全局声明(从文件开头开始查找)</li>
<li><code>gf</code>: 跳转到相应的头文件</li>
<li><code>&lt;C-o&gt;</code>: Normal 模式下返回上一个操作的位置, Insert 模式下切换到 Normal 模式, 输入完命令后再次进入 Insert 模式: <code>c-o zz</code></li>
<li><code>&lt;C-t&gt;</code>: Normal 模式下返回上一个操作的位置</li>
<li><code>&lt;C-i&gt;</code>: Normal 模式下返回下一个操作的位置</li>
<li><code>&lt;C-^&gt;</code>: 在当前文件与上次编辑的文件中快速切换</li>
<li><code>mm</code>: 为当前位置在当前缓冲区内设置标记 <code>m</code></li>
<li><code>'m</code>: 反撇号, 跳转到设置的标记 <code>m</code> 处</li>
<li><code>mM</code>: 为当前位置设置全局标记 <code>M</code>(必须是大写, 可以跨文件使用)</li>
<li><code>'M</code>: 跳转到全局标记</li>
</ul>
<h2 id="复制粘贴删除"><strong>复制/粘贴/删除</strong></h2>
<ul>
<li>
<p><code>c</code>: 删除并进入<code>插入模式</code> (理解: <code>cert</code> , 会插入)</p>
</li>
<li>
<p><code>cw</code>: 删除一个单词并进入<code>插入模式</code></p>
</li>
<li>
<p><code>C</code>: 删除自游标处到当前行尾, 并进入<code>插入模式</code></p>
</li>
<li>
<p><code>c2c</code>: 删除两行并进入<code>插入模式</code></p>
</li>
<li>
<p><code>cc</code>: 删除一行并进入<code>插入模式</code></p>
</li>
<li>
<p><code>d^</code>: 删除至行首 (理解: <code>delete</code> , 不会插入, 直接删除, 不会复制)</p>
</li>
<li>
<p><code>D</code>: 从当前光标处删除至行尾</p>
</li>
<li>
<p><code>dw</code>: 向右删除一个单词</p>
</li>
<li>
<p><code>d2d</code>: 删除两行</p>
</li>
<li>
<p><code>dd</code>: 删除一行</p>
</li>
<li>
<p><code>d121gg</code>: 从当前行删除到 121 行</p>
</li>
<li>
<p><code>d121j</code>: 从当前行向下删除 121 行</p>
</li>
<li>
<p><code>x</code>: 删除本字符(等于 delete)</p>
</li>
<li>
<p><code>X</code>: 向前删除一个字符(等于 backspace)</p>
</li>
<li>
<p><code>s</code>: 删除右侧并进入插入模式</p>
</li>
<li>
<p><code>S</code>: 删除整行并进入插入模式</p>
</li>
<li>
<p><code>yy</code>: 复制一行</p>
</li>
<li>
<p><code>y$</code>: 从光标当前处复制到结尾, 不会复制到换行符, 但是如果 <code>v$y</code> 则会复制到换行符</p>
</li>
<li>
<p><code>y</code>: 复制所选(可视模式)</p>
</li>
<li>
<p><code>y5j</code>: 向下复制 5 行</p>
</li>
<li>
<p><code>v/d/c/y</code> + <code>[文本对象]</code></p>
</li>
<li>
<ul>
<li>
<p>操作分隔符的文本对象: 用于确定范围</p>
</li>
<li>
<ul>
<li><code>i(/[/{/&quot;/'</code>: 由<code>(/[/{/&quot;/'</code> 包围起来的字符, 不包含 <code>(/[/{/&quot;/'</code></li>
<li><code>a(/[/{/&quot;/'</code>: 由 <code>(/[/{/&quot;/'</code>包围起来的字符及包围符号本身</li>
<li><code>it</code>: 由 tag 包围起来的字符</li>
<li><code>at</code>: 由 tag 包围起来的字符及 tag 本身</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p>操作文本块的文本对象</p>
</li>
<li>
<ul>
<li><code>iw</code>: 当前单词</li>
<li><code>aw</code>: 当前单词及一个空格</li>
<li><code>iW</code>: 当前字串</li>
<li><code>aW</code>: 当前字串及一个空格</li>
<li><code>is</code>: 当前句子</li>
<li><code>as</code>: 当前句子及一个空格</li>
<li><code>ip</code>: 当前段落</li>
<li><code>ap</code>: 当前段落记一个空行</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>一般来说, <code>d{motion}</code> 命令和 <code>aw</code>, <code>as</code> 和 <code>ap</code> 配合起来使用比较好,而 <code>c{motion}</code> 命令和 <code>iw</code> 及类似的文本对象一起用效果会更好.</li>
</ul>
</li>
<li>
<p><code>p</code>: 如果整行复制, 粘贴在下方一行. 如果选中复制, 粘贴到当前光标后方</p>
</li>
<li>
<p><code>P</code>: 与 <code>p</code> 方向相反</p>
</li>
<li>
<p><code>gp</code>: 与<code>p</code>类似, 不过会把光标移动至文本的结尾</p>
</li>
<li>
<p><code>gP</code>: 与 <code>P</code>类似, 不过会把光标移动到文本的结尾, 在粘贴多行的时候尤其有用</p>
</li>
</ul>
<h2 id="模式切换"><strong>模式切换</strong></h2>
<ul>
<li><code>i</code>: 当前字符之前插入</li>
<li><code>I</code>: 行首插入</li>
<li><code>a</code>: 当前字符之后插入</li>
<li><code>A</code>: 当前字符行尾插入</li>
<li><code>o</code>: 在下方插入一行并进入<code>Insert Mode</code></li>
<li><code>O</code>: 在上方插入一行并进入<code>Insert Mode</code></li>
<li><code>&lt;C-v&gt;</code>: 进入列选择模式, 可沿垂直方向选中多行, 然后使用大写的 I 和 A 分别可以实现在前侧和后侧批量添加字符, 使用 <code>&gt;</code> 可以向右缩进, 使用 <code>r</code> 可以替换, 特别好用!</li>
<li><code>v</code>: 进入 visual 模式, 移动光标可进行批量选择删除</li>
<li><code>gv</code>: 重复选择上次选择并操作的区域</li>
<li><code>O</code>: 在 Visual 模式下切换高亮选取的活动端使之可调整</li>
</ul>
<h2 id="大小写加减"><strong>大小写/加减</strong></h2>
<ul>
<li>
<p><code>~</code>: 将当前光标处的大小写翻转</p>
</li>
<li>
<p><code>g~5j</code>: 将当前行向下 5 行大小写反转</p>
</li>
<li>
<p><code>gu5j</code>: 将当前行向下 5 行改为小写</p>
</li>
<li>
<p><code>gU5j</code>: 将当前行向下 5 行改为大写</p>
</li>
<li>
<p><code>gUit</code>: 将 tag 包围的内容改为大写</p>
</li>
<li>
<p><code>Vu</code>: 将当前行改为小写</p>
</li>
<li>
<p><code>VU</code>: 将当前行改为大写</p>
</li>
<li>
<p><code>veu</code>: 当前光标至尾端的字符改为小写</p>
</li>
<li>
<p><code>vG~</code>: 将当前光标至文本结尾的字符翻转大小写</p>
</li>
<li>
<p><code>&lt;C-a&gt;</code>: 对数字进行增加操作, 在列选择模式下批量增加数字, 对 Markdown 的列表排序特别好用</p>
</li>
<li>
<ul>
<li><code>&lt;C-v&gt;</code> + <code>select</code> + <code>C-a</code>: 将选择区域数字统一增加 1</li>
<li><code>&lt;C-v&gt;</code> + <code>select</code> + <code>2</code> + <code>C-a</code>: 将选择区域数字统一增加 2</li>
<li><code>&lt;C-v&gt;</code> + <code>select</code> + <code>g</code> + <code>C-a</code>: 将选择区域的数字改为递增为 1 的序列</li>
<li><code>&lt;C-v&gt;</code> + <code>select</code> + <code>2</code> + <code>g</code> + <code>C-a</code>: 将选择区域的数字改为递增为 2 的序列</li>
</ul>
</li>
<li>
<p><code>&lt;C-x&gt;</code>: 对数字进行缩小操作(用法同<code>C-a</code> )</p>
</li>
</ul>
<h2 id="撤销"><strong>撤销</strong></h2>
<ul>
<li><code>u</code>: 撤销 undo(命令模式, 可多次撤销)</li>
<li><code>U</code>: 无论当前行修改了多少次, 全部撤销操作</li>
<li><code>&lt;C-r&gt;</code>: Normal 模式下反撤销</li>
<li><code>:undolist</code>: 撤销历史(命令模式)</li>
<li><code>:undo 5</code>: 撤销 5 个改变(命令模式)</li>
</ul>
<h2 id="folding"><strong>Folding</strong></h2>
<ul>
<li><code>zc</code>: close, 关闭当前光标下可折叠区域</li>
<li><code>zo</code>: open, 打开当前光标下可折叠区域</li>
<li><code>za</code>: toggle, 打开/关闭当前光标下可折叠区域</li>
<li><code>zC/zO/zA</code>: 与小写不同的是操作对象为全局, 与光标位置无关</li>
<li><code>zr</code>: reduce, 减少折叠等级</li>
<li><code>zR</code>: 将所有折叠级别减值最小(直观看来就是缓冲区完全展开了)</li>
<li><code>zm</code>: more, 增加折叠级别</li>
<li><code>zM</code>: 增加折叠级别至最高(直观看来就是缓冲区完全折叠了)</li>
<li><code>zd</code>: 删除当前折叠</li>
<li><code>zE</code>: 删除所有折叠</li>
<li><code>zj</code>: 移动至下一个折叠</li>
<li><code>zk</code>: 移动至上一个折叠</li>
<li><code>zn</code>: 禁用折叠</li>
<li><code>zN</code>: 启用折叠</li>
</ul>
<h2 id="windowtab"><strong>window/tab</strong></h2>
<ul>
<li><code>:tabnew [filename]</code>: 新建一个标签页, 例: <code>tabnew%</code> 以当前文件新建一个标签页, <code>%</code> 表示当前文件</li>
<li><code>:tabclose</code>: 关闭当前标签</li>
<li><code>:tabonly</code>: 关闭所有其他的tab</li>
<li><code>:tabn</code>: 前一个 tab</li>
<li><code>:tabp</code>: 后一个 tab</li>
<li><code>tabdo %s/foo/bar/g</code>: 在所有打开的 tab 上执行替换</li>
<li><code>tab ball</code>: 将所有的缓冲区在 tab 中打开</li>
<li><code>gt</code>: 跳转到下一个 tab</li>
<li><code>gT</code>: 跳转到上一个 tab</li>
<li><code>gt5</code>: 跳转到第 5 个 tab 上</li>
<li><code>:tabn</code>: 移动至下一个标签, 直接使用 gt 也可</li>
<li><code>:tabp</code>: 移动至上一个标签, 直接使用 gT 也可</li>
<li><code>:sp</code>: 上下切割当前文件, 同 <code>&lt;C-w&gt; s</code></li>
<li><code>:vs</code>: 左右切割当前文件, 同 <code>&lt;C-w&gt; v</code></li>
<li><code>:sp [filename]</code>: 上下分割并打开一个新文件, 如果不输入 filename 会切割打开本文件(光标在文件开头位置)</li>
<li><code>:vs [filename]</code>: 左右分割并打开一个新文件, 如果不输入 filename 会切割打开本文件(光标在文件开头位置)</li>
<li><code>&lt;C-w&gt; T</code>: 如果当前 tab 存在多个不同的window, 那么将当前 window 移动到新标签上, 必须是大写</li>
<li><code>&lt;C-w&gt; s</code>: 水平切割当前窗口</li>
<li><code>&lt;C-w&gt; v</code>: 垂直切割当前窗口</li>
<li><code>&lt;C-w&gt; h/j/k/l</code>: 光标向某个方向分屏移动</li>
<li><code>&lt;C-w&gt; w</code>: 在所有窗口间进行切换</li>
<li><code>&lt;C-w&gt; _</code>: 使窗口高度最大化</li>
<li><code>&lt;C-w&gt; |</code>: 使窗口宽度最大化</li>
<li><code>&lt;C-w&gt; =</code>: 使所有窗口等宽等高</li>
<li><code>&lt;C-w&gt; q</code>: quit, 关闭当前分屏, 如果是最后一个, 则退出 vim</li>
<li><code>&lt;C-w&gt; c</code>: close, 关闭当前分屏, 如果是最后一个, 则退出 vim</li>
<li><code>&lt;C-w&gt; o</code>: only, 关闭所有除当前屏幕外的所有分屏</li>
<li><code>&lt;C-w&gt; L</code>: 当前分屏向右移动</li>
<li><code>[N]&lt;C-w&gt; +</code>: 分屏增加 N 列高度(可选)</li>
<li><code>[N]&lt;C-w&gt; &lt;</code>: 分屏减少 N 列宽度(可选)</li>
<li><code>:close</code>: 关闭活动窗口</li>
<li><code>:only</code>: 只留下当前活动窗口</li>
<li><code>new abc.txt</code>: 在新窗口中编辑文件</li>
</ul>
<h2 id="buffer"><strong>Buffer</strong></h2>
<ul>
<li><code>:ls</code>: 显示当前所有 buffer(缓冲区列表)</li>
<li><code>:ls!</code> : 列出非缓冲区列表文件</li>
<li><code>:bn</code>: buffer next, 下一个 buffer</li>
<li><code>:bp</code>: buffer previous, 上一个 buffer</li>
<li><code>:bf</code>: 打开第一个 buffer</li>
<li><code>:bl</code>: 打开最后一个 buffer</li>
<li><code>:b1</code>: 切换到 buffer1(同理可按照数字切换到不同的 buffer)</li>
<li><code>:bd</code>: 删除 buffer(并没有删除文件本身, 只是 buffer 而已)</li>
<li><code>:bd 1 3</code>: 删除 buffer 编号为 <code>1</code>, <code>3</code> 的两个 buffer</li>
<li><code>:bw 3</code> : 将非缓冲区文件全部删除</li>
<li><code>:bfirst</code>: 第一个缓冲区</li>
<li><code>:blast</code>: 最后一个缓冲区</li>
<li><code>:bufdo [command]</code>: 对所有缓冲区执行操作</li>
<li><code>:1,3 bd</code>: 删除 buffer 编号在 <code>1~3</code>之间的所有 buffer</li>
</ul>
<h2 id="tag"><strong>Tag</strong></h2>
<ul>
<li><code>&lt;C-]&gt;</code>: 跳转到当前光标的定义处</li>
<li><code>g &lt;C-]&gt;</code>: 查看当前光标处有多少个定义(可输入数字然后跳转)</li>
<li><code>g ]</code>: 查看当前光标处有多少个定义(可输入数字然后跳转)</li>
<li><code>tag {keyword}</code>: 根据 <code>keyworkd</code> 查找有多少个匹配的 tag</li>
<li><code>tag</code>: 正向遍历标签历史</li>
<li><code>tnext</code>: 跳转到下一处匹配的标签</li>
<li><code>tprev</code>: 跳转到上一处匹配的标签</li>
<li><code>tfist</code>: 跳转到第一处匹配的标签</li>
<li><code>tlast</code>: 跳转到最后一处匹配的标签</li>
<li><code>tselect</code>: 提示用户从标签匹配的列表中选择一项进行跳转</li>
</ul>
<h2 id="quick-list"><strong>Quick-list</strong></h2>
<ul>
<li><code>:cnext</code> : 显示当前页下一个结果</li>
<li><code>:cpre</code> : 显示当前页上一个结果</li>
<li><code>:copen</code> : 打开 Quickfix 窗口</li>
<li><code>:cfirst</code>: 跳转到第一项</li>
<li><code>:clast</code>: 跳转到最后一项</li>
<li><code>:cnfile</code>: 跳转到下一个文件中的第一项</li>
<li><code>:cpfile</code>: 跳转到上一个文件中的最后一项</li>
<li><code>:cc N</code>: 跳转到第 n 项</li>
<li><code>:cclose</code> : 关闭 Quickfix 窗口</li>
<li><code>:cdo {cmd}</code>: 在 quickfix 列表中的每一行上执行 {cmd}</li>
<li><code>:cfdo {cmd}</code>: 在 quickfix 列表上的每个文件上执行一次 {cmd}</li>
<li><code>:cl[ist]</code> : 打开 location list 窗口, 目前看来不需要使用此选项</li>
</ul>
<h2 id="location-list"><strong>Location List</strong></h2>
<p>与 Quick-List 相似, 最大的不同是: Quick-List 是针对多个窗口共享一个结果, 而 <code>Location List</code> 则是各个窗口的结果互相独立</p>
<ul>
<li><code>lopen</code>: 用于打开位置列表窗口</li>
<li><code>lclose</code>: 用于关闭位置列表窗口</li>
<li><code>lnext</code>: 用于切换到位置列表中的下一项</li>
<li><code>lprevious</code>: 用于切换到位置列表中的上一项</li>
<li><code>lwindow</code>: 用于在错误出现时才触发位置列表窗口</li>
</ul>
<h2 id="宏"><strong>宏</strong></h2>
<ul>
<li><code>q + 小写字母</code>: 进入宏记录模式, 记录到<code>小写字母</code>寄存器中, 记录完成后再次按下 <code>q</code> 即可.</li>
<li><code>q + 大写字母</code>: 进入宏记录模式, 在 <code>小写字母</code>寄存器尾部接着添加命令, 记录完成后再次按下 <code>q</code> 即可.</li>
<li><code>@ + 小写字母</code>: 执行对应寄存器内的宏. 可使用前缀添加数字的方式重复多次命令</li>
<li><code>@:</code>: 重复执行上一次运行过的命令, <code>:</code> 寄存器总是保存着最后执行的命令行命令</li>
<li><code>@@</code>: 直接重复上一次的 <code>@</code> 命令, 此命令必须建立在上一次使用了以 <code>@</code> 开头的寄存器宏 或者 刚刚建立了一个寄存器宏的 基础上, 因此经常配合 <code>@:</code> 使用.</li>
<li><code>10@a</code>: 执行寄存器 <code>a</code>中所存储宏 10 次(串行处理, 如果有错误, 则立刻停止, 后续命令不再执行)</li>
</ul>
<h2 id="参数列表"><strong>参数列表</strong></h2>
<p>参数列表与缓冲区的概念很类似, 参数列表的原始含义是我们在终端中使用 <code>vim a.txt b.txt</code> 时后面的一系列文件或参数名, 但是我们也可以在进入 vim 后使用 <code>args</code>手动添加参数文件. 其与缓冲区的区别是:</p>
<ol>
<li>位于参数列表的文件必然位于缓冲区列表中</li>
<li>缓冲区列表永远是乱糟糟的, 但是参数列表永远是秩序井然</li>
</ol>
<ul>
<li><code>:args *.*</code> : 将当前目录下的所有类型的文件加入到参数列表中(不包括文件夹中的文件)</li>
<li><code>:args **/*.*</code> : 将当前目录下的所有文件及子文件夹的所有文件都匹配加入到参数列表中</li>
<li><code>:args *.md aa/**/*.md</code> 表示添加子文件夹下的 md 文件及 aa 文件夹下的和其子文件夹下的 md 文件到参数列表中</li>
<li><code>:args 'cat list.txt'</code>: 用反撇号将命令包围起来, 然后将命令被执行后的结果作为参数加入参数列表中</li>
<li><code>:argdo %s/oldword/newword/egc | update</code> : 对所有存在参数列表中的文件执行命令, s 代表替换, % 指对所有行进行匹配, g 代表整行替换(必用), e 指使用正则表达式, c 代表每次替换前都会进行确认, update 表示对文件进行读写</li>
<li><code>:argdo write</code>: 将所有参数列表中的内容进行缓冲区保存</li>
<li><code>:argdo normal @a</code>: 将当前参数列表的所有缓冲区执行寄存器 a 中所存储的宏</li>
<li><code>:argd *</code> : 清空参数列表</li>
<li><code>:argdo bw</code> : 将参数列表中的所有文件清除出缓冲区</li>
<li><code>args</code>: 显示当前的所有参数列表</li>
<li><code>:next</code>: 跳转到下一个参数列表的文件</li>
<li><code>:prev</code>: 跳转到上一个参数列表的文件</li>
<li><code>:first</code>: 跳转到第一个参数列表的文件</li>
<li><code>:last</code>: 跳转到最后一个参数列表的文件</li>
<li><code>:args **/*.md</code> : 将当前文件夹下所有.md 文件加入到参数列表中(包括子文件夹中的文件)</li>
<li><code>:argdo %s/!\[.*\]/!\[img\]/gc</code>: 将所有参数列表中的以 <code>![</code> 开头, 以 <code>]</code> 结尾的所有字段改为 <code>[img]</code></li>
<li><code>:argdo source FormatCN.vim</code>: 对参数列表中的所有文件执行脚本 <code>FormatCN.vim</code></li>
</ul>
<h2 id="命令行模式"><strong>命令行模式</strong></h2>
<ul>
<li><code>:shell</code>: 调用系统的 <code>shell</code> 来在 vim 进程中执行命令, 执行完使用 <code>exit</code> 退出</li>
<li><code>:term bash</code>: 在底部分割出一个独立窗口并调用 <code>bash</code>, 也可以使用 <code>term zsh</code> 来调用 <code>zsh</code>, 或 <code>:terminal zsh</code></li>
<li><code>&lt;C-w&gt; N</code>: 在进入 <code>:term</code> 的终端模式后, 使用本命令可以获得 <code>Normal 模式</code> 的效果, 使用 <code>i</code> 返回正常的终端模式</li>
<li><code>:col&lt;C-d&gt;</code>: 在 Ex 命令模式中使用补全查看可能的选项, 然后使用 <code>Tab</code>/<code>S-Tab</code> 进行选择/反向选择</li>
<li><code>&lt;C-r&gt;&lt;C-w&gt;</code>: 将当前的光标下的单词插入到命令行中</li>
<li><code>&lt;C-f&gt;</code>: 将正在命令行中输入的内容放入到命令行窗口开始编辑</li>
<li><code>&lt;C-c&gt;</code>: 与 <code>&lt;C-f&gt;</code> 相反, 此命令可以使命令行窗口的当前行内容从命令行窗口放回到命令行中</li>
<li><code>&lt;C-z&gt;</code>: 在终端中将 <code>vim</code> 最小化, 然后如果再需要调用的话使用 <code>fg</code> 进行操作, 使用 <code>jobs</code>查看所有处于后台的工作</li>
<li><code>&lt;C-b&gt;</code>: beginning, 在命令行模式中跳转到行首</li>
<li><code>&lt;C-e&gt;</code>: end, 在命令行模式中跳转到结尾</li>
<li><code>&lt;C-p&gt;</code>: 在命令行模式中显示上次的命令</li>
<li><code>&lt;C-n&gt;</code>: 在命令行模式中显示下次的命令</li>
<li><code>:!&lt;command&gt;</code>: 在 shell 中执行命令</li>
<li><code>!sh %</code>: 将当前文件使用外部程序 sh 执行, <code>%</code> 代表本文件</li>
<li><code>!!&lt;command&gt;</code>: 运行命令并将结果作为当前行的内容, 同 <code>:read !&lt;command&gt;</code></li>
<li><code>:!ls</code>: 显示当前工作目录下的所有文件(此操作属于调用系统进程, 使用!来调用系统操作是 Vim 的一大特点)</li>
<li><code>:w !sudo tee % &gt; /dev/null</code>: 在当前用户没有权限对当前文件做操作时使用超级管理员身份进行操作</li>
<li><code>:ls</code>: 列出当前所有的缓冲区文件列表, 执行的是 vim 的 ls 命令</li>
<li><code>:f</code>: 显示当前文件路径, (使用了 <code>&lt;C-g&gt;</code> 代替, 此项基本不会用了)</li>
<li><code>:command</code>: 显示当前所文件的所有可使用命令</li>
<li><code>:retab</code> : 重新生成所有的 tab(主要用于在 .vimrc 中重新设置了 tab 格式, 然后在已存在旧格式 tab 的文档进行重生成)</li>
<li><code>:map g</code>: 查看所有以 <code>g</code> 开头的映射</li>
</ul>
<blockquote>
<p>❝Vim 的先祖是 vi, 正是 vi 开创了区分模式编辑的范例. 相应的, vi 奉 一个名为 ex 的行编辑器为先祖, 这就是为什么会有 Ex 命令.</p>
</blockquote>
<p>Ex 命令在命令行模式中执行, 而命令行模式的进入方式为 <code>:</code> 键, 因此我们可以看到所有的 <code>Ex</code> 命令都是以 <code>:</code> 开始的, 输入完命令后按下确定键 <code>&lt;CR&gt;</code> 即可执行, 虽然 <code>Ex</code> 命令年代久远, 但是不可否认其语法的简洁明了以及高效, 很多复杂的操作往往都是通过 <code>Ex</code> 命令来进行处理.</p>
<ul>
<li>
<p><code>:[range] &lt;command&gt; [target]</code>: 执行命令并将结果放入目标位置</p>
</li>
<li>
<ul>
<li>
<p><code>:3,5 w !bash</code>: 将 3~5 行写入 bash</p>
</li>
<li>
<p><code>:. w !bash</code>: 将当前行写入 bash</p>
</li>
<li>
<p><code>:. !bash</code>: 将当前行执行结果写入当前 buffer</p>
</li>
<li>
<p><code>:3,5 delete x</code>: 将当前行执行结果删除到 x 寄存器</p>
</li>
<li>
<p><code>:3,5 yank x</code>: 将当前行执行结果复制到 x 寄存器</p>
</li>
<li>
<p><code>:. put x</code>: 在当前行后粘贴寄存器 x 的内容</p>
</li>
<li>
<p><code>:3,5 copy .</code>: 将 3~5 行复制到当前行下</p>
</li>
<li>
<p><code>:3,5 move .</code>: 将 3~5 行移动到当前行下</p>
</li>
<li>
<p><code>:3,5 join</code>: 将 3~5 行进行合并</p>
</li>
<li>
<p><code>[range] normal [cmd]</code>: normal 用来指定在 normal 模式下对文本的操作命令</p>
</li>
<li>
<ul>
<li><code>:3,5 normal .</code>: 对 3~5 行执行 <code>.</code> 重复命令</li>
<li><code>:3,5 normal @q</code>: 对 3~5 行执行寄存器 <code>q</code> 内存储的命令</li>
<li><code>'&lt;,'&gt; normal @a</code>: 在所选高亮区域上执行宏(如果有错误也不停止, 因为是针对每一行执行的, 出错了只需要不处理那一行就行了)</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li>
<p><code>:[range] global/{pattern}/[cmd]</code>: 对指定范围内匹配的所有行执行 Ex 命令</p>
</li>
<li>
<ul>
<li><code>:g/re/d</code>: 删除所有匹配到 <code>re</code> 的行</li>
<li><code>:g/re/p</code>: 打印所有匹配到 <code>re</code> 的行</li>
<li><code>:g//d</code>: 使用上次的查找结果进行匹配然后删除</li>
<li><code>:v/re/d</code>: vglobal 的反面, 只保留匹配到 <code>re</code> 的行</li>
<li><code>:g/TODO/yank A</code>: 将结果匹配到 <code>TODO</code> 的行复制到寄存器 <code>a</code> 的原内容尾部</li>
<li><code>:g/TODO/t$</code>: 将结果匹配到 <code>TODO</code> 的行复制到本缓冲区的尾部</li>
<li><code>:g:/{pattern}/[range][cmd]</code>: 可以用 <code>:g/{pattern}</code> 匹配作为参考点, 动态设置 <code>[cmd</code> 的 range</li>
<li><code>g/{/ .+1,/}/-1 sort</code>: 会在每个 <code>{</code> 开始找, 然后在之后一直执行到 <code>}</code> 为止, 进行排序</li>
<li><code>g/{/sil .+1,/}/-1 &gt;</code>: 会在每个 <code>{</code> 开始找, 然后在之后一直执行到 <code>}</code> 为止, 进行缩进(加入 sil 是为了屏蔽提示信息)</li>
</ul>
</li>
</ul>
</li>
<li>
<ul>
<li><code>:3,5 s/{pattern}/{string}/[flags]</code>: 将 <code>3~5</code>行进行相应替换</li>
<li><code>:3,5 join</code>: 将 <code>3~5</code>行进行合并</li>
<li><code>:3 p</code>: 打印第 3 行</li>
<li><code>:3,5 p</code>: 打印 3~5 行</li>
<li><code>:.,.+3 p</code>: 打印本行以下的三行内容, <code>+3</code> 代表偏移</li>
<li><code>:% p</code>: 打印本 buffer 的所有行, <code>%</code> 代表所有行, 是 <code>1:$</code> 的简写</li>
<li><code>:0,$ p</code>: 打印本 buffer 所有行, <code>$</code> 代表最后一行</li>
<li><code>:.,$ p</code>: 打印本 buffer 内从本行到结尾的所有内容, <code>.</code> 代表当前行</li>
<li><code>/&lt;html&gt;/+1,/&lt;\/html&gt;/-1 p</code>: 使用 patten 指定范围, <code>+1</code> 表示偏移</li>
<li><code>:6t.</code>: 把第 6 行复制到当前行下方, tail 代表尾巴, 遵守 <code>from...to...</code> 的含义</li>
<li><code>:t6</code>: 把当前行复制到第 6 行下方, <strong>当.位于首位时可以省略.</strong>, 因此全称是 <code>:.t6</code></li>
<li><code>:t.</code>: 粘贴当前行到下方, 与 <code>yyp</code> 不同的是本方式不会将内容放到寄存器中, 而 <code>yyp</code> 会将内容复制到 <code>unname</code> 寄存器与 <code>0</code> 寄存器</li>
<li><code>:t$</code>: 粘贴当前行到文本结尾</li>
<li><code>:'&lt;,'&gt;t0</code>: 把高亮选中的行复制到文件开头, <code>'&lt;</code> 代表高亮选取的第一行, <code>'&gt;</code> 代表高亮选取的最后一行</li>
<li><code>:'&lt;,'&gt;m$</code>: 把高亮选中的行移动到文件结尾</li>
<li><code>:'&lt;,'&gt;A;</code>: 把当前文件的所有行的尾部加上 <code>;</code></li>
</ul>
</li>
<li>
<p><code>:!!</code>: 重复执行上一次运行过的命令</p>
</li>
<li>
<p><code>:read !&lt;command&gt;</code>: 将命令的结果输入(重定向)到当前缓冲区</p>
</li>
<li>
<p><code>:[range]write !sh</code>: 将当前缓冲区的内容, 在 shell 中逐行执行, 与 <code>read !&lt;command&gt;</code>作用正好相反, <code>!</code>表示外部程序</p>
</li>
<li>
<p><code>:[range]write ! sh</code>: 将当前缓冲区的内容, 在 shell 中逐行执行, <code>!</code>表示外部程序</p>
</li>
<li>
<p><code>:[range]write! sh</code>: 将当前缓存区内容写入到一个名为 sh 的文件, <code>!</code>表示强制覆盖式写入</p>
</li>
<li>
<p><code>:[range]write! filename</code>: 将当前缓冲区内容另存为到 filename 文件中</p>
</li>
<li>
<p><code>:.,$ sort [option]</code>: 从当前行到末尾进行排序</p>
</li>
<li>
<ul>
<li><code>!</code>: 翻转顺序, 默认小在前, 翻转后大在前</li>
<li><code>i</code>: 忽略大小写</li>
<li><code>l</code>: ...</li>
<li><code>n</code>: ...</li>
<li><code>o</code>: ...</li>
<li><code>r</code>: ...</li>
<li><code>u</code>: ...</li>
<li><code>x</code>: ...</li>
</ul>
</li>
<li>
<p><code>:2,$ !sort -t',' -k2</code>: 使用外部 <code>sort</code> 程序进行排序, 以 <code>,</code> 为分隔符, 以第二项进行排序</p>
</li>
</ul>
<h2 id="insert-模式"><strong>Insert 模式</strong></h2>
<ul>
<li><code>&lt;C-p&gt;</code>: 选择上方补全</li>
<li><code>&lt;C-n&gt;</code>: 选择下方补全</li>
<li><code>⎋</code>: 退出插入模式(推荐)</li>
<li><code>&lt;C-c&gt;</code>: 退出插入模式</li>
<li><code>&lt;C-[&gt;</code>: 退出插入模式</li>
<li><code>&lt;C-u&gt;</code>: 向左删除到行首</li>
<li><code>&lt;C-w&gt;</code>: 向左删除一个单词</li>
<li><code>&lt;C-h&gt;</code>: 向左删除一个字符</li>
<li><code>&lt;C-t&gt;</code>: 整行向右偏移</li>
<li><code>&lt;C-d&gt;</code>: 整行向左偏移</li>
<li><code>&lt;C + r&gt;= &lt;function&gt;</code>: 进行计算并将结果输出到当前缓冲区中</li>
<li><code>&lt;C-v&gt;065</code>: 输入大写字母 A</li>
<li><code>&lt;C-v&gt;u{123}</code>: 按照 unicode 码以 10 进制来输入</li>
<li><code>&lt;C-v&gt;u{1234}</code>: 按照 unicode 码以 16 进制来输入</li>
<li><code>&lt;C-v&gt; &lt;Tab&gt;</code>: 无论 <code>expandtab</code> 选项是否开启都会插入制表符</li>
<li>插入模式中的粘贴操作参考这里</li>
</ul>
<h2 id="路径"><strong>路径</strong></h2>
<p>vim 的工作路径是使用中要格外注意的地方, 简单来说, 终端中的 vim 默认会把终端当前的路径作为其工作路径, 当然我们可以使用 <code>cd</code> 使其工作路径变更</p>
<ul>
<li><code>:cd [path]</code>: 设置此次vim的工作目录为path</li>
<li><code>:cd %:h</code>: cd 到当前缓冲区所属目录中</li>
<li><code>:cd ../</code>: cd 到上一级</li>
<li><code>:pwd</code>: 显示当前工作路径</li>
<li><code>:lcd [path]</code>: 设置当前窗口的工作目录为 path(与 cd 不同的是只会改变当前 window 的工作路径, 其他 window 的不受此影响)</li>
</ul>
<p>vim 为我们提供了一些可以使用的宏用来表示相关路径或文件名称:</p>
<ul>
<li><code>%:h</code>: 表示当前文件所在目录的相对工作目录路径(不含文件名及扩展)</li>
<li><code>%:p</code>: 表示当前文件所在目录的绝对路径(含文件名及扩展)</li>
<li><code>%:t</code>: 文件名及扩展</li>
<li><code>%:r</code>: 移除扩展之后的所有内容</li>
<li><code>%:e</code>: 扩展名</li>
</ul>
<p>在使用以上这几种宏时, 我们可以使用 <code>&lt;Tab&gt;</code> 使其自动展开, 有些命令不支持自动展开的话需要使用 <code>expand()</code> 命令</p>
<ul>
<li><code>echo expand('%:e')</code>: 打印当前文档扩展名, markdown 是 <code>md</code></li>
<li><code>cd %:h&lt;Tab&gt;</code>: cd 到当前缓冲区所属目录中, 在最后可以使用 <code>&lt;Tab&gt;</code> 进行自动展开</li>
<li><code>e %&lt;Tab&gt;</code>: 会自动扩展为当前文件含相对工作目录的路径全名</li>
</ul>
<h2 id="寄存器"><strong>寄存器</strong></h2>
<p>寄存器是 vim 的一种特有概念, 其他文本编辑器默认都会用系统剪贴板作为复制粘贴的根据地, 然后 vim 另辟蹊径使用多种不同类型寄存器作为临时内容存储位置. 我们可以在复制粘贴时使用指定的寄存器定制化我们的需求, 也可以在录制宏及使用宏时指定寄存器, 大大地提高了我们的工作效率.</p>
<p>很多刚使用 vim 的人会抱怨无法复制内容到 vim 外或 vim 内, 然后各种搜索如何使 vim 的默认复制操作与剪贴板交互, 最后定义了一大堆按键, 譬如 <code>&quot;*y</code>, <code>set clipboard=unnamed</code>, 其实大可不必, 寄存器是 vim 的高效操作方式之一, 接受了这种方式才能更好地利用 vim 来为我们服务(虽然刚开始适应的过程必然是痛苦的)</p>
<p>总的来说 Vim 的删除, 复制与粘贴命令以及定义宏时都会用到众多寄存器中的某一个. 可以通过给命令加 <code>&quot;{register}</code> 前缀的方式指定要用的寄存器. 若不指明, Vim 将缺省使用无名寄存器</p>
<ul>
<li>
<p>无名寄存器<br>
所有删除复制粘贴操作如果不显示指明寄存器类型的话使用的都是无名寄存器, 其标志符是 <code>&quot;&quot;</code>.</p>
</li>
<li>
<p>复制寄存器<br>
使用 <code>y</code> 复制后内容会被放到复制寄存器及无名寄存器中, 但是复制寄存器是稳定的, 无名寄存器的内容会时刻被重置替换. 其标志符是 <code>&quot;0</code></p>
</li>
<li>
<p>粘贴板寄存器<br>
用于与系统的其他应用中进行复制粘贴交互, 等于系统的剪贴板. 其标识符是 <code>&quot;*</code>(或 <code>&quot;+</code>)</p>
</li>
<li>
<p>黑洞寄存器<br>
所有放入黑洞寄存器的内容全部被丢弃, 相当于完全删除, 不留痕迹, 其标识符是 <code>&quot;_</code></p>
</li>
<li>
<p>有名寄存器<br>
以单个小写字母命名的寄存器, 可用于自定义存储空间, 一共有 26 个</p>
</li>
<li>
<p>特殊寄存器</p>
</li>
<li>
<ul>
<li><code>&quot;%</code>: 当前文件名</li>
<li><code>&quot;#</code>: 轮换文件名</li>
<li><code>&quot;.</code>: 上次插入的文本</li>
<li><code>&quot;:</code>: 上次执行的 Ex 命令</li>
<li><code>&quot;/</code>: 上次查找的模式</li>
</ul>
</li>
</ul>
<h3 id="使用方式"><strong>使用方式</strong></h3>
<ul>
<li><code>&quot;&quot;p</code>: 从无名寄存器中取值进行粘贴</li>
<li><code>&quot;ay</code>: 将内容复制到有名寄存器 <code>a</code></li>
<li><code>&quot;_y</code>: 将内容复制到黑洞寄存器, 相当于彻底地删除</li>
<li><code>&quot;ap</code>: 从自定义寄存器中取出内容进行粘贴</li>
<li><code>&quot;0p</code>: 从复制寄存器中取出内容进行粘贴, 默认的 p 是从无名寄存器取值</li>
<li><code>&quot;*p</code>: 从系统粘贴板寄存器中取出内容进行粘贴</li>
<li><code>&lt;C-r&gt;&quot;</code>: 在插入模式中将无名寄存器的内容粘贴进来</li>
<li><code>&lt;C-r&gt;*</code>: 在插入模式中将系统粘贴板寄存器的内容粘贴进来</li>
<li><code>&lt;C-r&gt;0</code>: 在插入模式中将复制寄存器的内容粘贴进来</li>
<li><code>&lt;C-r&gt;%</code>: 插入当前文件名(因为 &quot;% 寄存器中存储了当前文件名)</li>
<li><code>:reg a</code>: 查看有名寄存器 <code>a</code> 的内容</li>
<li><code>:reg *</code>: 查看粘贴板寄存器 <code>*</code> 的内容</li>
<li><code>:reg &quot;</code>: 查看无名寄存器 <code>&quot;</code> 的内容</li>
<li><code>:put a</code>: 将有名寄存器 <code>a</code> 的内容粘贴到当前缓冲区中, 与 <code>&quot;ap</code> 不同的是 <code>p</code> 用于只能在光标之前或光标之后进行粘贴, 但是 <code>put</code> 则会始终将内容粘贴到新的一行上</li>
<li><code>:d a</code>: 将内容删除到有名寄存器 <code>a</code> 中</li>
</ul>
<blockquote>
<p>❝使用 Visual Mode 时, 在选中的文本上使用 <code>p</code> 将直接替换该部分文本(替换后被替换的文本会被放入到无名寄存器中), 可用于解决需要删除然后粘贴但是会影响到无名寄存器的问题</p>
</blockquote>
<h2 id="vimdiff"><strong>vimdiff</strong></h2>
<figure data-type="image" tabindex="1"><img src="https://pic4.zhimg.com/80/v2-7b7f72df7db5d10e3d73ab21c15246bb_1440w.webp" alt="img" loading="lazy"></figure>
<p>git 与 vim 可以说是非常好的一对搭档了, 平时在终端中提交 commit 我们都少不了与 <code>vim</code>打交道, vimdiff 是 vim 提供的专门用于修正 git 冲突文件的一款工具</p>
<p>若想使用 vimdiff 作为冲突修改工具, 需要设置 <code>~/.gitconfig</code> 的以下项</p>
<pre><code class="language-text">[diff]
    tool = vimdiff
[merge]
    tool = vimdiff
</code></pre>
<p>在 vimdiff 中, 一共有四个窗口, 上面依次是 <code>LOCAL</code>, <code>BASE</code>, <code>REMOTE</code>, 底部则是一个最终的文件结果窗口, 整个过程我们只需要将光标在最下方窗口上上下移动, 使用 <code>diffget</code> 命令从 <code>LOCAL</code>, <code>BASE</code>, <code>REMOTE</code> 中选择需要使用哪一个作为本行的最终结果(当然也可以跳到上面的窗口中使用 diffput 放置结果到底部窗口上</p>
<ul>
<li><code>:diffget LOCAL</code>: 选择 LCOAL 作为本行最终结果</li>
<li><code>:diffget REMOTE</code>: 选择 REMOTE 作为本行最终结果</li>
<li><code>:diffget BASE</code>: 选择 BASE 作为本行最终结果</li>
<li><code>:diffput [num]</code>: 放置结果到缓冲区上, <code>num</code> 为缓冲区编号</li>
<li><code>:diffg L</code>: 这里 vim 为我们做了简略命令, 同样可用于 <code>REMTOE</code> 与 <code>BASE</code> 上</li>
<li><code>dp/do</code>: 如果只有两个文件则可以使用 <code>dp/do</code> 来替代 <code>:diffput/:diffget</code></li>
<li><code>:ls!</code>: 显示当前所有缓冲区的号码</li>
<li><code>[c</code>: conflict, 移动到上一个冲突处</li>
<li><code>]c</code>: conflict, 移动到下一个冲突处</li>
<li><code>:wqa</code>: 冲突修复完成保存退出, 如果仍然有文件冲突则进入下一个冲突</li>
<li><code>$git merge --continue</code>: 冲突全部解决完后在外界终端中使用 <code>git merge --continue</code>继续之前的 <code>merge</code> 操作</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[vs2019连接本地虚拟机linux]]></title>
        <id>https://tangyin1.github.io/post/vs2019-lian-jie-ben-di-xu-ni-ji-linux/</id>
        <link href="https://tangyin1.github.io/post/vs2019-lian-jie-ben-di-xu-ni-ji-linux/">
        </link>
        <updated>2023-10-31T11:13:55.000Z</updated>
        <summary type="html"><![CDATA[<p>今天准备使用vs2019远程连接Linux进行一些小玩意，结果死活连不上。捣鼓了一会终于成功！</p>
]]></summary>
        <content type="html"><![CDATA[<p>今天准备使用vs2019远程连接Linux进行一些小玩意，结果死活连不上。捣鼓了一会终于成功！</p>
<!-- more -->
<p>正常的步骤是 先在linux下下载ssh</p>
<p>执行</p>
<p><code>sudo apt install openssh-server</code>----下载ssh</p>
<p><code>sudo service ssh start</code>----启动ssh服务</p>
<p>然后</p>
<p>在 Visual Studio 中，依次选择菜单栏上的“工具”&gt;“选项”，以打开“选项”对话框。 然后，依次选择“跨平台”&gt;“连接管理器”，以打开“连接管理器”对话框</p>
<p>在“连接管理器”对话框中，选择“添加” 按钮，以添加新连接</p>
<p>然后按照要求填主机名 用户名 密码</p>
<p>正常来说到了这一步基本上就没啥了，会添加成功。但我今天死活都添加不上。</p>
<p>后面捣鼓了好久才发现一个解决办法    那就是    -------防火墙</p>
<p>可能是Windows和linux下面的防火墙把22端口给墙了，</p>
<p>于是乎我直奔防火墙进行修改</p>
<p>在windows下面</p>
<p>要在防火墙上打开SSH端口，你可以按照以下步骤进行操作：</p>
<ol>
<li>打开开始菜单并搜索&quot;Windows Defender 防火墙&quot;，然后打开防火墙设置。</li>
<li>在防火墙设置窗口中，点击&quot;高级设置&quot;链接。</li>
<li>在高级安全设置窗口中，你将看到&quot;入站规则&quot;和&quot;出站规则&quot;两个选项。这些规则控制了进入和离开计算机的网络流量。</li>
<li>如果你的虚拟机是在本地网络中，你需要在&quot;入站规则&quot;中创建一个新规则。右键点击&quot;入站规则&quot;，然后选择&quot;新建规则&quot;。</li>
<li>在新建入站规则向导中，选择&quot;端口&quot;选项，然后点击&quot;下一步&quot;。</li>
<li>选择&quot;特定本地端口&quot;，并输入SSH使用的端口号（默认为22）。点击&quot;下一步&quot;。</li>
<li>选择&quot;允许连接&quot;，然后点击&quot;下一步&quot;。</li>
<li>在&quot;配置配置文件&quot;中，选择适用于你的网络配置的选项。如果你不确定，可以选择默认选项&quot;域网络、专用网络和公用网络&quot;。点击&quot;下一步&quot;。</li>
<li>输入规则的名称和描述（可选），然后点击&quot;完成&quot;。</li>
</ol>
<p>在linux下</p>
<p>进入root模式</p>
<p>检查防火墙规则：运行以下命令查看当前的iptables规则：</p>
<p><code>sudo iptables -L</code></p>
<p>然后一看好像真没关于ssh 22的端口</p>
<p>于是</p>
<ul>
<li>
<p>允许SSH连接：如果没有针对SSH连接的规则，可以运行以下命令添加规则：</p>
<pre><code>sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT
</code></pre>
</li>
<li>
<p>保存规则：如果你的Linux虚拟机重启后需要保留规则，你需要保存iptables规则。运行以下命令保存规则：</p>
<pre><code>sudo iptables-save &gt; /etc/iptables/rules.v4
</code></pre>
</li>
</ul>
<p>然后再使用vs2019连接，连接成功！</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[搜索方法分享]]></title>
        <id>https://tangyin1.github.io/post/sou-suo-fang-fa-fen-xiang/</id>
        <link href="https://tangyin1.github.io/post/sou-suo-fang-fa-fen-xiang/">
        </link>
        <updated>2023-10-28T13:00:20.000Z</updated>
        <summary type="html"><![CDATA[<p>关于现在搜索能力的一些信息</p>
]]></summary>
        <content type="html"><![CDATA[<p>关于现在搜索能力的一些信息</p>
<!-- more -->
<h3 id="搜索方式的选择">搜索方式的选择</h3>
<h5 id="谷歌bing微信公众号短视频平台搜狗-百度等一系列国内搜索引擎">谷歌&gt;bing&gt;微信公众号&gt;短视频平台&gt;搜狗、百度等一系列国内搜索引擎</h5>
<h3 id="搜索技巧">搜索技巧</h3>
<h4 id="1关键字-限定关键字">1.关键字 +&quot;&quot;  （限定关键字）</h4>
<p>有时候想快速搜索到自己<font color='red'>想要</font>的东西，但有时会被大量搜索信息覆盖掉自己想要的信息时，这时只需要在需要搜索的词语加上英文的双引号就可以。</p>
<p>列如你想搜索  <font color='red'>易阳千喜</font> 并不是那个明星 <strong>易烊千玺</strong> 时，不加&quot;&quot;会出现大量关于易烊千玺的信息，这时候加上<font color='red'>&quot;&quot;</font>会减少大量不需要的信息。</p>
<h3 id="2intitle-限定标题">2.intitle （限定标题）</h3>
<p>在检索信息的时候，一般都是标题加上精简内容出现在我们的面前，有时候搜索相关标题会更好的让我们找到相关的文章或者其他内容。</p>
<p>使用方法： intitle :+你所需要搜索的内容</p>
<p>但这种只能限定一个关键字段</p>
<h3 id="3allintitle-限定标题多个关键字">3.allintitle (限定标题多个关键字)</h3>
<p>使用方法与intitle一样，但可以包含多个关键字</p>
<h3 id="4intext限定内容关键字">4.intext(限定内容关键字)</h3>
<p>搜索相关文章信息中的关键字，由于有时候网上标题党过多，内容并没有自己想要的内容，这时候再加上intext会更加精准的搜索到自己想要的内容，比如想要搜索标题含有李佳琪但内容中含有哭泣的信息，这时候就要搜索栏上输入</p>
<p>intitle:&quot;小杨哥&quot; intext:&quot;哭泣&quot;</p>
<h3 id="5inurl限定网址关键字">5.inurl(限定网址关键字)</h3>
<p>例如：搜索</p>
<p>李子柒 inurl:cctv</p>
<p>搜索到关于的都是关于cctv对李子柒的采访报道等</p>
<p>在这里再加一个网站：SimilarSites 可以搜索一个网站相似内容的网址、例如在里面搜索：www.bilibili.com</p>
<p>会出现youtube，知乎等和b站有着相似度的网址。</p>
<h3 id="6site限定网址来源">6：site(限定网址来源)</h3>
<p>后面需要接完整的域名，例如cctv.com bilibili.com</p>
<h3 id="7imagesize-限定图片尺寸大小">7.imagesize (限定图片尺寸大小)</h3>
<p>搜索语法：【搜索图片】+imagesize:[尺寸大小]</p>
<p>列如：</p>
<p>黑丝 imagesize:2903x1440</p>
<h3 id="8filetype-限定文件格式">8.filetype （限定文件格式）</h3>
<p>例如：研究报告 filetype:pdf</p>
<p>在搜索图片的时候也可以限定要的格式 例如 小猫咪 filetuype:jpg</p>
<h2 id="关于资源搜索方法">关于资源搜索方法</h2>
<h3 id="1电子书">1.电子书</h3>
<p>在国内建议使用，微信读书、得到、网站的话使用鸠摩搜书</p>
<p>使用谷歌的话，就直接搜  best free ebook download sistes 大部分出现的z-library      manybooks等</p>
<p>论文搜索 ：谷歌学术  scihub</p>
<h3 id="2ppt">2.PPT</h3>
<p>1.iSlide插件</p>
<p>2.canva.com（这是个非常好用的网址）</p>
<h3 id="3软件">3.软件</h3>
<p>https://alternativeto.net/</p>
]]></content>
    </entry>
</feed>